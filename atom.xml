<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>linjiang&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linjiang.tech/"/>
  <updated>2023-01-13T08:47:24.487Z</updated>
  <id>https://linjiang.tech/</id>
  
  <author>
    <name>linjiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin：委托 和 动态代理 的奇妙组合</title>
    <link href="https://linjiang.tech/2020/04/08/kotlin-delegate-with-proxy/"/>
    <id>https://linjiang.tech/2020/04/08/kotlin-delegate-with-proxy/</id>
    <published>2020-04-08T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>Callback是事件驱动的灵魂，Interface作为具体形式服务于各种场景。但是对于包含多个方法的接口，即使只会用到其中一个，也不得不容忍大量的空方法实现样板代码；当然我们可以创建一个公共的中间类预先实现需要的接口，其它地方使用时就可以直接继承该中间类并只需重写需要的方法即可，然而这样又会产生占用继承位、不同的接口需要不同的中间类等新问题，那么到了kotlin这儿又会有怎样的解决方案？<br><br />这里以 AnimatorListener 为例，直接展示最终的解决方案：<br /></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Any&gt;</span> <span class="title">noOpDelegate</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> javaClass = T::<span class="keyword">class</span>.java</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(javaClass.classLoader, arrayOf(javaClass)) &#123;_,_,_ -&gt;</span><br><span class="line">    &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line"><span class="comment">// 重写关心的方法即可</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br /><br><br />意犹未尽？😝</p>]]></content>
    
    <summary type="html">
    
      Callback是事件驱动的灵魂，Interface作为具体形式服务于各种场景。但是对于包含多个方法的接口，即使只会用到其中一个，也不得不容忍大量的空方法实现样板代码；当然我们可以创建一个公共的中间类预先实现需要的接口，其它地方使用时就可以直接继承该中间类并只需重写需要的方法即可，然而这样又会产生占用继承位、不同的接口需要不同的中间类等新问题，那么到了kotlin这儿又会有怎样的解决方案？
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://linjiang.tech/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="https://linjiang.tech/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin：分析 ?. 的实现对空安全的保证</title>
    <link href="https://linjiang.tech/2020/04/01/kotlin-nullable-infered/"/>
    <id>https://linjiang.tech/2020/04/01/kotlin-nullable-infered/</id>
    <published>2020-04-01T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>空安全是Kotlin特性之一，本文以一个常见的“错误”推导场景为例来分析 ?. 的实现。</p><p>使用kotlin开发时可能大家都遇到过这种情况：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> user: User? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        user.hello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>IDE 会提示 user.hello() 这一行语法错误，我们必须显式使用 <code>!!</code> 或者 <code>?.</code> 来解决，也就是说 IDE 认为 user 变量依然可能为null。“怎么可能，我明明已经在外层手动判断了 user 不为 null ”，这可能是我们首先想到的，然后开始巴拉这个「智能推导」实际是智障。</p><p>这其实并不是推导算法出现了 BUG，而是 user 确实无法被推导，原因就在于 user <strong>作为一个共享变量，任意时刻都存在被其它线程修改的可能性</strong>，也就是说即使前面进行了 null 判断，也不能保证在执行 hello 方法时的这一刻 user 一定不为 null，因此这种情况需要我们手动处理。如果我们确定 user 只会被一个线程操作，那么可以使用 <code>!!</code> 来明确告知以通过编译，否则应选择 <code>?.</code> 保证user字段的安全调用。</p><h2 id="的实现"><a href="#的实现" class="headerlink" title="?. 的实现"></a>?. 的实现</h2><p>但是这里又会产生一个新疑问：我们知道 <code>?.</code> 其实就是针对类似 <code>if(x != null) &#123;x.xx&#125;</code> 这样的语法而提炼的糖，既然 user 任何时候都可能为 null，为什么语法糖 <code>?.</code> 能严格保证不会出现空指针异常？万千疑惑不如从反编译后的 Java 文件寻找答案：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> void main() &#123;</span><br><span class="line">    User var10000 = <span class="keyword">this</span>.user;</span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="literal">null</span>) &#123;</span><br><span class="line">        var10000.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是对 <code>user?.hello()</code> 的 de-sugar，我们可以清楚地看到其背后实际的逻辑：通过定义一个临时局部变量指向 user 变量对应的对象，然后后续的判断和执行都是调用的这个局部变量。<br />定义临时局部变量来避免一些并发问题的操作非常常见，由于局部变量只属于被定义时的线程环境所有，其它线程无法对其进行修改，<code>var10000</code> 是否为 null 只取决于定义后赋值的这一刻 user 的值，因此后续无论 user 的指向如何变化，都不会再影响变量 <code>var10000</code> 的值，只要这个局部变量不为 null，调用 hello 方法时肯定不会导致空指针异常。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到此这个由推导引出的疑问算是有了最终答案。现在我们回顾在此之前的解决方式，可以明显发现是存在潜在问题的：<strong>我们在判断 user 不为 null 之后直接使用 user!!.hello() 依然存在空指针异常的可能性</strong>。因此最后再次强调：仅当我们确认所操作的变量一定安全，否则对 <code>!!</code> 要慎重使用。<br /></p>]]></content>
    
    <summary type="html">
    
      空安全是Kotlin特性之一，本文以一个常见的“错误”推导场景为例来分析 ?. 的实现。
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://linjiang.tech/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="https://linjiang.tech/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>对 mmap 的理解</title>
    <link href="https://linjiang.tech/2020/03/04/mmap/"/>
    <id>https://linjiang.tech/2020/03/04/mmap/</id>
    <published>2020-03-04T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>mmap 经常出现在对性能有要求的模块，Android系统中特有的进程间通信binder机制核心原理也是基于其实现，本文旨在以一种相对浅显易懂的方式来理清mmap的作用和高效的原因。</p><p><a name="VVsgE"></a></p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>早期操作系统运行程序时是直接将整个程序加载到物理内存，并且程序内访问到的内存地址也是真实的物理地址。这就导致了一些严重的问题，例如程序（进程）间的内存可以相互访问导致安全问题、内存的随机划分导致程序每次运行的实际地址不确定等等。</p><p>为了解决这些问题，虚拟地址空间的概念被提出。进程访问到的内存地址将不再是真实的物理地址，取而代之的是一组逻辑上的连续地址空间，并且对每个进程都一样，操作系统内部通过MMU负责将物理内存地址与虚拟地址建立映射关系，从进程角度来看，它可以访问一组地址固定且连续的内存空间，至于这块地址到底是被映射至RAM的哪一块、或者来自磁盘还是其它内存缓存是不知道的，因此也就不会错误或有意访问到其它进程的内存地址。</p><p>此外，一次性将整个程序（文件）加载到内存也会使得可运行的程序个数有限，内存无法得到很好的利用。实际上大部分情况在小段时间内只会用到文件的少部分数据，对此的解决方案就是分页，并采用以页为单位的页缓存技术。地址空间逻辑上被划分为了很多页，进程需要访问某个文件时，通过内核从磁盘上加载到内存都是按页加载，需要用到哪一页就加载并缓存相关页及其相邻页。</p><p><a name="VU7Hd"></a></p><h3 id="内核-用户空间"><a href="#内核-用户空间" class="headerlink" title="内核/用户空间"></a>内核/用户空间</h3><p>上面说到进程加载文件需要通过内核来实现，这是操作系统从安全（例如防止因为某个进程调用了不当指令就造成整个系统崩溃）角度考虑和设计的。普通用户进程操作和系统资源请求被区分开来，直接负责系统资源请求的部分由操作系统的内核实现，内存划分了一部分专门给内核使用，作为内核缓冲区，规定只有内核才有对底层硬件设备的所有控制权限，可以执行任何CPU指令，用户进程只能通过内核提供的相应接口间接发起系统调用。因此虚拟地址空间也需要划分一部分用于映射内核使用的缓冲区，称为内核空间，剩余部分则被称为用户空间，顺便虚拟地址空间也达到了将内核空间和用户空间隔离的效果。这样每个进程都对应一组相同虚拟地址空间，其中内核空间全都映射到同一块物理内存，对所有进程一样，用户空间则被映射到不同的物理内存区域，各自独立。</p><p>当用户进程需要调用系统资源时，例如读取某个文件，就会通过内核提供的接口发起系统调用进入内核态，内核首先会从磁盘将文件读取到自身所在的内核空间，然后再从内核空间拷贝到进程所在的用户空间，最后切换回用户态，完成本次操作；当然对于写文件，也是类似操作，数据经历从用户空间到内核空间再到磁盘整个过程。由此我们可以看到，不管是读还是写文件，数据都经历了两次拷贝，在效率上是有一定损耗的，对于有高性能需求的场景中，传统的文件操作并不可靠，因此很多高性能模块在设计中都采用了 mmap 方案。</p><p><a name="QtQHZ"></a></p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>mmap 是一种内存映射技术，可以将文件或对象映射到进程的内存地址空间，使得进程就像操作内存一样实现了“直接”对文件的高效读写。本质上来讲， <strong>mmap 实现的是内核缓冲区与用户进程的地址空间的映射</strong>，也就是说用户进程通过操作自己的逻辑虚拟地址就可以实现操作内核空间缓冲区，这样就不用再因为内核空间和用户空间相互隔离而需要将数据在内核缓冲区和用户进程所在内存之间来回拷贝。<br /></p><p>mmap 属于操作系统提供的标准API，具体实现由操作系统完成，有一些比较值得注意的点：</p><ul><li>mmap 在建立映射之初并没有物理内存分配，仅仅是从虚拟地址空间上划分出用于映射的区间并初始化相关数据结构，仅当首次读写文件触发缺页中断时才会开始分配内存并从磁盘读取文件数据，最后将分配物理内存的地址映射到用户进程的地址空间。</li><li>由于分页机制，加载到内存的文件数据都是按页映射到虚拟地址空间，如果文件大小和页大小不是整数倍关系，则最后一页多余的部分会被填充补齐，则可能导致读写文件后最终文件实际内容存在乱码。</li><li>由于在调用 mmap 方法时需要指定映射的大小，因此写文件的数据总大小是不能超过指定的大小的，即无法动态扩展。</li></ul><p>我们重新回顾上面的读取文件的操作，当操作系统按页从磁盘加载文件到内核缓冲区后，由于该内存与用户进程地址空间存在直接映射，因此数据不用再经历内核空间到用户空间的拷贝操作，直接比标准的文件读取行为少了1次拷贝；对于写文件也是同理，用户进程对文件的修改行为直接反映到内核缓冲区上，无需再经历从用户空间到内核空间的拷贝，并且操作系统会自动对脏页面进行回写到磁盘文件，保证数据的可靠性。</p><p><a name="pEQTr"></a></p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>作为Android系统进程间通信的实现，binder的核心实现也依赖 mmap 技术。前面说到虚拟内存地址空间将进程相互隔离，因此进程间通信必须通过内核空间中转，Android系统在启动时，内核会完成对binder驱动模块的加载，由binder驱动负责具体的IPC。当进行binder通信时，位于内核的binder驱动首先会开辟一块物理内存，然后在接收方进程的虚拟地址空间寻找一块空余区间与该物理地址建立映射，同时在内核的虚拟地址空间也划分一块区间与该物理地址建立映射，最后当发送方将数据通过划分的内核地址空间拷贝到内核中对应的物理内存时，由于该物理内存也映射到了接收方进程的虚拟地址空间，因此也相当于该数据被拷贝到了接收方进程用户空间，直接完成了进程间通信需求，整个过程只有1次从发送方进程用户空间到内核空间的拷贝操作。</p><p><a name="VieTX"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>弄清楚 mmap 最主要是要理解虚拟地址空间的含义，这里说的空间只是一串数字而不是物理内存，我们可以把虚拟地址空间看作运营商的一系列电话号码，号码用户就可以看作是真实的物理内存，这些电话号码在任意时刻是否被卖出（使用），是A在使用还是B在使用都是动态变化的。mmap的行为就是找出未使用的电话号码分配给用户，不管这个用户在哪里（用户空间还是内核空间）都可以被呼叫。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/sparkdev/p/8410350.html">Linux 内核空间与用户空间</a></li><li><a href="https://nieyong.github.io/wiki_cpu/mmap%E8%AF%A6%E8%A7%A3.html">mmap详解</a></li><li><a href="http://wuwenliang.net/2020/02/11/%E8%B7%9F%E6%88%91%E5%AD%A6RocketMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8EMmap/">RocketMQ之消息持久化原理与Mmap</a></li></ul>]]></content>
    
    <summary type="html">
    
      mmap 经常出现在对性能有要求的模块，Android系统中特有的进程间通信binder机制核心原理也是基于其实现，本文旨在以一种相对浅显易懂的方式来理清mmap的作用和高效的原因。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="performance" scheme="https://linjiang.tech/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>优化 Gradle 构建速度汇总</title>
    <link href="https://linjiang.tech/2020/02/26/gradle-build/"/>
    <id>https://linjiang.tech/2020/02/26/gradle-build/</id>
    <published>2020-02-26T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列了目前社区中常规的 gradle 构建速度优化方案，作为开发的参考。<br>更新于：2020-2-26</p><p><a name="2hPkS"></a></p><h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p><a name="WQV9Q"></a></p><h4 id="1-daemon"><a href="#1-daemon" class="headerlink" title="1. daemon"></a>1. daemon</h4><p>无需每次执行构建相关任务时都重新启动一个新的gradle进程，从而增加了相应的非必要耗时。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目的gradle.properties 增加 </span></span><br><span class="line">org.gradle.daemon=<span class="literal">true</span> </span><br><span class="line"><span class="comment">// 或通过命令行传递参数 </span></span><br><span class="line">./gradlew --daemon</span><br></pre></td></tr></table></figure><br>如果在长时间多次编译后速度变得缓慢，可以通过 <code>./gradlew --stop</code> 结束已有daemon进程。</p><p><a name="6dQcW"></a></p><h4 id="2-parallel"><a href="#2-parallel" class="headerlink" title="2. parallel"></a>2. parallel</h4><p>基本上大部分项目都包含了多个module，gradle默认情况下是串行执行的，可以通过以下方式开启并行构建，可以加入参数 –profile 在生成的html中看到total build time 和 task execution的时间差异。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目的gradle.properties 增加 </span></span><br><span class="line">org.gradle.parallel=<span class="literal">true</span> </span><br><span class="line"><span class="comment">// 或通过命令行传递参数 </span></span><br><span class="line">./gradlew --parallel</span><br></pre></td></tr></table></figure></p><p><a name="32cGr"></a></p><h4 id="3-configure-on-demand"><a href="#3-configure-on-demand" class="headerlink" title="3. configure on demand"></a>3. configure on demand</h4><p>gradle的构建包含初始化、配置、执行三大流程，CoD用于配置阶段，仅配置与所选任务相关的module。<br />例如module-A compile module-B，则B会被配置；或者task-A dependOn module-B‘s task 则B也会被配置。</p><blockquote><p>但是我们大部分情况是在IDE中执行的 <code>sync</code> 触发了配置所有module，因此CoD并没起什么作用。Gradle团队也决定废弃它，并计划通过一个新的模式来替代：<a href="https://github.com/gradle/gradle/issues/2868#issuecomment-384373780">issue</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目的gradle.properties 增加 </span></span><br><span class="line">org.gradle.configureondemand=<span class="literal">true</span> </span><br><span class="line"><span class="comment">// 或通过命令行传递参数 </span></span><br><span class="line">./gradlew --configure-on-demand</span><br></pre></td></tr></table></figure><p><a name="NAwuA"></a></p><h4 id="4-offline"><a href="#4-offline" class="headerlink" title="4. offline"></a>4. offline</h4><p>每次构建都会去下载本地缓存没有的依赖或检查缓存已有依赖是否存在最新版本，另外一些三方插件在构建期间也会发起网络请求，例如一些会上传匿名统计信息、一些会上传混淆的mapping文件等等。但是由于国内糟糕的网络环境，网络经常超时重试占用大量构建时间。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在IDE中的gradle panel里 toggle offline mode</span></span><br><span class="line"><span class="comment">// 2. 或通过命令行传递参数 </span></span><br><span class="line">./gradlew --offline</span><br></pre></td></tr></table></figure></p><p><a name="vd2pN"></a></p><h4 id="5-buildCache"><a href="#5-buildCache" class="headerlink" title="5. buildCache"></a>5. buildCache</h4><p>gradle的构建缓存机制 会缓存构建的输出（build-in 和 符合的三方task），并以输入作为参数生成唯一的key生成对应的缓存文件，这样在后续的构建过程中如果输入没有变化就可以直接利用这些缓存加快构建速度。<br /><strong>特别是clean之后重新构建时，实测有无缓存的时间相差将近 2/3 </strong>。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目的gradle.properties 增加 </span></span><br><span class="line">org.gradle.caching=<span class="literal">true</span> </span><br><span class="line"><span class="comment">// 或通过命令行传递参数 </span></span><br><span class="line">./gradlew --build-cache</span><br><span class="line"><span class="comment">// 如果在开启了caching，想临时测试关闭构建缓存的执行效果</span></span><br><span class="line">./gradlew --no-build-cache</span><br></pre></td></tr></table></figure></p><p>生成的缓存默认存储在 <code>&lt;user-home&gt;/.android/build-cache/</code> 可以通过以下方式进行修改或删除：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 修改位置：</span></span><br><span class="line"><span class="comment">// 在setting.gradle中增加</span></span><br><span class="line">buildCache &#123;</span><br><span class="line">    local &#123;</span><br><span class="line">        directory = new File(rootDir, <span class="string">&#x27;build-cache&#x27;</span>)</span><br><span class="line">        removeUnusedEntriesAfterDays = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 删除构建缓存：</span></span><br><span class="line">./gradlew cleanBuildCache</span><br></pre></td></tr></table></figure></p><p>与增量编译（incremental build）机制一个很明显的区别就是在构建的输出日志中，增量编译的task之后显示的是 <code>UP-TO-DATE</code> ，而构建缓存显示的是 <code>FROM-CACHE</code> 。</p><p><a name="BoMOz"></a></p><h4 id="6-jvmargs"><a href="#6-jvmargs" class="headerlink" title="6. jvmargs"></a>6. jvmargs</h4><p>由于构建所处的进程也是一个JVM，因此通常Java开发对JVM的调优参数也适用此构建进程，可以根据自身电脑的配置传递合适的jvm参数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目的gradle.properties 增加 </span></span><br><span class="line">org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p><a name="coFgH"></a></p><h3 id="AGP配置"><a href="#AGP配置" class="headerlink" title="AGP配置"></a>AGP配置</h3><p><a name="69wTG"></a></p><h4 id="1-minSdkVersion-21"><a href="#1-minSdkVersion-21" class="headerlink" title="1. minSdkVersion 21"></a>1. minSdkVersion 21</h4><p>64K问题导致针对5.0以下的设备需要通过multiDex方案来兼容，构建期间在拆分dex的同时还需要 花费一些时间 来决定哪些class需要放入primary dex以避免启动发生Crash。而从5.0开始虽然构建期间依然会拆分dex，但由于应用在安装时这些dex会被优化为一个 <code>.oat</code> 文件，也就无需再区分primary dex。<br />因此如果当前调试的设备版本&gt;=5.0，完全可以仅在debug下将 <code>minSdkVersion</code> 指定为 <strong>21</strong> 来避免前述的耗时。</p><p><a name="ADwtE"></a></p><h4 id="2-resConfigs"><a href="#2-resConfigs" class="headerlink" title="2. resConfigs"></a>2. resConfigs</h4><p>除非是针对不同语言或特定设备显示效果的特定测试，一般情况下我们开发环境仅包含一套资源即可，尽量减少aapt的编译耗时。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在app.gradle中的 defaultConfig 或特定 flavor 中</span></span><br><span class="line">resConfigs <span class="string">&quot;en&quot;</span>, <span class="string">&quot;xxhdpi&quot;</span></span><br></pre></td></tr></table></figure></p><p><a name="ihXbj"></a></p><h4 id="3-crunchPngs"><a href="#3-crunchPngs" class="headerlink" title="3. crunchPngs"></a>3. crunchPngs</h4><p>在构建期间 aapt 会自动对 png 图片进行压缩处理，但这在开发环境下一般是没必要的，因此可以停用。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在AGP3.0.0以下</span></span><br><span class="line">aaptOptions &#123;</span><br><span class="line">    cruncherEnabled <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从AGP3.0.0开始，buildType为debug时默认已经关闭，如果有自定义type，可增加如下</span></span><br><span class="line">crunchPngs <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p><a name="qD6p1"></a></p><h4 id="4-静态化"><a href="#4-静态化" class="headerlink" title="4. 静态化"></a>4. 静态化</h4><p>我们可能经常会将一些动态信息通过 app.gradle 配置写入到 manifest.xml 或 BuildConfig.java 文件中，例如绑定编译时间、git提交版本等，但是这些属性往往会触发全量构建，即使每次只是修改了一行项目内的代码。<br />因此在开发环境尽量避免这些行为，可以通过判断是否release来分别配置。</p><p><a name="Cg74p"></a></p><h3 id="Kotlin配置"><a href="#Kotlin配置" class="headerlink" title="Kotlin配置"></a>Kotlin配置</h3><p>现在很多项目都接入了Kotlin享受其带来的开发收益，但其编译速度却大受诟病，不过随着语言的迭代其编译速度也一直在优化。<br><a name="fHw0E"></a></p><h4 id="from-1-2-21"><a href="#from-1-2-21" class="headerlink" title="from 1.2.21"></a>from 1.2.21</h4><p>从该版本开始，Kotlin的编译任务也支持了 buildCache 特性，所以在开启buildCache 的前提下直接 <strong>升级到最新版本</strong> 就能享受到期带来的收益。<br />另外即使开启了buildCache，注解处理器 kapt 的缓存默认也是禁用的，因此需要手动开启：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    useBuildCache = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="1Afhv"></a></p><h4 id="from-1-2-60"><a href="#from-1-2-60" class="headerlink" title="from 1.2.60"></a>from 1.2.60</h4><p>从该版本开始，对kapt利用gradle的work api实现并行任务处理进行了优化，开启方式如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在gradle.properties 中</span></span><br><span class="line">kapt.use.work.api=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><a name="yDkil"></a></p><h4 id="from-1-3-20"><a href="#from-1-3-20" class="headerlink" title="from 1.3.20"></a>from 1.3.20</h4><p>从该版本开始，针对kapt引用了 Compile Avoidance 特性来避免一些情况下的注解处理任务，具体<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance">规则链接</a>。但前提是需要注解处理器显式地声明使用kapt处理，因此通过以下方式来禁止在编译路径下自动搜索注解处理器：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在gradle.properties 中</span></span><br><span class="line">kapt.include.compile.classpath=<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p><a name="DFDXP"></a></p><h4 id="from-1-3-30"><a href="#from-1-3-30" class="headerlink" title="from 1.3.30"></a>from 1.3.30</h4><p>从该版本开始，kapt支持增量注解处理，通过以下方式开启：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在gradle.properties 中</span></span><br><span class="line">kapt.incremental.apt=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>截止目前（1.3.61），以上特性由于还处于实验阶段，因此需要手动开启，不过随着版本的更新优化还在继续，也许在今后的某些版本中就会修改为默认开启。</p><p><a name="zdJ0N"></a></p><h3 id="其它实践"><a href="#其它实践" class="headerlink" title="其它实践"></a>其它实践</h3><p><a name="mMkjy"></a></p><h4 id="1-版本问题"><a href="#1-版本问题" class="headerlink" title="1. 版本问题"></a>1. 版本问题</h4><p>对于AS 和 AGP，除了新需求外新版本相对老版本一般都有性能方面的优化。</p><ul><li>例如老版的AS对于包含多个buildType和flavor配置的项目，每次sync都会将所有组合同步一遍（可以在build目录中看到所有组合的相关目录），非常耗时，而从AS3.3 + AGP3.3.0开始，在gradle文件发生变化时默认仅sync当前指定的flavor。</li><li>又如AGP 3.5.0 和AS 3.5.0 实施了 Project Marble 计划，主要针对的就是对构建速度的优化。</li></ul><p>因此在没有严重BUG的情况下，保持开发环境为最新版本能得到最新的性能优化。</p><p><a name="2bdjK"></a></p><h4 id="2-精简module"><a href="#2-精简module" class="headerlink" title="2. 精简module"></a>2. 精简module</h4><p>每增加一个module（模块）都会引入对应的 初始化 和 配置 tasks，大量的模块会对整个构建时间产生不可忽略的影响。可以挨个审查项目中的模块，能移除的尽量移除；对于基本上不会变动的模块，可以考虑打包为aar形式的依赖，AGP的构建缓存机制可以对其进行<a href="https://developer.android.com/studio/build/build-cache#disable_build_cache">缓存</a>以提升构建速度。</p><p><a name="U4gZM"></a></p><h4 id="3-三方库"><a href="#3-三方库" class="headerlink" title="3. 三方库"></a>3. 三方库</h4><p><a name="PLhUI"></a></p><h5 id="Firebase-Crashlytics-Fabric"><a href="#Firebase-Crashlytics-Fabric" class="headerlink" title="Firebase Crashlytics (Fabric)"></a>Firebase Crashlytics (Fabric)</h5><p>Crashlytics是用于收集bug的sdk，在国内使用也相当普遍，但是以下注意点会对构建速度产生影响：<br />crashlytics 会在每次构建期间构造一个ID来标识唯一性，但该ID是存储在manifest中所以会导致全量构建，可以在 buildType 中使用  <code>ext.alwaysUpdateBuildId = false</code> 在开发期间关闭。</p><p><a name="yTZ9k"></a></p><h4 id="4-command-line"><a href="#4-command-line" class="headerlink" title="4. command-line"></a>4. command-line</h4><p>建议尽量通过命令行来执行构建任务。通过IDE形式开启构建会将任务的执行进度、状态以及日志等信息与UI进行同步，根据电脑配置的不同该方案对构建性能有一定的影响。</p><p><a name="De0B6"></a></p><h4 id="5-其它方案"><a href="#5-其它方案" class="headerlink" title="5. 其它方案"></a>5. 其它方案</h4><ul><li><a href="https://github.com/alibaba/freeline">freeline</a>：当年前东家的项目中集成使用过，在生效的基础上单从速度而言确实比当时的instant run快，可以缓解部分情况下的问题。但是由于增量条件严苛（例如需要建立app进程和电脑socket通信所以首次插上时得全量编译、资源变化也会降级为全量等等），再加上仍然存在BUG（例如显示生效了但app中并没有变化，此时只能全量重编）实际上不适合作为常规开发解决方案。</li><li><a href="https://github.com/typ0520/fastdex">fastdex</a></li></ul><p>虽然以上两种方式由于AGP的升级和一些其它限制导致事实上不再适用现在大部分项目，但其优化方案是值得学习和借鉴的。</p><p><a name="dORSb"></a></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong><code>--profile</code></strong> 可以获取当次构建的结果报告，包含所有task的具体执行时间，可以以此分析可优化的点；生成的文件一般位于项目根路径下的 reports 目录下。<br /><strong><code>--info</code></strong> 可以获得更详细的构建输出日志，例如其中就包含了一些task为什么被执行的原因。<br /><strong><code>&gt;&gt; &lt;file path&gt;</code></strong> 构建过程的日志非常多，难以详细定位，可以通过该方式将日志输出到指定的文件中。</p><p>针对某一项的优化措施需要排除其它因素干扰，可以通过以下方式获取全量构建：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean</span><br><span class="line">./gradlew --stop</span><br><span class="line">./gradlew --profile --offline --no-build-cache --rerun-tasks assembleXXX</span><br></pre></td></tr></table></figure><br>其中 <code>--rerun-tasks</code> 强制重新执行所有相关task并忽略任何task优化。</p>]]></content>
    
    <summary type="html">
    
      本文罗列了目前社区中常规的 gradle 构建速度优化方案，作为开发的参考。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="performance" scheme="https://linjiang.tech/tags/performance/"/>
    
      <category term="gradle" scheme="https://linjiang.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>从R文件索引看资源优化</title>
    <link href="https://linjiang.tech/2020/01/20/r-resources-arsc/"/>
    <id>https://linjiang.tech/2020/01/20/r-resources-arsc/</id>
    <published>2020-01-20T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>包体积的优化是一个老生常谈的话题，除了官方文档的最佳实践，社区也探索出了一系列优化方案，例如效果显著的微信 AndResGuard，对资源索引表和资源路径进行了缩减，可让原本已经优化过的 apk 再立减好几 M；又例如针对特定场景优化的 booster，其中对 R 文件的处理可以进一步减少 class 文件冗余。不管哪种，都建立在 R 字段对资源的索引基础之上，本文就来简单阐述其具体过程和优化方案。</p><p>在开发过程中，对于资源文件，我们只需要将其放入 res 下相应目录便可以在代码中通过引用 R 类中自动生成的相应字段来获取对应的资源，从使用角度而言非常简单方便，也就是说，R 文件用于为每个资源提供了一个全局独一无二的 ID 以供索引，而 R 文件具体是如何生成的则依赖 AAPT。</p><p>一般项目中都会包含多个模块（这里及以下都特指<code>com.android.library</code>），对于存在资源文件的模块 AAPT 会根据资源类型为其生成对应包名下的 R 文件，这样模块中就可以直接使用 R 类了，但这里就会有个棘手的问题，每个模块中的资源 ID 默认都是从 <code>0x7f+resTypeId+0001</code> 开始的，那么不同模块中的不同资源不出意外很可能会被分配相同的 ID，需要明白的是，我们使用 R.xx.xxx 时是通过其 ID 而不是这个字段名去引用资源，因此若不处理就会导致资源冲突的问题。为了解决该问题，AAPT 的逻辑是将 ID 的最终分配延迟到编译的打包期间，因此开发过程中 app 之外的模块生成的 R.java 中的字段都被声明为了非 final 类型，具体的 ID 此时并不重要，仅仅是为了能在开发中正常使用 R.xx.xxx 的形式引用资源，当执行编译时，R.java 中的这些字段由于是非常量类型所以并不会被内联为具体 ID 值，并且编译后的 R.class 也会被丢弃，这是为了以最终确定的 ID 为准，具体的形式就是重新为这些模块生成相应包名下包含最终 ID 的 R.class，当然由于 app 模块引用了这些模块因此所有 ID 也会体现到 app 模块下的 R.class 中。<br />从该流程可以看到，不管是 R 字段还是 R 文件本身都存在可优化的地方，分别如下：</p><ul><li>对于其余模块的 R.xx.xx 形式的代码调用，虽然在最终 ID 确定之前无法被内联，但是在确定后其实仍然是可以被优化为相应常量的；</li><li>由于为了采用最终的 ID 在构建初期删除了其余模块下的 R.class，因此在确定 ID 后为了防止运行无法找到相应 R 类又为相应模块生成了一份对应包下的 R.class，如果把其余模块对 R 的引用内联，那么这些 R.class 就非常冗余了，因为 app 模块已经有一份包含了所有最终 ID 的 R.class。（如果项目本身不存在通过反射 R 获取 ID 的情况，app 模块下的这份 R.class 也是可以删除的）</li></ul><p>当然，R 文件仅仅只是得到的资源对应的 ID，ID 如何索引到具体资源文件则是通过  <code>resources.arsc</code> 来实现的。resources.arsc 也是 AAPT 的产物之一，本质上是一张映射表，包含了从 <code>ID &lt;---&gt; name &lt;---&gt; value</code> 的映射关系，其中如果资源是文件则 value 表示的就是打包后 res 文件夹下中对应的文件路径，那么获取资源文件其实就是为了得到这个 value，从中我们也可以了解到 Android 资源获取的流程：R 文件是 ID 和字段名的映射、resources.arsc 是 ID &lt;—&gt; name &lt;—&gt; res.path 的映射，所以资源获取有两条路径，一是代码中通过 R.class 字段名得到资源 ID，然后在 resources.arsc 中通过 ID 得到资源在 res 中的路径；二是通过 getIdentifier 方法传入 name 直接在 resources.arsc 映射表中得到资源的路径。<br />从 resources.arsc 文件的组成和资源获取的方式不难发现，resources.arsc 也存在优化的空间：</p><ul><li>不管是通过 ID 还是 name 获取资源时，res 目录对于开发者而言是透明的，那么我们完全可以缩短资源路径，只要保证 resources.arsc 中存放的资源路径和 res 中实际的文件位置能够对应上即可，例如将形如 res/drawable/avatar.png 的路径压缩为 a/b/avatar.png 的形式，这样存放在 resources.arsc 的 path 所占用的空间将大大减少；</li><li>对于除了反射（getIdentifier）的资源外，resources.arsc 中保存的 name 其实并不重要，因为 ID 可以直接映射到资源的路径，所以可以将资源 name 缩短以减少 resources.arsc 的大小，并且由于 name 并没有和 path 中的 name 产生关联，所有还可以将其修改为同一个 string 以减小常量池。</li></ul><p>至此整个资源索引流程结束，可以通过下图来总结资源索引和优化的关系：</p><p><img src="https://raw.githubusercontent.com/whataa/PicsRepo/master/r_resources_raw.png" alt="r_resources"></p>]]></content>
    
    <summary type="html">
    
      包体积的优化是一个老生常谈的话题，除了官方文档的最佳实践，社区也探索出了一系列优化方案，例如效果显著的微信AndResGuard，对资源索引表和资源路径进行了缩减，可让原本已经优化过的apk再立减好几M；又例如针对特定场景优化的booster，其中对R文件的处理可以进一步减少class文件冗余。不管哪种，都建立在R字段对资源的索引基础之上，本文就来简单阐述其具体过程和优化方案。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="资源优化" scheme="https://linjiang.tech/tags/%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary2.0解析</title>
    <link href="https://linjiang.tech/2019/12/25/leakcanary/"/>
    <id>https://linjiang.tech/2019/12/25/leakcanary/</id>
    <published>2019-12-25T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文涉及的源码基于LeakCanary2.0：<a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p></blockquote><p>LeakCanary是square公司开源的内存泄漏检测工具，近期发布了2.0正式版，并带来了全新的内存分析工具shark，本文旨在梳理其整个工作流程。</p><p><a name="elDTD"></a></p><h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><p>LeakCanary利用了ContentProvider的随进程启动实例化的特性实现无感知初始化。整个初始化流程位于 <code>InternalAppWatcher</code> 的install方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到主要分为注册监听和通知回调两个步骤。注册监听的目的是为了能实时感知关键对象的销毁时机，以进一步检测对象是否发生泄漏。对于Android应用，Activity和Fragment无外乎是交互最为频繁的组件了，因此这里通过两个对应的watcher向其注册了生命周期回调。</p><p>注册监听的逻辑分为两部分，对于Activity，Application本身就对其生命周期变化提供了标准的回调接口，但对Fragment而言就稍显复杂了些，Fragment本身存在多个版本：集成于SDK的标准组件 / support包 / androidX，且早期版本并未提供Fragment的生命周期回调接口，因此FragmentDestroyWatcher包含了诸多兼容性处理实现了对位于Android O及其以上、support版本（&gt;=25.1.0）以及AndroidX版本的Fragment的监控能力，最后依据Fragment依赖Activity的特性，在Activity的onCreate回调中通过FragmentManager的registerActivityLifecycleCallbacks方法对上述各种Fragment统一注册回调。这样每当组件销毁时，组件对象便会被放入<code>objectWatcher</code> 的观察集合，objectWatcher用于初步判断对象是否发生泄漏，具体实现稍后再谈。</p><p>完成注册后，接下来继续剩余的初始化流程。 <code>InternalLeakCanary</code> 类实现了 (Application) -&gt; Unit 接口并在InternalAppWatcher的构造方法中被反射注册为<code>onAppWatcherInstalled</code> 对象，以接收初始化通知，InternalLeakCanary的初始化逻辑如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听对象可能泄漏的消息</span></span><br><span class="line">    AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="keyword">this</span>)</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 实例化核心类，</span></span><br><span class="line">    heapDumpTrigger = HeapDumpTrigger(</span><br><span class="line">        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,</span><br><span class="line">        configProvider</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加Shortcut快捷入口</span></span><br><span class="line">    addDynamicShortcut(application)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalLeakCanary的职责主要是接收来自objectWatcher的 “存在尚未销毁的对象” 的消息并驱动<code>HeapDumpTrigger</code> 进行堆转储（dump heap），分析内存快照并发布最终的结果（当然这里并非就是立即堆转储，后面再说）。这里有一个疑惑：既然都知道了哪个对象未销毁，为什么还要堆转储进一步分析？其实这和objectWatcher的实现有关。</p><p><a name="wbEUS"></a></p><h3 id="判断泄漏"><a href="#判断泄漏" class="headerlink" title="判断泄漏"></a>判断泄漏</h3><p>objectWatcher具体方案是利用弱引用 <code>WeakReference</code> 的特性来实现的，我们知道软引用 <code>SoftReference</code> 、弱引用以及虚引用 <code>PhantomReference</code> 可以关联一个引用队列 <code>ReferenceQueue</code> ，当引用reference的对象referent确定将被回收时，该reference会先被放入到所关联的queue中，因此可以利用该特性来确定对象最终是否被回收。</p><blockquote><p>选用弱引用而不是虚引用的原因：排除必须等到内存将满时才被回收的软引用，对于虚引用，reference在被加入到关联的queue时，reference内部所持有的referent并不会被置为null，因此需要手动调用clear()方法。</p></blockquote><p>对于销毁的组件，如果能正常入队就表示确被回收反之可初步认为发生了泄漏。但是GC机制是主动的，因此对象什么时候被回收是无法确定的，LeakCanary采取了默认等待5s再判断所watch的对象是否被回收的方案来获得一个可能结果，虽然是一个佛系数字，但正常的GC运行还是使得在给定的时间内大部分情况下对象都得到了回收，有效减少了堆转储的必要，毕竟是一个耗费资源和影响体验的操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor = Executor &#123;<span class="comment">// 主线程post一个5s延迟消息</span></span><br><span class="line">    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ObjectWatcher</span></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(watchedObject: <span class="type">Any</span>, name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line">    <span class="keyword">val</span> reference = KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)</span><br><span class="line">    watchedObjects[key] = reference</span><br><span class="line">    checkRetainedExecutor.execute &#123;<span class="comment">// postDelayed</span></span><br><span class="line">        moveToRetained(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述片段可以看到，<code>watchedObjects</code>存放的就是被观察的对象引用。每watch一个对象，就会在5s后再通过<code>moveToRetained</code> 检测一遍是否被回收，其具体逻辑就是遍历引用队列queue，将其中的reference（若存在）依次从watchedObjects中移除，最后看看watchedObjects中是否还存在该对象引用，如果存在就表示该对象有可能无法被回收。但GC的时机毕竟无法预知，假如某个对象在第6s的时候才被回收，也就是说，objectWatcher得出的 “存在尚未销毁的对象”只是一个初步结果，还不能完全确定这些对象是否能够真正被回收。</p><p>回到InternalLeakCanary，对于这些尚未被回收的对象，转交给HeapDumpTrigger做进一步判定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">(reason: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        gcTrigger.runGc() <span class="comment">// 0: 内部Runtime.getRuntime().gc()并Thread.sleep(100)</span></span><br><span class="line">        retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line">... <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> heapDumpFile = heapDumper.dumpHeap()</span><br><span class="line">    ... <span class="comment">// 2</span></span><br><span class="line">    HeapAnalyzerService.runAnalysis(application, heapDumpFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见HeapDumpTrigger并不急着立即触发dump堆内存并分析堆转储文件，而是先尝试触发一次GC，虽然GC无法手动执行；并且也因为GC无法手动执行，所以触发后先等待一小段时间（默认100ms），当然我们的前提是假定虚拟机收到消息后会尽快执行GC，这样在小段时间之后我们再通过<code>checkRetainedCount</code>检查引用集合中是否仍然存在活着的对象就可以判断是否有对象无法被回收。</p><p>checkRetainedCount除了判断存活的对象个数是否为0外，还通过指定的阈值（默认5）个数来限制短时间内反复触发后续的dump heap，例如一个Activity+N个Fragment，当Activity被关闭时，假使Activity确实无法释放，那么短时间内每个组件对象最后都会依次触发dump heap导致生成多个hprof文件。</p><p>由此可见，这一次的判断虽然可以进一步排除“假”泄漏对象，但依然不是完全确定的，GC毕竟无法人为控制，我们前面只是基于假设GC在触发后立即得到了执行，到此只能祭出最后的杀手锏了。</p><p>接下来继续后面的流程，在上述片段注释1处开始dump出内存快照，<code>dumpHeap()</code> 内部很简单，就是弹出toast并调用系统接口 <code>Debug.dumpHprofData</code> 生成堆转储<code>hprof</code>文件。生成的文件接下来交给注释2出的<code>HeapAnalyzerService</code>来执行分析。HeapAnalyzerService是一个前台IntentService（可配置到其它进程以降低对主进程的影响），为分析堆转储文件提供运行环境，其内部逻辑简单明了，就是调用<code>HeapAnalyzer</code>执行分析并得到分析结果，然后通过<code>OnHeapAnalyzedListener</code>回调。HeapAnalyzer位于Shark模块，我们先来看看shark是什么。</p><p><a name="Od9bI"></a></p><h3 id="shark"><a href="#shark" class="headerlink" title="shark"></a>shark</h3><p>此前LeakCanary用于分析hprof的工具依次包括HAHA、HAHA2以及perflib。shark是square团队开发的一款全新的分析hprof文件的工具，其官方宣布比Android Studio用于memory profiler的核心库<code>perflib</code> 要快8倍并且内存占用少10倍，更加适合手机端的分析工具。其目的就是提供快速解析hprof文件和分析快照的能力，并找出真正的泄漏对象以及对象到GcRoot的最短引用路径链，以便帮助开发者更加直观的找出泄漏的真正原因。</p><blockquote><p>由此可知，先前初步分析得到的泄漏对象与这里的堆分析和得到的真正泄漏对象并没有依赖关系，先前的初步分析仅仅只是一个触发堆转储和分析操作的过滤。</p></blockquote><p>hprof文件的标准协议主要由head和body组成，head包含一些元信息，例如文件协议的版本、开始的时间戳等。body则是由一系列不同类型的Record组成，Record主要用于描述trace、object（实例 / 数组 / 类 / …）、thread等信息，依次分为4个部分：TAG、TIMESTAMP、LENGTH、BODY，其中TAG就是表示Record类型，LENGTH用于指示BODY的长度。Record之间依次排列或嵌套，最终组成hprof文件。</p><p>在Shark库的设计中，<code>Hprof</code>类就是用于描述从内存中dump出的<code>.hprof</code>文件；密封类<code>HprofRecord</code>的各个子类一一对应上述协议中的各种Record；真正的解析则由<code>HprofReader</code>实现，核心方法为<code>readHprofRecords</code>()：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readHprofRecords</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    recordTypes: <span class="type">Set</span>&lt;<span class="type">KClass</span>&lt;<span class="type">out</span> <span class="type">HprofRecord</span>&gt;&gt;, <span class="comment">// 关心的record类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    listener: <span class="type">OnHprofRecordListener</span> <span class="comment">// 回传解析得到的record映射对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!exhausted()) &#123; <span class="comment">// 循环读取标签，直至结束</span></span><br><span class="line">  ...</span><br><span class="line">      <span class="keyword">when</span> (tag) &#123;</span><br><span class="line">          STRING_IN_UTF8 -&gt; &#123;...&#125;</span><br><span class="line">          ...</span><br><span class="line">          HEAP_DUMP, HEAP_DUMP_SEGMENT -&gt; &#123;</span><br><span class="line">              <span class="keyword">val</span> heapDumpTag = readUnsignedByte()</span><br><span class="line">              <span class="keyword">when</span> (heapDumpTag) &#123;</span><br><span class="line">                  ...</span><br><span class="line">                  ROOT_THREAD_OBJECT -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (readGcRootRecord) &#123;</span><br><span class="line">                      <span class="keyword">val</span> recordPosition = position</span><br><span class="line">                      <span class="keyword">val</span> gcRootRecord = GcRootRecord(</span><br><span class="line">                          gcRoot = ThreadObject(</span><br><span class="line">                              id = readId(),</span><br><span class="line">                              threadSerialNumber = readInt(),</span><br><span class="line">                              stackTraceSerialNumber = readInt()</span><br><span class="line">                          )</span><br><span class="line">                      )</span><br><span class="line">                      listener.onHprofRecord(recordPosition, gcRootRecord)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      skip(identifierByteSize + intByteSize + intByteSize)</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  ...</span><br><span class="line">              &#125;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难看出，readHprofRecords就是一个遵从协议实现的通用提取器，Record的类型有很多，通过指定关心的record类型和回调接口就可以将hprof文件转化为Record对象集合。</p><p>解析得到的records被进一步抽象为<code>HprofMemoryIndex</code>，Index的作用就是就是将得到的record按类型进行归类和计数，并通过特定规则进行排序；最终Index和Hprof一起再组成<code>HprofGraph</code>，graph做为hprof的最上层描述，将所有堆中数据抽象为了 <code>gcRoots、objects、classes、instances</code> 4种集合，并提供了快速定位dump堆中具体对象的能力。</p><p><a name="QXesj"></a></p><h3 id="HeapAnalyzer"><a href="#HeapAnalyzer" class="headerlink" title="HeapAnalyzer"></a>HeapAnalyzer</h3><p>heapAnalyzer作为shark模块的出入口，衔接解析和分析两大流程，核心逻辑如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hprof.<span class="keyword">open</span>(heapDumpFile)</span><br><span class="line">    .use &#123; hprof -&gt;</span><br><span class="line">        <span class="keyword">val</span> graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">val</span> findLeakInput = FindLeakInput(graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors)</span><br><span class="line">        <span class="keyword">val</span> (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> HeapAnalysisSuccess(</span><br><span class="line">            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime), metadata,</span><br><span class="line">            applicationLeaks, libraryLeaks</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个流程非常清晰：首先通过indexHprof解析得到graph，然后构造 <code>FindLeakInput</code> 开始分析并找出泄漏，最后包装分析结果返回。<br />graph的组成和功能我们已经清楚了，我们直接来看<code>findLeaks</code>具体是如何工作的。整个流程分为了三个步骤，分别对应三个关键方法：<code>findRetainedObjects</code>、<code>findPathsFromGcRoots</code>、<code>buildLeakTraces</code>。</p><p><a name="HpK0P"></a></p><h4 id="findRetainedObjects"><a href="#findRetainedObjects" class="headerlink" title="findRetainedObjects"></a>findRetainedObjects</h4><p>顾名思义就是找到存活（泄漏）的所有对象，具体逻辑就是遍历由graph提供的objects集合，通过特定规则进行标记过滤，最后得到一组由存活对象id构成的集合。<br />这里的特定规则由多个<code>ObjectInspector</code> 组成，根据LeakCanary的文档描述，默认的Inspector是建立在AOSP / libraries / JDK / …等基础上的开发经验和知识总结而来的，即对于Android而言（具体类<code>AndroidObjectInspectors</code>），我们知道哪些地方是可以造成内存泄漏的，因此只需要在内存快照中依次遍历特定的对象查看其是否 <strong>满足 / 肯定不满足</strong> 泄漏条件即可知道具体的泄漏对象，这些特定对象包括：</p><ul><li>android.widget.View间接引用的Activity的mDestroyed字段；</li><li>android.widget.Editor内部的mTextView字段；</li><li>android.app.Activity的mDestoryed字段；</li><li>android.content.ContextWrapper间接引用的Activity的mDestroyed字段；</li><li>android.app.Dialog的mDecor字段；</li><li>Fragment的mFragmentManager字段；</li><li>android.os.MessageQueue的mQuitting字段；</li><li>android.view.ViewRootImpl的mView字段；</li><li>android.view.Window的mDestroyed字段；</li><li>android.widget.Toast中的mTN对象内部的mWM字段和mView字段；</li></ul><p>对于JDK而言（具体类<code>ObjectInspectors</code>），我们知道哪些地方肯定不会泄漏，例如：ClassLoader、Class、匿名Class等，以及对于单例而言（具体类<code>AppSingletonInspector</code>），对象肯定不属于泄漏。</p><p>上述规则其实不难理解，内存泄漏的大致定义是：<br /><strong>无效的对象仍然与GcRoot保持了可达的引用路径，导致其无法被GC释放。</strong><br />而「无效」是逻辑上的概念，GC是无法理解的，但作为开发人员是知道的，例如在Android平台上，应用具体的场景切换中我们是知道哪些对象的状态会转变为无效，例如销毁的Activity，因此才会在初始化时对其进行watch。</p><p><a name="nkzfo"></a></p><h4 id="findPathsFromGcRoots"><a href="#findPathsFromGcRoots" class="headerlink" title="findPathsFromGcRoots"></a>findPathsFromGcRoots</h4><p>接下来就是找出所有从泄漏对象到GcRoot的引用路径链。总体思路是采用 <strong>广度优先遍历</strong> 算法从Roots向下查找，直到到达泄漏对象。由于涉及的代码繁多，这里仅阐述主要逻辑，整个过程是先从graph中得到的gcRoots被抽象为node按照优先级依次入队，作为队列的初始数据构成树根，然后开始从根节点开始遍历，对每个节点依据类型的不同采取对应的模式进行访问并得到所引用的对象集合，引用集合继续被抽象为node加入队列构成子节点以待后续遍历，如此反复直到当前遍历的node对象属于第一步中的泄漏对象，期间所经过的所有node便构成了从泄漏对象到GcRoot的引用路径。</p><p>上述过程中，用于维护遍历顺序的队列是通过toVisist、toVisitLast两对Queue和Set来构造的，其中Set用于保证树的遍历顺序始终遵从“从上至下”，使最终引用链结果不会包含更长的路径；两种Queue则提供一个优先级分级的概念，用于保证GcRoots中的ThreadObject优先于JavaFrame被遍历（当然也用于降低遍历LibraryLeak类型的泄漏的优先级），这样也是为了得到离泄漏对象最近的引用路径，避免得到形如thread-…-&gt;frame-…&gt;thread-…&gt;obj这样的结果。</p><p>除此之外，针对已知泄露（例如Android Framework内部的一些已知泄漏）的剔除也是在这里实现的，避免检测过程中反复打扰。已知泄漏使用<code>ReferenceMatcher</code>来描述，泄漏的具体引用使用<code>ReferencePattern</code>描述，分为threadLocal-variable、static-field、instance-field和native-globalVariable四种类型，并在遍历入队过程中，根据对象的类型不同，针对HeapClass、HeapInstance、HeapObjectArray提取对应的name在相应的已知泄漏集合中进行判断，以决定是否剔除。</p><p>当然还包括一些其它细节，例如在遍历入队过程中对基本类型和String等对象的剔除，都是为了得到更短更低重复性的路径集合。</p><p><a name="cME06"></a></p><h4 id="buildLeakTraces"><a href="#buildLeakTraces" class="headerlink" title="buildLeakTraces"></a>buildLeakTraces</h4><p>我们知道，一个对象被多个对象引用是很常见的行为，前面得到的引用路径集合泄漏对象和GcRoot之间可能存在多条路径，为了更利于分析，还需要进行裁剪。<br />裁剪的过程并不复杂，首先先将路径链反转为从GcRoot到泄漏对象的方向，然后通过<code>updateTrie</code>方法转化为一个以无效node为根节点的树，最后再通过 <strong>深度优先遍历</strong> 算法得到从根节点（无效node的children）到叶子节点的所有路径，即为最终的最短路径。其中裁剪的逻辑就发生在构造树的过程中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">deduplicateShortestPaths</span><span class="params">(inputPathResults: <span class="type">List</span>&lt;<span class="type">ReferencePathNode</span>&gt;)</span></span>: List&lt;ReferencePathNode&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> rootTrieNode = ParentNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> (pathNode <span class="keyword">in</span> inputPathResults) &#123;</span><br><span class="line">        ...<span class="comment">// 这里的path是已经反转后的路径</span></span><br><span class="line">        updateTrie(pathNode, path, <span class="number">0</span>, rootTrieNode)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateTrie</span><span class="params">(pathNode: <span class="type">ReferencePathNode</span>, path: <span class="type">List</span>&lt;<span class="type">Long</span>&gt;, pathIndex: <span class="type">Int</span>, parentNode: <span class="type">ParentNode</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objectId = path[pathIndex]</span><br><span class="line">    <span class="keyword">if</span> (pathIndex == path.lastIndex) &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        parentNode.children[objectId] = LeafNode(objectId, pathNode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;</span><br><span class="line">            <span class="keyword">val</span> newChildNode = ParentNode(objectId)</span><br><span class="line">            parentNode.children[objectId] = newChildNode</span><br><span class="line">            newChildNode</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">if</span> (childNode <span class="keyword">is</span> ParentNode) &#123;</span><br><span class="line">            updateTrie(pathNode, path, pathIndex + <span class="number">1</span>, childNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>deduplicateShortestPaths</code>中的<code>rootTrieNode</code>作为树的根节点，其children指向所有的GcRoot；在注释1处，如果某条路径遍历到最后一个节点时发现起父节点parentNode的children中已经存在自身，即GcRoot和泄漏对象相同，说明此前已有一条相等或更长的重复路径，那么此处的覆盖就将更长的引用链丢弃（裁剪）了。</p><p>至此主要工作结束，剩余的逻辑主要是为引用路径链的每个节点赋予详细的描述信息，包括通过objectInspectors重新inspect等，最终构建为applicationLeaks和LibraryLeaks两种形式的泄露描述并得到HeapAnalysis，在Service中通过DefaultOnHeapAnalyzedListener写入数据库并Notification提示，这些后续逻辑相对简单，就不一一细说了。</p><p><a name="4JLtU"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>LeakCanary的整个工作流程从向Activity/Fragment注册生命周期监听开始，当组件销毁时触发对对应对象的观察，利用WeakReference和手动触发GC双重机制来判断对象是否泄露，并在对象可能确实泄露时dump内存快照利用shark进行解析和分析，整个分析过程分为三个流程，先依据Android平台的特性和开发经验找出目标（泄露）对象，然后从GcRoot开始遍历，采用广度优先遍历算法得到所有符合条件的引用路径链，最终裁剪得到泄露对象到GcRoot的最短引用路径链，整个流程结束。</p><p>为了更详细地阐述整个流程，本文省略了很多旁枝末节和代码，但不妨碍理解，可以看到从注册对关键对象的观察，到判断对象是否泄漏，再到最后dump内存快照进行分析直至确定最后结果，LeakCanary的实现逻辑还是非常清晰和高效的。但同时我们也发现，LeakCanary也不是万能的，如何确定一个对象是否有效，它的规则并不能覆盖到所有的业务场景。</p><p><a name="0iTdU"></a></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088">Binary Dump Format (format=b)</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib">Android Hprof format parser</a></li><li><a href="https://developer.squareup.com/blog/announcing-shark-smart-heap-analysis-reports-for-kotlin">Announcing Shark: Smart Heap Analysis Reports for Kotlin</a></li></ul>]]></content>
    
    <summary type="html">
    
      LeakCanary是square公司开源的内存泄漏检测工具，近期发布了2.0正式版，并带来了全新的内存分析工具shark，本文旨在梳理其整个工作流程。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="performance" scheme="https://linjiang.tech/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Matrix-TraceCanary的设计和原理分析手册</title>
    <link href="https://linjiang.tech/2019/11/12/matrix-trace-canary/"/>
    <id>https://linjiang.tech/2019/11/12/matrix-trace-canary/</id>
    <published>2019-11-12T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>matrix是微信开源的APM方案，其中TraceCannery是一套用于监控应用卡顿和帧率并提供精确化的日志捕捉和分析能力的模块。本文以手册形式对其设计方案的选择和功能背后的原理进行分析说明，以期对Android端性能检测和优化有更加透彻的理解。</p><p>项目地址：<a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">https://github.com/Tencent/matrix</a></p><p><a name="kbuS4"></a></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><a name="o33xO"></a></p><h3 id="LooperMonitor"><a href="#LooperMonitor" class="headerlink" title="LooperMonitor"></a>LooperMonitor</h3><p>向主线程的Looper注册MessageLogging和IdleHandler，分别对主线程消息模型 <strong>处理每条message</strong> 和 <strong>消息队列空闲时 </strong>进行监听并分发每条message处理的开始和结束事件。</p><p><a name="klufX"></a></p><h3 id="UIThreadMonitor"><a href="#UIThreadMonitor" class="headerlink" title="UIThreadMonitor"></a>UIThreadMonitor</h3><p>TracePlugin模块的核心实现。通过LooperMonitor和Choreographer实现对线程所有UI操作的监控，为具体Tracer提供相应事件的回调和统计。</p><ol><li><p>如何实现对UI操作 <strong>帧级别</strong> 的耗时统计？</p><p> 通过LooperMonitor观察主线程Handler的每条message的回调事件，并在每次事件结束时向 <code>Choreographer</code> 分别插入INPUT、ANIMATION、TRAVERSAL三个事件到对应的队列头部（实际是先插入INPUT，当INPUT执行时再插入ANIMATION和TRAVERSAL），当下次VSYNC到来时触发执行相应回调，以达到对该三个事件执行时间的精确统计。<br />注意：这里的帧定义为系统处理输入、动画以及绘制的总操作，注意和Handler其余message的区别。由于每一帧执行也是通过Handler触发，所以不管是帧的执行还是其余message，只要出现了耗时，都会导致帧未及时执行或执行过长从而引起卡顿。</p></li><li><p>为什么插入到队列头部？</p><p> VSYNC事件触发UI相关的操作实际也是通过主线程Handler来完成的，最终执行点是doFrame方法，该方法里是按照INPUT、ANIMATION、TRAVERSAL三种事件依次回调的，从每个事件的队列中取出符合执行时间的集合并执行；这里的问题就是符合时间的事件是取决于doFrame开始执行的时间戳，没法提前知道，即无法成对地向队列尾部插入事件。<br />因此考虑另一种方案：从INPUT队列第一个事件开始执行到ANIMATION队列的第一个事件开始执行刚好就是此次所有INPUT事件的执行时间，以此类推即可计算出三种事件的耗时；但是TRAVERSAL之后就结束了，TRAVERSAL的耗时没法在此次doFrame事件的回调中完成统计，所以我们增加一个标识符，在下一个message事件开始时根据标识符来结束对TRAVERSAL的耗时统计。</p></li></ol><p>关于Choreographer的运行机制参考：<a href="http://linjiang.tech/2019/10/18/choreographer/">http://linjiang.tech/2019/10/18/choreographer/</a></p><p><a name="mDhyo"></a></p><h3 id="matrix-trace-plugin："><a href="#matrix-trace-plugin：" class="headerlink" title="matrix-trace-plugin："></a>matrix-trace-plugin：</h3><p><a name="87dVT"></a></p><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><ul><li>mappingOut:</li></ul><p>// gradle默认的压缩混淆输出目录：app/build/outputs/mapping/{buildType}/<br />${globalScope.getBuildDir()}/outputs/mapping/${variantScope.getVariantConfiguration().getDirName()}</p><ul><li>traceClassOut:</li></ul><p>// 插桩后的输出目录（于源文件对应的层级结果，可用于观察每个函数的插桩结果）<br />${globalScope.getBuildDir()}/outputs/traceClassOut/${variantScope.getVariantConfiguration().getDirName()}</p><ul><li>methodMapping.txt</li></ul><p>${mappingOut}/methodMapping.txt<br />插桩结果文件：被插桩的方法集合</p><ul><li>ignoreMethodMapping.txt</li></ul><p>${mappingOut}/ignoreMethodMapping.txt<br />插桩结果文件：忽略了插桩的方法集合</p><ul><li>baseMethodMapFile</li></ul><p>插桩配置文件：可手动指定需要插桩的函数及索引（例如避免函数过于简单而被忽略）</p><ul><li>blackListFile</li></ul><p>插桩配置文件：指定插桩过滤名单，class级别；</p><ul><li>customDexTransformName</li></ul><p>插桩配置文件：指定trace切入的task名，默认是 <code>transformClassesWithDexForXX</code> 或 <code>transformClassesWithDexBuilderForXX</code> ；选择这样的方式是为了在混淆后开始插桩，因为 <code>AppExtension#registerTransform</code> 注册的任务是在混淆之前执行的。</p><ul><li>mapping.txt（开启混淆后Android插件生成的文件）</li></ul><p>开启混淆后的生成文件。</p><p><a name="Jx6c3"></a></p><h4 id="插桩时机和流程"><a href="#插桩时机和流程" class="headerlink" title="插桩时机和流程"></a>插桩时机和流程</h4><p>之所以选择在<strong>混淆后插桩</strong>，是因为在混淆前插桩可能导致某些方法不符合内联规则（编译时内联），无法被proguard（R8）优化，从而导致方法数无法减小，即相对没插桩就是变多。整个插桩过程总体来说分为三大步：<br />一</p><ol><li>解析自定义配置和混淆的输出文件；</li><li>如果baseMethodMapFile存在，就将其中指定的函数映射至对应的混淆后的函数；</li><li>从DictionaryInput和JarInput中解析出变化的<strong>源文件集合</strong>（输入-输出的map）用于下一步的函数收集；<ol><li>其中会把上面两个类的输入文件集合的属性反射修改为指向自定义的输出文件目录，等插桩完成，修改后的文件写入到输出目录并作为下一个transform的输入文件；</li></ol></li></ol><p>二</p><ol><li>从<strong>源文件集合</strong>中根据过滤规则和黑名单的限制，通过ASM找到并收集所有可插桩的method，并分配唯一ID；<ol><li>对于混淆的情况：在判断函数是否需要插桩时会先根据mapping得到原始name再判断；</li><li>过滤规则：空函数（无任何指令）、get/set函数、简单的构造函数（最多就是调用了super）、简单函数（没调用任何其它函数）、黑名单；</li></ol></li><li>将收集的和忽略的通过mapping还原为真实name并输出到methodMapping、ignoreMethodMapping。</li></ol><p>三</p><ol><li>遍历<strong>源文件集合</strong>并通过ASM进行真正的插桩，并将插桩后的文件流保存到对应的输出目录作为下一个transform的输入文件；<ol><li>在函数的入口和出口处分别插入AppMethodBeat.i(id)、AppMethodBeat.o(id)；</li><li>在ASM访问类时，遍历到onWindowFocusChanged时插入AppMethodBeat.at(this, focus)，如果class是Activity的非抽象子类且没有onWindowFocusChanged方法，则同时手动插入对应的方法并插桩；</li><li>这里需要注意的是：在判断某个类是否是Activity的子类时，由于增量式编译plugin得到输入源只包含变化了的类，support库下的相关父类Activity并未参与到ASM的遍历中来，因此可能导致这里的判断失效从而无法插入 at 函数；</li></ol></li></ol><p><a name="kGn7H"></a></p><h3 id="AppMethodBeat"><a href="#AppMethodBeat" class="headerlink" title="AppMethodBeat"></a>AppMethodBeat</h3><p>用于记录运行于 <strong>主线程 </strong>的所有函数的执行时间，具体方案是在函数的入口和出口分别插入对应的调用点(i/o)，在编译阶段通过trace-plugin插桩实现。基于此plugin顺便也实现了对Activity的焦点变化的监控(at)。</p><p>记录函数的执行时间具体来说是开辟了一个固定长度为100w的long型数组用于存储函数开始和结束时的“当前时间点”（以下称记录表），占用内存空间约为: 1_000_000*64/8/1024/1024 ≈ 7.6M，其中将每个long型数组元素从高位到低位分成3部分，最高位0/1分别表示出入口、第43~62位存储methodID、第0~42位存储时间戳；这里可以看到</p><ol><li>函数ID在插桩分配时虽然未作限制，但实际最大只支持20位即大约100多w个，但也绰绰有余了。</li><li>这种将函数和时间绑定在一个long字段上的方案极大地节约了运行空间，值得借鉴。</li></ol><p>另外，这里所说的记录的“当前时间”并非是记录时获取的实时时间，具体原因应该是考虑到大量调用<code>SystemClock.uptimeMillis()</code> 的耗时已不容忽略，因此采用了另外一种更新时间的机制：另起一个HandlerThread线程以每5ms的间隔刷新时间，并通过LooperMonitor的回调即主线程分发message的时刻来作为补充并控制刷新的开始和暂停。也就是说该方案得到的函数耗时至少有±10ms的误差，特别是对5ms以内的函数更是无从统计，但考虑到这种情况的函数并非影响性能的罪魁祸首，所以该方案也是合理的。</p><p>有了每个函数的进入退出记录表，AppMethodBeat还需对外提供真正所需的切片以定位具体的问题函数，具体是由IndexRecord实现，顾名思义，用于外部在需要时记录切入时间片段索引；AppMethodBeat内部维护了一个IndexRecord链表和一个指向记录表最新位置的索引sIndex，当外部需要时就会为其生成一个保存了该时刻索引的IndexRecord对象并按索引递增的顺序插入链表中最后返回，外部可根据该对象从记录表中切出对应的数据切片。</p><p><a name="bODpJ"></a></p><h2 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h2><p>从多个场景维度来实现对性能的跟踪监控，以期提供更加精准化的问题分析和优化的能力。<br><a name="tZn4u"></a></p><h3 id="AnrTracer"><a href="#AnrTracer" class="headerlink" title="AnrTracer"></a>AnrTracer</h3><ul><li><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary</a></li></ul><p>用于检测主线程的ANR并尝试提供准确的可供分析定位的快照，特别适用于不可复现的卡顿场景（可复现的场景可以通过Trace来得到函数调用栈的快照以进一步分析）。</p><p>开启后向LooperMonitor注册得到主线程的消息分发回调，并初始化了一个私有的HandlerThread用于对每一个消息的执行时间进行监测。具体就是在消息开始处理时post一个5s延迟task（以系统定义主线程无响应规则为基准），当消息处理结束时就移除先前的延迟task，如果task得到执行就表示处理超时，该task的职责就是负责收集当前时刻的运行快照，包括处理器内存情况、主线程堆栈、此次message处理过程的UI事件耗时统计（如果正好可以的话，因为并非每个message都是VSYNC的doFrame） 以及 对应的函数栈执行耗时切片。</p><p>ANR监控是针对“帧”而言，这里的帧在老版本使用Choreographer分发每帧的回调，而新版本使用主线程的Handler-dispatchMessage机制，其中一个主要原因是因为Choreographer的doFrame也是以Message形式抛给Looper处理的，而主线程除了doFrame，本身就可能还存在其它Message需要处理，在两个脉冲之间如果存在耗时message就会导致doFrame不能及时处理，这里就引出了两个问题，一是我们的ANR监控可能误报，因为老方案检测的是两个doFrame之间的总时间超过阈值，但这之间可能是多个message，平摊下来的耗时可能并不会触发真正的ANR；二是监控到ANR时取得的函数栈执行耗时切片相对过大，不太便于分析，总而言之就是无法更精确的统计帧率和卡顿，而新机制可以将上述监控精准到message级别，优势不言而喻。<br />而利用Handler机制的缺点就是方案所依赖的的回调是判断Looper中组装的log字符串，由于回调很频繁因此系统产生大量的字符串严重时会使得内存紧张触发频繁的GC从而导致app性能下降；</p><p><a name="2wPRD"></a></p><h3 id="StartupTracer"><a href="#StartupTracer" class="headerlink" title="StartupTracer"></a>StartupTracer</h3><p>用于监控冷/热启动场景下的性能问题，提供的分析快照包含冷热启动的总耗时、application耗时、启动页耗时、以及相应期间的函数调用栈及其耗时。</p><p>其中函数调用栈的快照来自前述的AppMethodBeat的切片，其它相关的耗时统计则依赖对ActivityThread的hook，切入的时机并未要求手动在application中实现，而是选自函数插桩后的运行时的第一次调用，由于默认是全局插桩，那么不管application实现的onCreate方法还是attchBaseContext，只要被调用就会触发hook。Hook其实只做了一件事：就是反射替换掌管分发应用内四大组件生命周期消息的Handler对象 <code>mH</code> 的 <code>mCallback</code> ，这样便可获取到启动页的launch时机，从而间接计算出application的总耗时（启动页启动时的时间点 - hook切入时的时间点）和启动页的启动耗时（Activity#onWindowFocusChanged - 启动页启动时的时间点）。</p><p>onWindowFocusChanged和onResume一个很重要的区别就是onResume回调时只是表示进入了可见状态，Activity的layout仍未绘制，理论上Activity的启动统计除了位于生命周期回调函数中的逻辑耗时，还应包括布局的onMeasure、onLayout、onDraw流程的时间，而onWindowFocusChanged的首次回调表示Activity真正可见，是一个<strong>相对更完美</strong>的统计截止点；之所以不是最完美是因为onDraw是在onWindowFocusChanged之后回调的，即 <code>onResume -&gt; onMeasure -&gt; onLayout -&gt; onWindowFocusChanged -&gt; onDraw</code> ，因此上面的“真正可见”的时机实际上还是一团黑/白，没有任何内容。</p><p>补充说明：</p><ul><li>application的总耗时的截止时间点具体来说是到第一个组件（Activity/Service/Receiver，除了Provider）启动的时刻；</li><li>“启动页”并非特指第一个Activity，可以结合实际业务指定启动过程的截止Activity；</li><li>onWindowFocusChanged时机的监控也是在编译时通过插桩调用的，见上述matrix-trace-plugin流程；</li></ul><p><a name="K6I20"></a></p><h3 id="FrameTracer"><a href="#FrameTracer" class="headerlink" title="FrameTracer"></a>FrameTracer</h3><p>帧率监控也是通过向LooperMonitor注册得到主线程的消息分发回调、并在私有HandlerThread中进行逻辑处理，主要分为以下两块：<br />一是通过FrameTracer来统计每个页面在可见时的帧率情况，并在帧耗时累积达到一定时间时上报该期间的统计分析，包括平均帧率、掉帧的区间分布等信息（个人觉得用处不大）。<br />另一块位于FrameDecorator，以UI形式呈现“实时”FPS的监控，可以较为准确地观察到当前UI的帧率变化。其中的FPS算法是以累积200ms的总耗时为一个周期，期间的总帧数和总耗时相除得到的一个平均值，所以这里的“实时”是打引号的。<br />有以下几个注意点：</p><ul><li>总耗时指每一帧的耗时的累积时间，其中每一帧的耗时并非取的是 <code>UIThreadMonitor</code> 中统计的耗时，而是先根据该耗时计算出掉帧数dropFrame，即frameCost / 16.66（这里及以下以60hz为例）得到的整数，然后再用(dropFrame + 1) * 16.66计算出一帧的耗时时间，可以看到这种规则得到的耗时始终是16.66的倍数，为什么要这样算？其实这和VSYNC有关系，举个例子：不论每个VSYNC期间UI相关操作是10ms还是5ms，我们实际的帧率依然是60，不可能因为UI操作非常快就突破了60，因为VSYNC的推出就是用来稳定帧率的。</li><li>计算的FPS除了不是实时外，而且还<strong>偏大</strong>。原因就在于matrix里一帧的耗时只包含了Choreographer的callback队列的执行，即UI操作相关的耗时，没有包含两个VSYNC之间产生的其它非UI操作相关的message的耗时，从而导致实际一帧的时间偏小，最终导致FPS偏高。</li></ul><p><a name="I03T8"></a></p><h3 id="EvilMethodTracer"><a href="#EvilMethodTracer" class="headerlink" title="EvilMethodTracer"></a>EvilMethodTracer</h3><p>顾名思义，该tracer是用来找出“邪恶”方法，即那些在主线程执行时耗时过长的方法，可以看作AnrTracer的补充，提供了一个更细的分析粒度。因此方案也与ANRTracer类似，通过LoopMonitor注册主线程的消息分发回调观察每一个消息的耗时，当超过指定阈值（默认700ms）时便通过AppMethodBeat取出该期间在主线程中所有执行过的方法记录然后抛在私有HandlerThread中进行解析上报。</p>]]></content>
    
    <summary type="html">
    
      matrix是微信开源的APM方案，其中TraceCannery是一套用于监控应用卡顿和帧率并提供精确化的日志捕捉和分析能力的模块。本文以手册形式对其设计方案的选择和功能背后的原理进行分析说明，以期对Android端性能检测和优化有更加透彻的理解。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="performance" scheme="https://linjiang.tech/tags/performance/"/>
    
      <category term="matrix" scheme="https://linjiang.tech/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Choreographer机制概述</title>
    <link href="https://linjiang.tech/2019/10/18/choreographer/"/>
    <id>https://linjiang.tech/2019/10/18/choreographer/</id>
    <published>2019-10-18T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>Choreographer是用于协调动画(animation)、输入(input)以及绘制(drawing)三种事件的触发时间。<br />具体来说就是作为系统”垂直同步脉冲“VSYNC和应用端的协调者，通过稳定的周期性回调来统一上述与UI相关的事件的执行，以期达到稳定流畅的显示效果。</p><p>Choreographer在内部为这些事件各自维护了一个按发生时间从近及远的队列，用于存储向其请求执行的任务，每当同步信号到来时，就从相应的队列中取出符合的任务并按照INPUT、ANIMATION、TRAVERSAL的顺序回调，最终触发触摸事件分发、动画执行和绘制流程相关逻辑的执行。</p><p>所谓VSYNC，是Android4.1开始引入的一种提升页面流畅性的新机制，以固定周期集中处理UI绘制相关操作以提供更稳定的FPS；在此之前每一帧的UI绘制相关操作都是无间隔地以message形式抛给Handler处理的，那么FPS直接取决于message的执行时间，导致忽高忽低。需要注意的是，系统在运行期间以60帧的帧率即16.67ms的间隔（对于最近火热的90帧的手机，其系统的VSYNC则是90帧即11.1ms的间隔）持续发出脉冲信号，但并不意味着应用内部不论何种情况都会不断地收到该信号，仅当应用主动向系统请求时，最近的VSYNC才会传递给Choreographer并安排相应的任务；其中”应用主动请求“包括input事件的唤起、动画的执行以及视图层级的刷新。</p><p><a name="O91kg"></a></p><h2 id="TRAVERSAL流程"><a href="#TRAVERSAL流程" class="headerlink" title="TRAVERSAL流程"></a>TRAVERSAL流程</h2><p>这里我们以View的绘制执行为例来梳理应用与Choreographer之间的关系。<br />当视图需要重绘时，我们会调用requestLayout方法，该方法将事件通过视图层级层层向上传递到了ViewRootImpl的requestLayout方法中，并最终调用scheduleTraversals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，该方法直接向Choreographer通过postCallback插入了一个TRAVERSAL事件，我们前面说到，当同步信号到来时就会取出Choreographer里面的队列事件并执行，这里的事件指的其实就是 mTraversalRunnable ，其内部调用正是Android绘制的真正执行方法：doTraversal()，整个流程也就不言而喻了。<br />postCallback内部并不复杂，主要做了以下两件事：</p><ol><li><p>将事件加入到对应的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">            Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向系统请求安排最近的同步信号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里我们仅关心VSYNC模式下的相关逻辑，其中scheduleVsyncLocked内部调用的是native方法，用于向系统请求安排 <strong>最近 </strong>的同步信号，相当于向对应的系统进程注册了一个回调；当下一次同步信号到来时Choreographer的onVsync方法将被调用，该方法内部又将事件抛给了主线程的Handler（这里我们以主线程的Choreographer为例），以真正的执行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    ... </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有事件本质都是以runnable的形式存储在队列，doCallback内部的核心逻辑就是执行runnable的run方法，也即是执行前面说到的mTraversalRunnable内部的doTraversal方法开始真正的绘制流程。整个流程结束，对于ANIMATION以及TRAVERSAL也是依次类推。</p><p>另外，在doFrame中我们还可以顺道发现和验证一些常见问题，例如我们经常在LogCat里看到的</p><blockquote><p>Skipped xx frames!  The application may be doing too much work on its main thread.</p></blockquote><p>就是在该方法中输出的，刚刚我们说到onVsync方法会把通知事件抛给Handler，如果在此期间存在非常耗时的message，那么等到doFrame这个消息执行时可能已经过了好几个VSYNC周期，在doFrame中就是通过对比 当前时间 和触发该message的 onVsync的发生时间 来判断出大致掉了多少帧，所以在主线程中不管是input、animation以及UI绘制三者自身耗时还是其它message的执行耗时，都会导致掉帧。</p><blockquote><p>注：onVsync的发生时间并非指onVsync开始执行时的时间，而是传给onVsync的参数时间，这个时间是VSYNC信号到来的时间。</p></blockquote><p><a name="g1k0I"></a></p><h2 id="题外话：流畅度"><a href="#题外话：流畅度" class="headerlink" title="题外话：流畅度"></a>题外话：流畅度</h2><p>既然已经大致了解了Android的UI绘制与Choreographer的关系，那么可以以什么方式或从什么地方来检测每一帧的耗时情况呢？</p><p>由前面的分析可知，所谓每一帧其实指的就是input、animation、traversal三种事件对应的三个doCallback方法的执行结果，那么帧耗时就可以用这三个方法的执行总时间来表示。</p><p>统计一个方法的耗时最直接的方案就是向方法内部第一行和最后一行插桩得到执行时间差，此处依然行之有效，当然并不是编译期插入，毕竟是系统方法，而是向input、animation、traversal三个事件队列的头部插入一个我们自己包装的事件，从input队列第一个事件开始执行到animation队列的第一个事件开始执行刚好就是此次所有input事件的执行时间，以此类推即可计算出三种事件的耗时，由此可见，根据该方案我们不仅可以得到每一帧的耗时，还能更进一步得到每一帧内input、animation、traversal三种事件的耗时情况。</p><p>至于为什么只插入到队列头部，是进入doCallback的事件是从相应队列中取出的符合执行时间的集合，这里的问题就是符合时间的事件是取决于doFrame开始执行的时间戳，没法提前知道，即无法成对地向队列尾部插入事件。<br />另外还有一个小细节，traversal的doCallback之后就结束了，一帧的耗时统计没法闭合，所以我们可以增加一个标识符，在下一个message事件开始时根据标识符来结束对TRAVERSAL的耗时统计。</p><p>其实该方案正是取自微信开源的Matrix项目，具体代码逻辑位于 UIThreadMonitor 类，关于在什么时机并如何向Choreographer内部的队列插入自定义事件可自行参考。</p><p><a name="rsOQV"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/37631535">https://zhuanlan.zhihu.com/p/37631535</a></li><li><a href="https://blog.csdn.net/yangwen123/article/details/39518923">https://blog.csdn.net/yangwen123/article/details/39518923</a></li><li><a href="http://gityuan.com/2017/02/25/choreographer/">http://gityuan.com/2017/02/25/choreographer/</a></li><li><a href="https://developer.android.com/reference/android/view/Choreographer">https://developer.android.com/reference/android/view/Choreographer</a></li><li><a href="https://github.com/Tencent/matrix/blob/91935959753fcfe9826aa699138fafa86fd5f00b/matrix/matrix-android/matrix-trace-canary/src/main/java/com/tencent/matrix/trace/core/UIThreadMonitor.java#L311">https://github.com/Tencent/matrix/blob/91935959753fcfe9826aa699138fafa86fd5f00b/matrix/matrix-android/matrix-trace-canary/src/main/java/com/tencent/matrix/trace/core/UIThreadMonitor.java#L311</a></li></ul>]]></content>
    
    <summary type="html">
    
      Choreographer是用于协调动画、输入以及绘制三种事件的触发时间，属于Android渲染机制的一部分。本文主要概述Choreographer的实现以及如何衔接系统和应用的关系，并探讨了一种统计帧绘制的事件的方案。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="View" scheme="https://linjiang.tech/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Dart的学习笔记</title>
    <link href="https://linjiang.tech/2019/03/21/dart/"/>
    <id>https://linjiang.tech/2019/03/21/dart/</id>
    <published>2019-03-21T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>在Dart中一切都是对象，一个.dart文件可以声明任何对象，包括类、函数、变量；</p><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>除了局部变量建议用var之外，其余地方建议用具体类型声明；</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const 修饰一个编译时常量。  </p><ul><li>当修饰构造函数时，则该类的所有fields必须是final修饰；</li><li>当const修饰的是类的field，则必须同时修饰static；</li><li>被final或者const修饰的变量，变量类型可以省略；</li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>类的fields被final修饰，可以不初始化（只是会警告），但是若要初始化，则必须通过构造函数来初始化，不能通过其它函数初始化。</p><ul><li>声明对象时可以省略对象类型；</li></ul><h2 id="covariant"><a href="#covariant" class="headerlink" title="covariant"></a><a href="https://www.dartlang.org/guides/language/sound-dart#use-sound-parameter-types-when-overriding-methods">covariant</a></h2><p>因为Dart是类型安全的，所以Override方法时，方法的参数类型不能“收缩(tight)”。但是某些时候需要这种情况时，可以用该关键字注解用来抑制「静态检测错误」（即使知道是无效的），以 <strong>通过编译</strong>。但是运行时仍会执行无效参数检查。</p><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="dart文件"><a href="#dart文件" class="headerlink" title="dart文件"></a>dart文件</h2><ul><li>主方法是 <code>main()</code>, 如果需要接收输入的参数则定义为 <code>main(List&lt;String&gt; args)</code> ；</li><li>可以定义任何代码，包括多个类、变量、函数等，无需限定在 <code>class</code> 内部；</li><li><p>没有 <code>public、protected、private</code> 关键字，默认所有的定义都是「public」的，如果需要转化为「private」，直接在对应的命名前增加下划线 <code>_</code>；</p></li><li><p><code>abstract</code> 定义抽象类，使用 <code>extends</code> 则表示继承；</p></li><li><p>没有 <code>interface</code> 关键字，默认所以的 <code>class</code> 都是隐式的接口。使用 <code>implements</code> 实现接口:</p><ul><li>若在同一个文件，则必须实现接口定义的所有变量和函数；</li><li>若不在同一个文件，则只需实现「public」类型的变量和函数；</li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><p>提供两种定义方式：</p><ol><li><p>与类名 <code>(ClassName)</code> 相同，可以理解为 <code>NoNamed constructors</code>；</p><blockquote><p>有且只能存在一个</p></blockquote></li><li><p>以<code>ClassName.identifier</code>的形式，称作 <code>Named constructors</code>；</p><blockquote><p>可用以提供更具场景化的构造名称，和Java的利用静态方法构造对象的方案类似，因此这种构造方式也就无法被子类继承;</p></blockquote></li></ol></li><li><p>在没有显式提供任何构造函数时，默认包含一个 <strong>无参无名</strong> 构造函数；不管是哪种方式，一旦显式定义了，默认的无参构造函数就被取代；</p></li><li><p>可以没有方法体；</p></li></ul><ul><li><p>构造函数参数区后可继续接 <code>:</code> + 表达式，称为初始化表达式<code>Initializer expressions</code> ：</p><ol><li>调用父类构造函数，例如：<code>Point.circle(int x) : super.any(x);</code></li><li>实例化成员变量，例如：<code>Point(int y) : x = 1 + y;</code></li><li>开发阶段的断言，例如：<code>Point(int y) : assert(y &gt; 0);</code></li><li><p>重定向到其它构造函数，例如：<code>Point.circle(int x) : this(x);</code></p><blockquote><p>重定向无法和上述前三种共用、没有body、不能快速参数指定</p><p>1, 2, 3可以组合，但是1必须位于整个表达式的最后。</p></blockquote></li></ol></li><li><p><code>factory</code> 关键字定义一个工厂函数（是构造函数，相当于从语言层支持了工厂方法），例如抽象类不能被实例化，可以利用该方式返回子类对象；</p></li><li><p>如果类实例化的对象不可变（不可修改该对象、且不可修改该对象的变量），可以通过在构造函数前面声明 <code>const</code>、对所有变量声明 <code>final</code> 来将对象转化为编译时常量。</p><p>该形式的构造函数有以下特性：</p><ol><li>没有有body；</li><li>由于所有的变量必须final，对于私有变量，可以通过 初始化表达式 来实例化；</li><li>初始化表达式 涉及的只能是常量；</li><li>任何地方通过该构造函数实例化的 <strong><em>constant对象</em></strong> (例如<code>const Point(1)</code>这种)，如果参数完全一致，那么这些对象是同一个对象；</li></ol></li></ul><h3 id="1-参数"><a href="#1-参数" class="headerlink" title="1. 参数"></a>1. 参数</h3><ul><li>可直接在参数区使用 <code>this.</code>+ 实例变量名 快速为实例变量赋值，例如：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bicycle(this.cadence, this.speed, this.gear);</span><br></pre></td></tr></table></figure></li><li><p>命名可选参数：将构造函数的部分参数包裹在 <code>&#123;&#125;</code> 中，同时可以为可选参数提供默认值，若参数是一个对象，则默认值需要声明为 <code>const</code> 以表示是一个编译时常量；</p></li><li><p>位置可选参数：将构造函数的部分参数包裹在 <code>[]</code> 中，传入的参数位置和函数声明的参数位置一一对应。</p></li></ul><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><ul><li>子类的构造函数必须调用父类的构造函数，默认隐式调用父类的无参无名构造函数（注意：<code>Named constructors</code> 的无参构造函数不算）；若父类没有，则需要通过 <code>: super</code> 的形式手动调用，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.circle(int x) : super(x);</span><br></pre></td></tr></table></figure></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>定义对象时可以使用 <code>var</code> 关键字，同时也支持 <code>final</code>（如果该对象不会发生变化）；</li><li>实例化对象时可以省略 <code>new</code> 关键字；</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>由于完全面向对象，所以任何类型的变量默认值都为null，即使是num；</p></li><li><p>默认情况每个「public」实例变量都隐式地实现了 <code>getter/setter</code> （无需也禁止再手动实现），如果该实例变量被声明为了「private」，则可以使用关键字 <code>get</code> 定义方法以提供对外(内)访问，<code>set</code> 定义方法提供对外(内)修改；</p></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>与Java的泛型在运行时被擦除不一样的是，Dart的泛型指定后在运行时始终存在：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var names = List&lt;String&gt;();</span><br><span class="line">names.addAll([&#x27;Seth&#x27;, &#x27;Kathy&#x27;, &#x27;Lars&#x27;]);</span><br><span class="line">print(names is List&lt;String&gt;); // true</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a><a href="https://my.oschina.net/zzxzzg/blog/2962518">Mixin</a></h2><ul><li>可以理解为「组合」，形如Java接口但更强大；</li><li>使用方式是通过 <code>class A with B, C, ...</code>，使A得到B、C的方法、字段；</li><li><p>除了普通类，可使用关键字 <code>mixin</code> 定义一种特殊的类，专门表示用来mixin(<code>with</code>)的；  </p><ol><li>mixin类不能继承或被继承，但是可以（或被）<code>implements</code>；</li><li>mixin类可以后接 <code>on</code>，例如 <code>mixin A on B</code> ，用以限定 A 只能被 B 及其子类所<code>with</code>；</li><li>mixin on 所指定的限定类必须包含一个无参无名构造函数；</li></ol></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><code>try-catch-finally</code> 捕获异常；</li><li><p>可以在try模块后接 <code>on + Ex</code> 模块来捕获具体类型的异常，区别于 <code>catch</code> 捕获的是具体异常对象； </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  // A specific exception</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception catch (e) &#123;</span><br><span class="line">  // Anything else that is an exception</span><br><span class="line">  print(&#x27;Unknown exception: $e&#x27;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // No specified type, handles all</span><br><span class="line">  print(&#x27;Something really unknown: $e&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>throw</code> + 字符串 快速抛出异常，也可以继承 <code>Exception</code> 类实现自定义的异常； </p></li><li>使用 <code>reThrow</code> 快速在catch块中再次抛出；</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>支持函数作为参数；</li><li>支持将函数赋值给变量；</li><li><p>由于函数也是对象，所以关键字 <code>Function</code> 如同 <code>num、bool</code> 一样，代表函数的类型，因此，对象可声明的地方，函数也如此，例如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    Function test() &#123;</span><br><span class="line">        return int abc() =&gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的函数都有返回值，如果没有显式指定return，默认返回null；</p></li><li>函数可以省略声明返回类型，这样就是默认的dynamic类型；</li><li><code>=&gt; expr</code> 是对 <code>&#123; return expr; &#125;</code> 的一种简写手法，注意：expr指<strong>表达式</strong>；</li></ul><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ul><li>也是一种类型；</li></ul><p>typedef 用于定义Function类型，具体指参数类型、个数、返回值，而Function的名字只是一个别名，包括以下两种定定义方式：</p><ol><li><code>typedef XXX = void Function(int/String/... x);</code></li><li><code>typedef void XXX(int/String/... x);</code></li></ol><blockquote><p>注意：若省略参数名，则参数类型失效，变为了dynamic</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int Test(Object a, Object);</span><br><span class="line">typedef int ABC(Object a, Object b);</span><br><span class="line">typedef ABC2 = int Function(Object a, Object b);</span><br><span class="line">int sort(Object a, Object b) =&gt; 0;</span><br><span class="line">main() &#123;</span><br><span class="line">  print(Test); // (Object, dynamic) =&gt; int</span><br><span class="line">  print(ABC);  // (Object, Object) =&gt; int</span><br><span class="line">  </span><br><span class="line">  print(&quot;sort is ABC: $&#123;sort is ABC&#125;&quot;); // true</span><br><span class="line">  print(&quot;sort is ABC2: $&#123;sort is ABC2&#125;&quot;); // true</span><br><span class="line">  </span><br><span class="line">  print(&quot;ABC is ABC2: $&#123;ABC is ABC2&#125;&quot;); // false</span><br><span class="line">  print(&quot;ABC == ABC2: $&#123;ABC == ABC2&#125;&quot;); // true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul><li><p><code>switch case</code> 支持省略 <code>break</code> 以继续下一个 <code>case</code> ，但是前提是这个 <code>case</code> 不包含代码，否则异常；如果确要如此，可以使用 <code>continue + label:</code> 的形式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (command) &#123;</span><br><span class="line">  case &#x27;CLOSED&#x27;:</span><br><span class="line">    executeClosed();</span><br><span class="line">    continue nowClosed;</span><br><span class="line">  // Continues executing at the nowClosed label.</span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  case &#x27;NOW_CLOSED&#x27;:</span><br><span class="line">    // Runs for both CLOSED and NOW_CLOSED.</span><br><span class="line">    executeNowClosed();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="external"><a href="#external" class="headerlink" title="external"></a><a href="https://stackoverflow.com/a/24929907">external</a></h2><p>大意是用于修饰函数，表示该函数的具体实现和它定义的地方是分开的。据目前所知，这种形式常用来针对不同平台作不同的具体实现，例如浏览器端和服务端VM的差异实现。</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p><a href="https://segmentfault.com/a/1190000007535316">https://segmentfault.com/a/1190000007535316</a></p><h2 id="sync-async-yield-yield"><a href="#sync-async-yield-yield" class="headerlink" title="sync/async/yield/yield*"></a>sync<em>/async</em>/yield/yield*</h2><p>一种（序列）生成器的概念。<a href="https://www.dartlang.org/articles/language/beyond-async">https://www.dartlang.org/articles/language/beyond-async</a></p><ul><li><p>类似Async-await概念。用Sync<em>/Async</em>修饰函数，函数被调用时，不同于前者立即返回Future，后者是返回Iterable（同步）/Stream（异步）。</p></li><li><p>函数内通过yield发射值到迭代器/流，同步的情况是需要外部pull（惰性）；异步的情况是stream被订阅后主动push；</p></li><li>Sync、ASync是同步和异步的区别，同步情况下，每次yield后会“暂停”，直到下次被pull；异步情况则不会。</li><li>yield后接一个表达式，yield* 则是后接一个子序列（符合同步异步情况的前提下），并将这个子序列转入当前函数的序列中。</li></ul>]]></content>
    
    <summary type="html">
    
      Dart语言博众家之长，本篇以Java语言角度记录一些学习Dart的笔记，期望包含其中的主要差异和特性。
    
    </summary>
    
    
      <category term="Dart" scheme="https://linjiang.tech/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://linjiang.tech/tags/Dart/"/>
    
      <category term="Flutter" scheme="https://linjiang.tech/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>使用InheritedWidget被忽略的要点</title>
    <link href="https://linjiang.tech/2019/02/25/flutter_inherited_note/"/>
    <id>https://linjiang.tech/2019/02/25/flutter_inherited_note/</id>
    <published>2019-02-25T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，flutter提供了一套功能粒度划分非常细的基本组件，并推荐利用组合的方式来构建布局，这确实很便捷、高效，但是也导致了Widget层次结构嵌套非常深，即使是一个很简单的页面。而不论什么页面，控件之间往往存在某些状态依赖关系，假使让一个结构形如“A-&gt;B-&gt;C-&gt;…-&gt;Z”中的A传递数据给Z，如果利用构造函数来一层层传递，效率可想而知。好在官方提供了 <code>InheritedWidget</code> 。</p><p>InheritedWidget的好处不言而喻，从起官方文档的定义即可知：</p><blockquote><p>Base class for widgets that efficiently propagate information down the tree.</p><p>To obtain <strong>the nearest</strong> instance of a particular type of inherited widget from a build context, use BuildContext.inheritFromWidgetOfExactType.</p><p>Inherited widgets, when referenced <strong>in this way</strong>, will cause the consumer to rebuild when the inherited widget itself changes state.</p></blockquote><p>通过直译（加揣度），大意就是包含以下两个特性：</p><ol><li>InheritedWidget是一个可以在树中高效地向下传递数据的组件：我们可以在以 <code>InheritedWidget</code> 为节点的树下任一Widget中调用 <code>BuildContext.inheritFromWidgetOfExactType</code> 来获取离其最近的 <code>InheritedWidget</code> 实例。</li><li>当以上面这种方式（调用<code>inheritFromWidgetOfExactType</code>方法时）被引用后，每当InheritedWidget自身的状态改变时，会导致 “consumer”（调用<code>inheritFromWidgetOfExactType</code>方法的这个Child） 重新 <code>build</code> 。</li></ol><p>SDK提供的Theme就是基于该特性，实现了配置的传递和配置的动态改变。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>目前网上也有很多使用教程，核心大致实现<a href="https://gist.github.com/whataa/f197d3136ac800ccbb254fa4974a732a">inherited_widget_test.dart</a>，其结构图如下所示：</p><html><br><p><br><img src="https://note.youdao.com/yws/api/personal/file/WEB0c9cefa2cc7a5b1908c47cab494588a5?method=download&shareKey=3d07341e3daa253f8569b7fafd833f3e" width=40%><br></p><br></html><p>我们先简单描述下代码逻辑：</p><ul><li><code>WidgetA</code> 调用了<code>inheritFromWidgetOfExactType</code>方法，获得了存放在 <code>MyInherited</code> 对象里的 <code>data</code> 数据并显示在 <code>WidgetA</code> 内容上，同时使得 <code>WidgetA</code> 和 <code>MyInherited</code> 产生关联；</li><li>当点击 <code>FlatButton</code> 触发 <code>MyWidget</code> 状态更新时， <code>MyState</code> 的 <code>build</code> 方法回调，重新构建 <code>MyInherited</code> 对象传入新值，由于<code>data</code>发生变化， <code>MyInherited</code> 的方法 <code>updateShouldNotify</code> 中返回了true，最终使得与<code>MyInherited</code> 关联的 <code>WidgetA</code> 触发reBuild。</li></ul><p>当我们运行并点击<code>FlatButton</code>后，页面表现得确实如上述所示，<code>WidgetA</code>的内容由 <code>WidgetA data = 0</code> 变为了 <code>WidgetA data = 1</code>，似乎 <code>InheritedWidget</code> 正确的使用方式正是如此，但是log里输出的却是如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/flutter: onPressed</span><br><span class="line">I/flutter: MyWidget build</span><br><span class="line">I/flutter: MyInherited construct</span><br><span class="line">I/flutter: MyInherited updateShouldNotify result = true</span><br><span class="line">I/flutter: WidgetA build</span><br><span class="line">I/flutter: WidgetB build</span><br></pre></td></tr></table></figure><p>可以看到，结合前面的代码逻辑分析，理论上只有 <code>WidgetA</code> 才会reBuild，而现在却产生了 <code>I/flutter: WidgetB build</code> 这条记录。这是为什么呢？</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>其实可以从前面提到的特性2找到答案。其中说到：<strong><em>InheriteWidget 状态发生变化时会rebuild相关的child。</em></strong> 我们知道，flutter中Widget被标识为了<code>@immutable</code>，即是不可变的，那么所谓的状态发生变化就意味着InheriteWidget重新构建，由于前面代码中在InheriteWidget构造时同时也构造的其child对象，因此当InheriteWidget重新构建时也会导致child跟着重新构建，这样也就失去了 “rebuild相关的child” 的意义，</p><p><strong><em>也就是说，要想特性2生效，需要保证InheriteWidget节点下的树不会被重新构建。</em></strong> </p><h3 id="推荐做法"><a href="#推荐做法" class="headerlink" title="推荐做法"></a>推荐做法</h3><h4 id="1-使用const-Widget"><a href="#1-使用const-Widget" class="headerlink" title="1. 使用const Widget"></a>1. 使用const Widget</h4><p>将<code>InheriteWidget</code> 的child转化为const，这样即使在重建 <code>InheriteWidget</code> 时，由于其child得到的是同一个对象，也就不会导致这个子树重建，选择性reBuild也就得到了保证。但是由于const特性，相关的参数也必须是常量，因此需要重写或修改的代码量相对较多，因此更推荐下面的做法。</p><h4 id="2-上移Child对象到InheriteWidget的Parent-Widget"><a href="#2-上移Child对象到InheriteWidget的Parent-Widget" class="headerlink" title="2. 上移Child对象到InheriteWidget的Parent Widget"></a>2. 上移Child对象到InheriteWidget的Parent Widget</h4><p>我们可以参考Theme的实现方式，Theme是一个普通的Widget，其build方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// Theme.class</span><br><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    return _InheritedTheme(</span><br><span class="line">      theme: this,</span><br><span class="line">      child: IconTheme(</span><br><span class="line">        data: data.iconTheme,</span><br><span class="line">        child: child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，<code>_InheritedTheme</code> 就是InheritedWidget，其child参数所指向的child对象是在Theme的构造函数中传入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Theme(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    @required this.data,</span><br><span class="line">    this.isMaterialAppTheme = false,</span><br><span class="line">    @required this.child,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><br>这样就避免了当触发Theme的build方法进而导致<code>_InheritedTheme</code>重建时，child也被重新实例化的情况。</p><p>对于StatefulWidget来说，InheritedWidget是在State对象的build方法中实例化的，setState触发的是State的build，而StatefulWidget本身是没有重新实例化的，也就保证了child没有被重新实例化。</p><p>现在我们在保证层级结构不变的前提下，重新对上述式例进行优化，修改后的代码位于<a href="https://gist.github.com/whataa/bef37322816ba8e91b8368a1f716b3ca">inherited_widget_test_2.dart</a>，其中 <code>WidgetA和WidgetB</code> 对象已经提前于InheritedWidget在 <code>MyWidget</code> 构建期间实例化，当<code>MyWidget</code>执行 <code>build</code> 方法时触发InheritedWidget构建时再作为参数传入。这样只要 <code>MyWidget</code> 不重新构建，child也就不会构建，每次触发 <code>MyWidget</code> 的 <code>State</code> 变化时，只有InheritedWidget才会重新构建。</p><p>当我们再次点击FlatButton时，日志将如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I/flutter: onPressed</span><br><span class="line">I/flutter: MyWidget build</span><br><span class="line">I/flutter: MyInherited construct</span><br><span class="line">I/flutter: MyInherited updateShouldNotify result = true</span><br><span class="line">I/flutter: WidgetA build</span><br></pre></td></tr></table></figure></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>InheritedWidget 是学习flutter不得不掌握的一个特殊组件，具备向下传值和选择性reBuild子树节点的特性，许多SDK组件包括第三方库包都是基于其特性实现，本文结合官方文档发现并解决了一个使用InheritedWidget时容易被忽略的问题，并给出推荐方案。</p><p>感谢阅读。</p>]]></content>
    
    <summary type="html">
    
      InheritedWidget是学习flutter不得不掌握的一个特殊组件，具备向下传值和选择性reBuild子树节点的特性，许多SDK组件包括第三方库包都是基于其特性实现，本文结合官方文档发现并解决了一个使用InheritedWidget时容易被忽略的问题，并给出推荐方案。
    
    </summary>
    
    
      <category term="Flutter" scheme="https://linjiang.tech/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://linjiang.tech/tags/Flutter/"/>
    
      <category term="Widget" scheme="https://linjiang.tech/tags/Widget/"/>
    
  </entry>
  
  <entry>
    <title>一种巧妙的drawable.xml替代方案-效果篇</title>
    <link href="https://linjiang.tech/2018/09/08/%E4%B8%80%E7%A7%8D%E5%B7%A7%E5%A6%99%E7%9A%84drawable.xml%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-%E6%95%88%E6%9E%9C%E7%AF%87/"/>
    <id>https://linjiang.tech/2018/09/08/%E4%B8%80%E7%A7%8D%E5%B7%A7%E5%A6%99%E7%9A%84drawable.xml%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-%E6%95%88%E6%9E%9C%E7%AF%87/</id>
    <published>2018-09-08T23:52:00.000Z</published>
    <updated>2023-01-13T08:47:24.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接上一原理篇：<a href="http://linjiang.tech/2018/09/08/%E4%B8%80%E7%A7%8D%E5%B7%A7%E5%A6%99%E7%9A%84drawable.xml%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/">一种巧妙的drawable.xml替代方案</a></p></blockquote><p>在上一篇文章中，我们详细了解到了一种利用DataBinding来替代drawable.xml的方案，但是并没有任何真正的演示代码和效果来呈现，本篇就是此目的。</p><p>本文将以上一篇方案所对应的库<code>NoDrawable</code>来演示，具体的用法请点击链接 <a href="https://github.com/whataa/noDrawable">https://github.com/whataa/noDrawable</a> 查看。以大部分App中都有的登录页为例，以下为设计图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB47eb0205a805ab3c719e4ec0eaf4b643?method=download&amp;shareKey=f2797e4084769c4dd0fd558c1ac87378" alt="image"></p><p>这是一张很常见（正常）的设计图，但是从实现角度来看，按照传统方式，我们至少得新建8个drawable.xml资源文件（没想到吧）：</p><ol><li>整体背景的渐变色；</li><li>输入框的普通状态背景和选中状态背景；</li><li>登录按钮的背景；</li><li>“第三方登录”左右两边的“尾翼”资源，各一个（没办法，即使小，还是得做啊）；</li><li>微信和QQ的按钮各一个（不同的按压效果）；</li></ol><p>可以看出来，仅一张设计图就新建了8个文件，那项目中的其它页面呢？即使按照规范将文件名起得整整齐齐的，保不齐下一次圆角大小变了、同样的圆角单背景色变了…枯燥无味吧。</p><p>现在我们直接用<code>NoDrawable</code>来试试到底能不能达到一个drawable文件都不用创建的效果。</p><blockquote><p>为节约篇幅，以下演示片段均展示与drawable相关的属性，其余省略</p></blockquote><h3 id="1-整体背景的渐变色"><a href="#1-整体背景的渐变色" class="headerlink" title="1. 整体背景的渐变色"></a>1. 整体背景的渐变色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout </span><br><span class="line">    drawable_endColor=&quot;@&#123;0xff3e91ee&#125;&quot;</span><br><span class="line">    drawable_orientation=&quot;@&#123;@integer/orientation_bottom_top&#125;&quot;</span><br><span class="line">    drawable_startColor=&quot;@&#123;0xff02144e&#125;&quot;</span><br><span class="line">    ...</span><br><span class="line">    &gt;</span><br></pre></td></tr></table></figure><h3 id="2-输入框状态"><a href="#2-输入框状态" class="headerlink" title="2. 输入框状态"></a>2. 输入框状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;EditText</span><br><span class="line">    drawable_focused_strokeColor=&quot;@&#123;@color/color_green&#125;&quot;</span><br><span class="line">    drawable_focused_strokeDash=&quot;@&#123;4&#125;&quot;</span><br><span class="line">    drawable_focused_strokeDashGap=&quot;@&#123;4&#125;&quot;</span><br><span class="line">    drawable_focused_strokeWidth=&quot;@&#123;2&#125;&quot;</span><br><span class="line">    drawable_focused_marginLeft=&quot;@&#123;-3&#125;&quot;</span><br><span class="line">    drawable_focused_marginTop=&quot;@&#123;-3&#125;&quot;</span><br><span class="line">    drawable_focused_marginRight=&quot;@&#123;-3&#125;&quot;</span><br><span class="line">    drawable_radius=&quot;@&#123;21&#125;&quot;</span><br><span class="line">    drawable_solidColor=&quot;@&#123;0x7fffffff&#125;&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h3 id="3-登录按钮的背景"><a href="#3-登录按钮的背景" class="headerlink" title="3. 登录按钮的背景"></a>3. 登录按钮的背景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    drawable_radius=&quot;@&#123;21&#125;&quot;</span><br><span class="line">    drawable_solidColor=&quot;@&#123;0xff818385&#125;&quot;</span><br><span class="line">    drawable_enabled_radius=&quot;@&#123;21&#125;&quot;</span><br><span class="line">    drawable_enabled_solidColor=&quot;@&#123;0xff59c8d8&#125;&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h3 id="4-“第三方登录”左右两边的“尾翼”"><a href="#4-“第三方登录”左右两边的“尾翼”" class="headerlink" title="4. “第三方登录”左右两边的“尾翼”"></a>4. “第三方登录”左右两边的“尾翼”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">    drawable_endColor=&quot;@&#123;0x00000000&#125;&quot;</span><br><span class="line">    drawable_orientation=&quot;@&#123;@integer/orientation_right_left&#125;&quot;</span><br><span class="line">    drawable_startColor=&quot;@&#123;0xffffffff&#125;&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h3 id="5-微信按钮按压效果"><a href="#5-微信按钮按压效果" class="headerlink" title="5. 微信按钮按压效果"></a>5. 微信按钮按压效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    drawable_pressed_shapeMode=&quot;@&#123;@integer/shapeMode_oval&#125;&quot;</span><br><span class="line">    drawable_pressed_solidColor=&quot;@&#123;0xff54B536&#125;&quot;</span><br><span class="line">    drawable_shapeMode=&quot;@&#123;1&#125;&quot;</span><br><span class="line">    drawable_solidColor=&quot;@&#123;0xffDCDFE8&#125;&quot;</span><br><span class="line">    ...</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>结合 <a href="https://github.com/whataa/noDrawable">NoDrawable</a> 的属性文档，不知大家是否可以理解到位。根据上述代码片段，我们可以总结到该方案的两大特性：</p><ol><li>高可读性</li></ol><p>直接在布局中的View标签声明drawable属性，对View最终效果一目了然；</p><ol><li>适配任意View</li></ol><p>像使用View自身的属性一样，作用于任何View；</p><p>效果图就不贴了，和设计图一模一样。大家如果有具体需求，可直接到<code>NoDrawable</code>仓库地址查看，其demo包含本文完整的代码及效果预览，最后，感谢阅读。</p>]]></content>
    
    <summary type="html">
    
      本篇接上一篇，以演示代码和效果呈现。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="开源项目" scheme="https://linjiang.tech/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>一种巧妙的drawable.xml替代方案</title>
    <link href="https://linjiang.tech/2018/09/08/%E4%B8%80%E7%A7%8D%E5%B7%A7%E5%A6%99%E7%9A%84drawable.xml%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/"/>
    <id>https://linjiang.tech/2018/09/08/%E4%B8%80%E7%A7%8D%E5%B7%A7%E5%A6%99%E7%9A%84drawable.xml%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</id>
    <published>2018-09-08T23:40:00.000Z</published>
    <updated>2023-01-13T08:47:24.491Z</updated>
    
    <content type="html"><![CDATA[<p>如何维护（替换）drawable xml是android开发中一个老生常谈的话题。按照标准的Android布局开发模式，我们不得不为各种UI效果新建不同的xml文件进行描述，哪怕是简单的一个圆角。随着项目迭代，成百上千的xml连同那模棱两可的文件名，不仅让开发者复用或清理的成本难以估计，还使得项目体积急剧增大。因此，下面我们探索一种原理巧妙、适配全面的drawable替代方案。</p><h2 id="传统方案总结"><a href="#传统方案总结" class="headerlink" title="传统方案总结"></a>传统方案总结</h2><p>我们先概括下目前市面上已有的方案，大致分为两种实现方式。</p><p>一种是继承某个（或某几个）常用的控件，然后将drawable.xml中的常用属性作为当前控件的自定义属性，最后在控件内部动态生成drawable作为该控件的背景。这种方案的优点很明显：能直观地将drawable效果描述作为控件的属性定义在布局xml中，具有很好的可读性；但是缺点也不可忽视，这些属性并不能应用到任意控件，导致在很多时候还是不得不创建drawable.xml文件。</p><p>另一种方案则是将drawable的常用属性封装为代码API，以动态的方式在代码中生成并赋值给控件。这种方案理论上完全抛弃了drawable.xml，可以适配任意控件，但是若想完全以这种方式达到完全替换xml，个人觉得不可能，代码量大，关联性低是其最大的缺点，单看布局，无从知晓该控件的最终效果。不过，如果两相结合，作为对第一种方案的补充倒是一个不错的方案。</p><h2 id="新方案探索"><a href="#新方案探索" class="headerlink" title="新方案探索"></a>新方案探索</h2><p>上述两种方案各有千秋，但都无法完全解决问题，我们对上述两种方案进行分析，提出以下问题：为什么不能有一种「既具有高可读性，又能全面适配」的drawable.xml替代方案呢？也就是说能同时兼顾前面提到的两种方案的优点，高可读性意味着对drawable的描述需要作为属性定义在布局文件中、全面适配意味这些属性对任意控件都有效。思来想去，答案似乎只有一个：DataBinding。说到这里，可能有些朋友已经隐隐猜到了，不过别急，容我娓娓道来。</p><p>DataBinding是Android官方推出的数据绑定库，尽管已有数年，但是我估计仍有部分开发者还没有接触甚至有些抵触，具体就不细说，但是我希望你暂且能拥抱它，继续阅读。<br>数据绑定让数据变化能直接反映到布局中，对于控件已有的属性，例如TextView的<code>android:text</code>属性，一旦通过DataBinding绑定：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:text=&quot;@&#123;name&#125;&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure><br>在运行时内部就会调用TextView内部的setText方法。其实现原理的关键就是DataBinding通过提供的<code>@BindingAdapter</code>注解，该注解将任意指定的属性和任意指定的方法关联，DataBinding会在编译的时候动态生成的调用关系，而对于常用的控件，DataBinding已经预置了对应的注解方法，例如以下就是TextView的setText方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:text&quot;)</span><br><span class="line">public static void setText(TextView view, CharSequence text) &#123;</span><br><span class="line">    final CharSequence oldText = view.getText();</span><br><span class="line">    if (text == oldText || (text == null &amp;&amp; oldText.length() == 0)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (text instanceof Spanned) &#123;</span><br><span class="line">        if (text.equals(oldText)) &#123;</span><br><span class="line">            return; // No change in the spans, so don&#x27;t set anything.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (!haveContentsChanged(text, oldText)) &#123;</span><br><span class="line">        return; // No content changes, so don&#x27;t set anything.</span><br><span class="line">    &#125;</span><br><span class="line">    view.setText(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们需要关注的就是这个<code>@BindingAdapter</code>注解，「任意指定的属性」这个属性并非特指我们在布局中Android提供的标准属性，也就是说，我们可以提供任意字符串作为属性，而任意方法很好理解，上面的代码片段很好的表达了这个意思，我们唯一需要关注的就是这个方法的参数：第一个参数是指定注解中的属性的作用域，后面的参数则是和注解所声明的属性一一对应，那么结合到我们本文的主题，答案也就呼之欲出了：</p><h2 id="新方案实现"><a href="#新方案实现" class="headerlink" title="新方案实现"></a>新方案实现</h2><p>提供一个用<code>@BindingAdapter</code>注解的方法，作用域指定为View（即任意控件）；参数约定为drawable.xml中的属性，不就达到了目的吗。是否是感觉到一丝丝巧妙？既然方案有了，下面我们来看具体实现。</p><p>限于drawable属性的丰富性，本文以常用的属性solid 和 corner为例展开。如以下片段所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(value = &#123;</span><br><span class="line">        &quot;drawable_solidColor&quot;,</span><br><span class="line">        &quot;drawable_radius&quot;,</span><br><span class="line">&#125;, requireAll = false)</span><br><span class="line">public static void setViewBackground(View v, int color, int radius) &#123;</span><br><span class="line">    GradientDrawable drawable = new GradientDrawable();</span><br><span class="line">    drawable.setColor(color);</span><br><span class="line">    drawable.setCornerRadius(radius);</span><br><span class="line">    view.setBackground(drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面代码片段定义了两个属性：<code>drawable_solidColor</code>, <code>drawable_radius</code>，分别表示solid的color和corner的radius属性，也就是说稍后我们就就可以在布局文件中为每个View都指定该属性了；</p><p>这里可能有朋友会产生疑问，drawable的属性那么多，这里只定义了两个还好，如果把所有的drawable属性都定义，那岂不是每个控件都要把每个属性都指定一次，即使不需要。所以还需要提一下<code>requireAll</code>参数，它表示是否需要每个属性都必须绑定了数据才会调用<code>setViewBackground</code>方法，设置为false后，就可以在布局文件中只指定需要的属性即可。</p><p>以上几行代码完成了基本定义，下面我们来看看如何使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        drawable_radius=&quot;@&#123;10&#125;&quot;</span><br><span class="line">        drawable_solidColor=&quot;@&#123;0xffff0000&#125;&quot;</span><br><span class="line">        </span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot; /&gt;</span><br><span class="line">&lt;layout/&gt;</span><br></pre></td></tr></table></figure></p><p>不用怀疑，就是这么简单，即使这里不贴出效果图，我想大家脑海中已经浮现出来了，是不是觉得一目了然？以此类推，其它的drawable属性也可以通过本方案逐一实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾本文，并没有任何复杂的代码或高深的逻辑组合，仅提出一种巧妙的drawable.xml替代方案，具有「既具有高可读性，又能全面适配」的特点。</p><p>从成本来说，本方案应该是最低的（特别是对一些已经在使用DataBinding的项目）：只需要定义一个方法即可，而效果却是最优的：理论来讲，实现该方案后，可以减少99%的drawable.xml创建。<br>如果非要说出本方案的缺点，那么它的实现原理所依赖的核心库DataBinding可能是有些开发者所不能接受的。</p><p>读到这里，是否觉得意犹未尽？没错，我已依据本文的方案替大家整理好了几乎所有常用的drawable属性提交到了GitHub，核心依然是只有一个方法，直接可用。</p><p>Github地址：<a href="https://github.com/whataa/noDrawable">https://github.com/whataa/noDrawable</a></p>]]></content>
    
    <summary type="html">
    
      如何维护（替换）drawable xml是android开发中一个老生常谈的话题。按照标准的Android布局开发模式，我们不得不为各种UI效果新建不同的xml文件进行描述，哪怕是简单的一个圆角。随着项目迭代，成百上千的xml连同那模棱两可的文件名，不仅让开发者复用或清理的成本难以估计，还使得项目体积急剧增大。因此，下面我们探索一种原理巧妙、适配全面的drawable替代方案。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="开源项目" scheme="https://linjiang.tech/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Large Database Queries on Android[译]</title>
    <link href="https://linjiang.tech/2018/03/10/[%E8%AF%91]Large%20Database%20Queries%20on%20Android/"/>
    <id>https://linjiang.tech/2018/03/10/[%E8%AF%91]Large%20Database%20Queries%20on%20Android/</id>
    <published>2018-03-10T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>译自：<a href="https://medium.com/google-developers/large-database-queries-on-android-cb043ae626e8">Large Database Queries on Android</a></p><h2 id="SQLiteCursor-and-CursorAdapter"><a href="#SQLiteCursor-and-CursorAdapter" class="headerlink" title="SQLiteCursor and CursorAdapter"></a>SQLiteCursor and CursorAdapter</h2><p><code>SQLiteCursor</code>是Android SQLite数据库查询返回的类型。我们可以耗费固定的初始化加载成本来检索大数据量的查询结果。首次查询将初始化一个通常为2MB大小的缓冲窗口<code>CursorWindow</code>，用于存放从数据库中查询的结果。当我们所要查询的行不位于该缓冲区时，<code>SQLiteCursor</code>就会重新查询数据库并刷新窗口。通过这种方式，<code>SQLiteCursor</code>实现了一种大小固定的分页方式。</p><p>Android API 1 时就提供了一个叫<code>CursorAdapter</code>的类，提供一种简便的方式来方便从<code>Cursor</code>中读取数据绑定到ListView的items中。它的功能是挺好的，<strong>但每次需要加载新数据时，它都是直接在UI线程上查询的数据库</strong>，违背了现代的响应式App思想。那么有人可能会问：我们就不能改造一个在异步线程加载数据的新<code>CursorAdapter</code>吗？毕竟<code>SQLiteCursor</code>已经内置了分页功能。</p><h2 id="Problems-with-paging-within-SQLiteCursor"><a href="#Problems-with-paging-within-SQLiteCursor" class="headerlink" title="Problems with paging within SQLiteCursor"></a>Problems with paging within SQLiteCursor</h2><p>其实，不能基于<code>SQLiteCursor</code>分页的归根结底的原因正是由于它使用了固定缓存大小的窗口来对查询结果进行分页。以下是我们在尝试使用基于<code>SQLiteCursor</code>内部分页的<code>Paging Library</code>时罗列的一些问题：</p><h3 id="1-SQLiteCursor-doesn’t-hold-any-database-transaction-open"><a href="#1-SQLiteCursor-doesn’t-hold-any-database-transaction-open" class="headerlink" title="1. SQLiteCursor doesn’t hold any database transaction open"></a>1. SQLiteCursor doesn’t hold any database transaction open</h3><p>在准备深入了解Paging前，其实我对Android中的SQLite尤其是<code>Cursors</code>不是太了解，所以我只得假设<code>SQLiteCursor</code>在加载了一个窗口后就暂停，当需要时（下个窗口）再恢复。这样的话，访问第10个窗口与访问第1个窗口是一样的效率，其实最终证明这是非常错误的。每次需要读取一个新的窗口时，底层查询都是从0开始并跳过我们不需要的行，最后将结果填充到窗口的。这是因为<code>SQLiteCursor</code>无法恢复一个查询。</p><p>也就是说，假如我们想访问集合中的1000到1050项，我们不得不跳过大量的项，才能访问到下一页，这样子下来，每个后续窗口必须跳过越来越多的查询，严重降低查询速度。这相当于使用SQL OFFSET关键字跳过内容，尽管不是对内容分页最有效的方式，但利用<code>SQLiteCursor</code>来进行分页时无法避免。</p><h3 id="2-SQLiteCursor-getCount-is-required-and-scans-entire-query"><a href="#2-SQLiteCursor-getCount-is-required-and-scans-entire-query" class="headerlink" title="2. SQLiteCursor.getCount() is required, and scans entire query"></a>2. SQLiteCursor.getCount() is required, and scans entire query</h3><p>在读取第一行之前，<code>SQLiteCursor</code>需要通过调用<code>getCount()</code>来进行边界检测，但是SQLite必须检索所查询的整个结果集才能知道其大小（like a linked list），无形加大了开销。如果我们将本地的一组大数据集逐渐分页显示到UI中，用以响应用户的滚动，我们可能根本就不需要知道查询结果的整个大小，那么前面所说的<code>getCount()</code>无疑增加了不必要的前期工作。</p><h3 id="3-QLiteCursor-getCount-always-loads-the-first-window-of-rows"><a href="#3-QLiteCursor-getCount-always-loads-the-first-window-of-rows" class="headerlink" title="3. QLiteCursor.getCount() always loads the first window of rows"></a>3. QLiteCursor.getCount() always loads the first window of rows</h3><p>在上面边界检测步骤中，检索查询结果集时，如果有用，<code>SQLiteCursor</code>同时还会自动地从0开始填充缓冲窗口。</p><p>预加载这些数据，以便它可以提前知道大约多少行对一个窗口适合（下面的更多内容）。如果我们从查询的位置0开始展示数据，则此这种预加载机制是合理的，但是如果触发保存的实例保存和恢复机制，那么恢复的位置可能会从离列表位置0的很远处开始检索，而这个位置已经超出了初始的窗口。如果想要显示第三个内容窗口的数据，则必须首先加载并丢弃2MB数据。</p><p>// code is <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/sqlite/SQLiteCursor.java#130">here</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getCount() &#123;</span><br><span class="line">    if (mCount == NO_COUNT) &#123;</span><br><span class="line">        fillWindow(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return mCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-SQLiteCursor-may-load-data-you-didn’t-ask-for"><a href="#4-SQLiteCursor-may-load-data-you-didn’t-ask-for" class="headerlink" title="4. SQLiteCursor may load data you didn’t ask for"></a>4. SQLiteCursor may load data you didn’t ask for</h3><p><code>Cursor.moveToPosition()</code>保证所请求的行在窗口中。但是<code>SQLiteCursor</code>并不会在请求发起的位置处开始填充窗口。因为<code>SQLiteCursor</code>不能保证App就一定是向后读取，因此它实际上是从离结果集的目标位置大约1/3处的取出开始填充窗口。这意味着当一个窗口加载完成后，<code>CursorAdapter</code>向后滚动几行时不会触发刷新（重新填充）窗口。这也意味着在第一次加载之后加载的每个2MB数据窗口都加载了约650KB或更多的我们已经看到的数据。</p><p>// code is <a href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/DatabaseUtils.java#742">here</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int cursorPickFillWindowStartPosition(</span><br><span class="line">            int cursorPosition, int cursorWindowCapacity) &#123;</span><br><span class="line">    return Math.max(cursorPosition - cursorWindowCapacity / 3, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-SQLiteCursor-loading-position-can-be-unpredictable"><a href="#5-SQLiteCursor-loading-position-can-be-unpredictable" class="headerlink" title="5. SQLiteCursor loading position can be unpredictable"></a>5. SQLiteCursor loading position can be unpredictable</h3><p>前面说到<code>SQLiteCursor</code>尝试加载指定位置数据时，会尝试向前倒推1/3往窗口填充数据，这就意味着它必须猜测一个缓冲窗口大致可以容纳多少行数据，因此它会将查询出所有的行先填充到第一个窗口。但不幸的是，如果我们所查询的内容的行数是不确定的（例如用户评论），那么这种方式就不可靠，<code>SQLiteCursor</code>可能还没到到达指定位置，窗口就填满了，那么就必须丢弃掉已填充的然后再次填充新的。例如假如我们查询的一大段数据，触发重新填充窗口，就有可能加载到窗口的数据只有一小部分。</p><h3 id="6-Cursors-require-closure"><a href="#6-Cursors-require-closure" class="headerlink" title="6. Cursors require closure"></a>6. Cursors require closure</h3><p>Cursor必须显式地调用<code>close()</code>进行关闭，所以无论哪里，都必须在不再需要时调用方法以释放。尤其是<code>CursorAdapter</code>，它内部并没有帮我们实现这些，而是把这个事情交给了开发者，那么为了写入或重用Cursor，就必须编写额外代码来处理情况，例如当Activity stopping时。</p><h3 id="7-SQLiteCursor-does-not-know-data-has-changed"><a href="#7-SQLiteCursor-does-not-know-data-has-changed" class="headerlink" title="7. SQLiteCursor does not know data has changed"></a>7. SQLiteCursor does not know data has changed</h3><p>在窗口首次填充完成后，<code>CursorAdapter</code>并不会track数据库是否改变，也就是说如果我们新增或删除了一些数据，SQLiteCursor’s的缓存就是脏数据了，那么当我们移动到一个未知的行位置时就可能导致Exception或在某些情况下得到不一致的数据。例如假如我们已经加载了N行数据，此时在位置0处插入了一条新的数据，那么当我们尝试读取第N+1行时，结果会导致重复加载第N行。</p><h2 id="Avoiding-the-Problems"><a href="#Avoiding-the-Problems" class="headerlink" title="Avoiding the Problems"></a>Avoiding the Problems</h2><p>由以上所有的问题可知，<code>SQLCursor</code>适用的场景非常有限。不过幸运的是这些问题都有一个简单的解决方案：小查询（small query）。采用刚好装满<code>CursorWindow</code>的查询就可以避免以上问题，这就是为什么我们如此喜欢<code>Paging and Room</code>的原因。通常我们建议一页大小配置为10到20个，并且每次只查询这么多。</p><p>尽管如此，选择每页大小也有一些需要了解的：较大的窗口查询通常可以提高性能，较小的可以减少等待时间并节约内存。如果DB不是瓶颈的话，对于大item一般每次10个差不多，如果每项数据很小的话，每次300可能会更好点，否则的话查询就很浪费了。</p><p>如果正好有谁想使用<code>SQLiteCursor</code>内部的分页机制来懒加载一组大量的数据的打算，我们建议你可以考虑另外的方案：要么使用<code>Paging Library</code>，它可以与<code>Room</code>完美配合；要么就自己实现并且需要确保每次查询的结果足够小，以刚好适配单个<code>CursorWindow</code>的大小。</p><p>如果使用Room和Paging Library将一个大查询分页为多个小查询，我们需要将以下代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface UserDao &#123;</span><br><span class="line">    // regular list query — falls over with too much data</span><br><span class="line">    @Query(“SELECT * FROM user ORDER BY mAge DESC”)</span><br><span class="line">    LiveData&lt;List&lt;User&gt;&gt; loadUsersByAgeDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>改为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface UserDao &#123;</span><br><span class="line">    // paged query — handles arbitrarily large queries</span><br><span class="line">    @Query(“SELECT * FROM user ORDER BY mAge DESC”)</span><br><span class="line">    DataSource.Factory&lt;Integer, User&gt; loadUsersByAgeDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后通过<code>LivePagedListBuilder</code>包装，得到一个可以处理任意大小的结果集<code>LiveData&lt;PagedList&gt;</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;PagedList&lt;User&gt;&gt; users = new LivePagedListBuilder&lt;&gt;(</span><br><span class="line">        userDao.loadUsersByAgeDesc(), /*page size*/ 20).build();</span><br></pre></td></tr></table></figure><br>上面的代码最终得到的分页结果<code>LiveData</code>，在数据库数据变化时会实时同步给所有已订阅的观察者。</p><p>最后附上参考用例：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample">Google’s Paging sample on Github</a></p><h2 id="Android-Platform"><a href="#Android-Platform" class="headerlink" title="Android Platform"></a>Android Platform</h2><p>“ 我们目前正在考虑在未来的Android版本中改进SQLiteCursor的一些行为。例如将<code>CursorWindow</code>的大小和1/3的加载机制修改为可配置的方案，因为实际使用现状看起来与当时设计SQLiteCursor和CursorAdapter时所想的截然不同。当我们决定更改时，我们同时一定会更新<code>Room Persistence Library</code>以使这些新特性保持查询效率 ”。</p>]]></content>
    
    <summary type="html">
    
      Paging Library的背景知识：Android中的分页加载SQLiteCursor存在的问题和限制。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="https://linjiang.tech/tags/Android/"/>
    
      <category term="译文" scheme="https://linjiang.tech/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>使用sublime提升mars-xlog日志文件分析效率</title>
    <link href="https://linjiang.tech/2017/08/06/Use%20sublime%20to%20enhance%20the%20efficiency%20of%20analyzing%20mars-xlog%20log%20files/"/>
    <id>https://linjiang.tech/2017/08/06/Use%20sublime%20to%20enhance%20the%20efficiency%20of%20analyzing%20mars-xlog%20log%20files/</id>
    <published>2017-08-06T23:50:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于个人所负责的模块的不确定性，需要预埋大量的日志以便更精准地分析和定位问题、同时升级项目中原有的日志系统的需求又刚好提上了日程，于是通过和同事的几天调研，最终将公司App的日志系统替换为了微信开源的Mars-xlog组件，关于xlog的优势和使用方式可直接参见其<a href="https://github.com/Tencent/mars/tree/master/mars/log">官方Github</a>，这里仅记录拿到收集的日志文件后，如何提升对日志的分析的效率的小技巧。</p><p>参考Android Studio的Logcat，结合xlog文件的特性，以最省心和高效的方式来看，可优化的方面包括：自动化解压和打开、语法高亮两方面。</p><h2 id="自动化解压和打开-open-build"><a href="#自动化解压和打开-open-build" class="headerlink" title="自动化解压和打开(open-build)"></a>自动化解压和打开(open-build)</h2><p>xlog在异步模式下会自动开启内容压缩，若直接打开，看到的将全是16进制的数字，所以微信提供了脚本<code>decode_mars_log_file.py</code>来解压，我们所需要做的首先是打开终端，cd到对应的路径，执行<code>python decode_mars_log_file.py xxx.xlog命令</code>以生成最终的xxx.xlog.log文件，然后再打开文件……，作为开发，怎能忍受这么麻烦的操作存在，这里就需要抡起sublime了。</p><blockquote><p>小技巧：.log的文件默认是以“控制台”程序打开，可以通过<code>“右键 - 显示简介 - 打开方式 - 选择‘sublime’ - 全部更改”</code>的方法修改默认配置。</p></blockquote><p>总所周知，sublime可以编辑和编译大部分主流的编程语言文件(js、java、php……)，这得益于其强大的构建系统(build system)的自定义，因此这里利用该方案来“build”我们的xlog文件。打开sublime，选择 <code>工具栏 - tool - Build System - New Build System</code>来为xlog文件配置构建方案。在弹出的新文件编辑窗口中填写以下内容即可：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;cmd&quot;: [&quot;$packages/User/decode_mars_log_file.py&quot;, &quot;$file&quot;],</span><br><span class="line">&quot;selector&quot;: &quot;source.xlog&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然后保存为例如<code>SampleXlog.sublime-build</code>。</p><blockquote><p>关于如何编写这些配置，具体可以参考sublime官方文档-<a href="http://sublime-text.readthedocs.io/en/latest/reference/build_systems.html#id1">Build System章节【译】</a></p></blockquote><p>由于sublime本身对python的支持，所以我们可以直接指定相应的参数。</p><ul><li>其中cmd的值的第一个元素表示前面提到的用于解压缩的脚本的路径，<code>$packages</code>变量表示sublime本地的Packages路径，因此这里第二个步骤就是将<code>decode_mars_log_file.py</code>文件copy到上述路径下；  </li><li>第二个元素变量表示当前文件，如果当前窗口是打开的xlog文件，<code>$file</code>就表示它。<br>另外还有个selector，我们稍后再解释。</li></ul><p>完成上述步骤后如果我们直接选中SampleXlog并点击Build，我们会发现在本地文件系统打开的xlog文件旁边生成了解压缩后的文件<code>xxx.xlog.log</code>，但是……这并没有什么*用，讲了大半天就给看这个？</p><p>其实很容易就可以给出解决方案：只要将其解压后的内容的存放位置从原来生成的新文件修改为源文件本身，就可以实现“open-build”，对于解压前的内容，我们本身就不关心。因此，打开<code>decode_mars_log_file.py</code>文件，修改其main方法，将传入ParseFile的第二个参数修改为第一个参数一样的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def main(args):</span><br><span class="line">    global lastseq</span><br><span class="line">    if 1==len(args):</span><br><span class="line">        if os.path.isdir(args[0]):</span><br><span class="line">            filelist = glob.glob(args[0] + &quot;/*.xlog&quot;)</span><br><span class="line">            for filepath in filelist:</span><br><span class="line">                lastseq = 0</span><br><span class="line">                ParseFile(filepath, filepath)</span><br><span class="line">        else: ParseFile(args[0], args[0]) #这里   </span><br><span class="line">    elif 2==len(args):</span><br><span class="line">        ParseFile(args[0], args[1]) #这里手动指定了存放文件，就不修改了 （虽然并不会走到这里）  </span><br><span class="line">    else: </span><br><span class="line">        filelist = glob.glob(&quot;*.xlog&quot;)</span><br><span class="line">        for filepath in filelist:</span><br><span class="line">            lastseq = 0</span><br><span class="line">            ParseFile(filepath, filepath) #这里（虽然并不会走到这里） </span><br></pre></td></tr></table></figure><br>到这里，我们再重试手动Build，解压的内容便成功地覆盖了先前那不知所云的内容。但是密密麻麻的一大片白色字符，眼睛开始痛了起来。在logcat中的红黄蓝绿等所标识的VIDWEF等级显得多么的美丽。</p><h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>不用刻意注意就知道sublime在打开的例如js、Java等文件时，会自动对相关关键字、方法变量等进行颜色区分，或者直接说语法高亮，其中的原因便是sublime内置了对这些语言的高亮配置方案，因此我们还是可以以为xlog配置build方案的模式来同样为xlog配置“语法高亮”方案。</p><p>在sublime中，每种语法的高亮配置是以xml格式的内容组成，而为了更方便的制作高亮配置，已经有前人提供了相应方案，例如sublime的PackageDev插件，以更直观的方式进行编辑。安装好之后，点击<code>“工具栏 - tool - Packages - Package Development - Syntax Definition”</code>来为xlog文件指定高亮方案。如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># [PackageDev] target_format: plist, ext: tmLanguage</span><br><span class="line">---</span><br><span class="line">name: Codoon Xlog</span><br><span class="line">scopeName: source.xlog</span><br><span class="line">fileTypes: [&quot;xlog&quot;, &quot;xlog.log&quot;]</span><br><span class="line">uuid: af21ab18-b1b3-4929-8999-2654833418f4</span><br><span class="line"></span><br><span class="line">patterns:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><ul><li>name：表示该方案的名称，随意；</li><li>scopeName：这个字段很重要了，可以将其理解为一套“语法方案”，注意将其与下面的fileTypes区分开来，还记得前面在为xlog配置build方案时忽略了一个selector属性吗，这下应该明白了，也就是说，如果发现该文件内容是xlog“语法方案”，那么就sublime就会自动将其build方案指定为<code>SampleXlog</code>；</li><li>fileTypes：大概跟文件类型通配符类似，这里指定了只要文件名是以xlog、xlog.log形式结尾的，都将适用于本方案；</li><li>uuid：自动生成，勿删除；</li></ul><p>接下来最重要的就是这个patterns了，如需详细了解，请自行参考<a href="http://www.sublimetext.com/docs/3/syntax.html">官方文档</a>，可以以一句大白话概括：用正则匹配语句并指定高亮模式，每一种高亮模式在不同的主题中都有对应的颜色，具体颜色可以访问<a href="http://tmtheme-editor.herokuapp.com/#!/editor/theme/Monokai">自定义sublime主题颜色-Sublime Color Editor网站</a>。那么有了这些基础了解，xlog的高亮方案也就可以很简单的匹配出来了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">patterns:</span><br><span class="line">- comment: others</span><br><span class="line">  name: comment</span><br><span class="line">  match: (\^|d|g|M|l).*</span><br><span class="line"></span><br><span class="line">- comment: verbose</span><br><span class="line">  name: variable</span><br><span class="line">  match: (\[V])(\[.*?])(\[.*?])(\[.*?])(\[.*?])(\[.*)</span><br><span class="line">  captures:</span><br><span class="line">    &#x27;1&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;2&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;3&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;4&#x27;: &#123;name: string&#125;</span><br><span class="line">    &#x27;5&#x27;: &#123;name: constant.numeric&#125;</span><br><span class="line"></span><br><span class="line">- comment: debug</span><br><span class="line">  name: support.function</span><br><span class="line">  match: (\[D])(\[.*?])(\[.*?])(\[.*?])(\[.*?])(\[.*)</span><br><span class="line">  captures:</span><br><span class="line">    &#x27;1&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;2&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;3&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;4&#x27;: &#123;name: string&#125;</span><br><span class="line">    &#x27;5&#x27;: &#123;name: constant.numeric&#125;</span><br><span class="line"></span><br><span class="line">- comment: info </span><br><span class="line">  name: entity.name.function</span><br><span class="line">  match: (\[I])(\[.*?])(\[.*?])(\[.*?])(\[.*?])(\[.*)</span><br><span class="line">  captures:</span><br><span class="line">    &#x27;1&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;2&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;3&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;4&#x27;: &#123;name: string&#125;</span><br><span class="line">    &#x27;5&#x27;: &#123;name: constant.numeric&#125;</span><br><span class="line"></span><br><span class="line">- comment: warn</span><br><span class="line">  name: variable.parameter</span><br><span class="line">  match: (\[W])(\[.*?])(\[.*?])(\[.*?])(\[.*?])(\[.*)</span><br><span class="line">  captures:</span><br><span class="line">    &#x27;1&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;2&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;3&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;4&#x27;: &#123;name: string&#125;</span><br><span class="line">    &#x27;5&#x27;: &#123;name: constant.numeric&#125;</span><br><span class="line"></span><br><span class="line">- comment: error</span><br><span class="line">  name: keyword.other</span><br><span class="line">  match: (\[E])(\[.*?])(\[.*?])(\[.*?])(\[.*?])(\[.*)</span><br><span class="line">  captures:</span><br><span class="line">    &#x27;1&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;2&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;3&#x27;: &#123;name: comment&#125;</span><br><span class="line">    &#x27;4&#x27;: &#123;name: string&#125;</span><br><span class="line">    &#x27;5&#x27;: &#123;name: constant.numeric&#125;</span><br></pre></td></tr></table></figure><br>其中</p><ul><li>comment相当于注释；</li><li>name表示该套模式的名字；</li><li>match该套模式的正则表达式，入门正则，可以看看<a href="https://deerchao.net/tutorials/regex/regex.htm">这一篇</a>；</li><li>captures是可选的，是对match粒度的进一步细分；</li></ul><p>保存后，还需要执行build将这种编写方式转化为sublime的格式，最后大功告成，看看效果：<img src="http://note.youdao.com/yws/api/personal/file/WEB06c09e65828a99e4080f24621c08cd95?method=download&amp;shareKey=41254dace5879db69c65ad295eb7a0d4" alt="image"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>虽然sublime自带强大的搜索/过滤，但以用途和方便而言，这里还是推荐一下<a href="https://github.com/davidpeckham/sublime-filterlines">Filter Lines插件</a>，可以更好地帮助日志的粗分，最重要的是可以以<strong>行</strong>为单位进行过滤。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后来总结一下，本文方案其实就是利用sublime的特性，通过将xlog文件当作一种“语言”的方式来为其配置自定义的“语法高亮”规则和“编译”规则，实现了xlog文件的快速解压和查看，极大的提升了日志分析的效率；使用方式也非常方便，直接双击xlog在sublime中打开，然后快捷键F7或command+B执行加压缩，便得到了形如logcat的日志内容。</p><p>另外，需要说明的有两点：</p><ol><li>本文所使用的xlog未修改源码，其余压缩方案、加密解密、自定义格式化等修改请自行参考；</li><li>本文所涉及的路径描述、生产环境均基于mac，其它系统请自行参考。</li></ol>]]></content>
    
    <summary type="html">
    
      最近由于个人所负责的模块的不确定性，需要预埋大量的日志以便更精准地分析和定位问题、同时升级项目中原有的日志系统的需求又刚好提上了日程，于是通过和同事的几天调研，最终将公司App的日志系统替换为了微信开源的Mars-xlog组件，关于xlog的优势和使用方式可直接参见其[官方Github](https://github.com/Tencent/mars/tree/master/mars/log)，这里仅记录拿到收集的日志文件后，如何提升对日志的分析的效率的小技巧。
    
    </summary>
    
    
      <category term="工具插件" scheme="https://linjiang.tech/categories/%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="log" scheme="https://linjiang.tech/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Touch事件概述及自定义事件处理的被忽视的重要细节</title>
    <link href="https://linjiang.tech/2017/03/27/Touch%20summary%20and%20critical%20details%20of%20custom-event/"/>
    <id>https://linjiang.tech/2017/03/27/Touch%20summary%20and%20critical%20details%20of%20custom-event/</id>
    <published>2017-03-27T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>从接触视图的自定义手势处理这块知识到现在也有1年多，期间陆陆续续在实际开发中实现了一些自定义组件，但是不如一些每天都需要用到的知识点，所以久了一些重要的原理和技巧就淡忘了，最近终于抽出时间来整理。没有按照以往贴上源码挨着顺序分析，因为网上一搜就有很多讲解得很好的文章，所以本篇主要的目的是便于自我的一个快速地回顾和印象增强。文章如同标题所述主要分为两部分，前半部分主要是一个流程和Touch相关知识点的概述，期间罗列了一些常见例子帮助分析，差不多都是点到为止，后半部分则是在实际开发中，对手势处理的一些很容易被忽视的细节点，当然并不是说不了解这些细节点就无法进行自定义处理逻辑，但是掌握有助于理清处理手势的一些步骤，因此从整体而言，本篇也算是一篇不错的初学者入门篇。</p><h2 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h2><p>每一个由设备上的触摸屏产生的事件都被包裹成MotionEvent中的一种，<br>MotionEvent提供了关于这个事件我们所需要的全部信息，这些信息包括事件所产生的动作以及关于本事件的一些额外的元信息，比如说触摸点的位置、事件发生时有多少根手指处于屏幕上、事件发生的时间等。</p><p>系统提供了一些常用的事件动作类型，光看其名字就能猜出其本身的含义。例如<code>ACTION_DOWN</code>，<code>ACTION_UP</code>，<br>这两个动作是第一根手指在屏幕上按下，然后释放手指所产生的；<code>ACTION_MOVE</code>产生于手指在屏幕上拖拽时；<code>ACTION_POINER_DOWN</code>和<code>ACTION_POINTER_UP</code>这两个动作会在第二根或更多手指跟屏幕交互时所产生，在处理多点触控时会用到；最后一个是<code>ACTION_CANCEL</code>，这个动作会在一些特殊的情形下用到，在接下来的讲解中会遇到。主要的用法是当事件起初被一个视图处理，之后又交给其他视图处理时,就会用到。另外需要强调的是，android只定义了一种手势，此手势的全部事件组成发生在<code>ACTION_DOWN</code>和<code>ACTION_UP</code>之间，当我们需要处理一个新的手势时，<br><code>ACTION_DOWN</code>就是这个新手势的起始，之后手势的状态会一直由不同的移动事件所维护着，直到<code>ACTION_UP</code>发生，这有点像重新洗牌，再开一局的意思，整个过程可能会反复多次。</p><h2 id="事件的传递流程"><a href="#事件的传递流程" class="headerlink" title="事件的传递流程"></a>事件的传递流程</h2><p>对于每一个由硬件和底层框架产生的事件，最先被发送到Activity中，应用的哪个Activity在前台的最顶部，哪个Activity就会接收触摸事件，优先于应用中的其他任何组件，该过程是经由框架调用Activity的<code>dispatchTouchEvent()</code>来完成的，因此我们可以重载这个方法来检查各种移动事件（但不建议在该方法里面做过多的事情）。从这个方法开始，这些事件会开启其旅程，由Activity开始往下传递给视图结构树，而在视图结构树中会由上到下传递，事件首先由窗口服务端发送到Activity里面，再由Activity发送给RootView，RootView是contentView的顶层View，因此事件会分发给我们自己布局中的根ViewGroup，然后依次发送给子视图们，如果这些子视图中也有ViewGroup，就递归地再往下分发，直到事件分发到视图树的最底部，之后事件会反过来由底向上传递。</p><p>这里的传递机制是：事件会从上往下再从下往上穿梭，直到某个View宣布其对这个事件<strong>感兴趣</strong>为止，一旦存在，那么关于某个手势的其他信息就会接踵而来。是否”感兴趣”的具体体现就是<code>onTouchEvent()</code>这个方法，每个View和ViewGroup都有这个函数，其返回一个布尔值，因此我们的自定义视图可以通过重写这个方法并返回true来宣布对到来的触摸事件感兴趣，具体来说就是需在<code>onTouchEvent()</code>中处理 <code>ACTION_DOWN</code> 时返回true，因为如果不宣布对 <code>ACTION_DOWN</code> 感兴趣，系统就会觉得我们对其他事件亦不感兴趣，就效率而言，系统认为他们这么做理所当然，一旦某个特定的View宣布了，那么这个View就是某个手势中其他事件的直接目的地。然后当Android框架就知道了有一个视图会对触摸事件感兴趣，那么它就会中断原本的对触摸事件的响应链。但是如果一个触摸事件成功的传递到了视图的底部，以及在此过程中,没有任何视图对其产生兴趣，此事件就会在视图树中一直往上返回，直到返回到Activity为止。</p><p>综上所述,整个视图树的传递流程是，通过View和ViewGroup自顶向下传递，根据是View还是ViewGroup调用其各自的<code>dispatch</code>方法，ViewGroup会把事件交由它的child，child再交给child’s child等等，接下来当事件往上传递时，View和ViewGroup就会调用<code>onTouchEvent()</code>了，简而言之，<code>dispatch</code>一层一层往下调用，<code>onTouchEvent</code>一层一层往上返回。所以我们以前可能这么做过：由于Activity中有一个<code>onTouchEvent()</code>的方法，既然事件经由Activity分发下去，那么Activity中的<code>onTouchEvent()</code>就是我们要监控触摸事件的传递流程的第一站，但是结果却是恰恰相反！如果在Activity的<code>onTouchEvent</code>中监测触摸事件，这个地方其实是触摸事件到达的终点，而且大多数情况下我们根本就监测不到，因为如果触摸事件被中间过程中的某个View消费了，那么事件终点就会停到那个View处了，也就是说那个View上面的<code>onTouchEvent</code>就不会被调用了，这点需要谨记。</p><p>另外，前面提到的<code>onTouchEvent()</code>需要重写View，所以我们可以用另外一种方式监测触摸事件或者是对事件做交互处理，这种方法不必我们去派生View或ViewGroup的子类，而是直接调用其<code>onTouchListener()</code>即可，<code>onTouchListener()</code>就跟<code>onTouchEvent()</code>没啥两样，在此方法中，照样可以返回true来消耗某些事件，当我们对待某些情形时，使用这个方法是个不错的选择。</p><h2 id="事件的分发：dispatchTouchEvent"><a href="#事件的分发：dispatchTouchEvent" class="headerlink" title="事件的分发：dispatchTouchEvent()"></a>事件的分发：dispatchTouchEvent()</h2><p>前面我们已经把触摸的流程地梳理完了，这节来看看视图是如何分发这些事件的。View在这个过程中的逻辑要比ViewGroup简单。View的<code>dispatchTouchEvent()</code>只需要干两件事儿，第一件是检查是否有<code>TouchListener</code>注册在这个View中，如果有，就会先对此监听器进行检查，看看其是否想要消费此次事件，如果触摸监听器不消费事件或者传进来的事件跟要监听的事件无关，接下来该View的<code>onTouchEvent()</code>就要被调用了，如果在<code>onTouchEvent()</code>中也没有返回true，那么事件就会返回到视图树上的上一层，在一般的View中，就只有这两个地方来处理事件。</p><p>ViewGroup的机制就有点复杂了，它需要对自己的child进行遍历和迭代，来确定哪些child有可能对此事件感兴趣，这个步骤是在ViewGroup的<code>dispatchTouchEvent()</code>中实现的，ViewGroup会根据触摸的位置来判断，有哪些child可以代表此位置，触摸位置处于child的边界内才说明触摸事件与此View相关，如果此child不只1个，比方说两个有重叠部分的View，ViewGroup就会逆序遍历这些child-View（逆序是指按照被加入到ViewGroup中的顺序的逆序），使得这些View有处理事件的机会，通过父View的dispatch，首先是第一个child-View处理事件，之后再轮到第二个child-View，前提是第一个child-View没有消耗掉事件。</p><h2 id="事件的拦截：onInterceptTouchEvent"><a href="#事件的拦截：onInterceptTouchEvent" class="headerlink" title="事件的拦截：onInterceptTouchEvent()"></a>事件的拦截：onInterceptTouchEvent()</h2><p>除了正常的事件分发，ViewGroup还提供了<code>onInterceptTouchEvent()</code>方法用以对触摸事件进行中断或者窃取。当由于手势的特殊需求，使得ViewGroup要停止将事件分发下去，即停止将事件分发给原本将要消耗此事件的child转而直接让自己来处理事件，就可以在不打乱事件分发的流程的前提下使用<code>onInterceptTouchEvent</code>来实现。举个例子，我们有一个ScrollView，这个ScrollView里面有一些子视图，这些子视图也同样需要交互，例如Button，这些Button肯定是要能被点击的，所以他们被注册点击listener。一旦我们的手指开始做一个滚动的动作，ScrollView就需要优先Button来响应事件，处理视图内容的滚动。</p><p>实际上ViewGroup本来就在监控各种触摸事件，尽管事件最终是要被分发到不同的child身上，不过一旦ViewGroup监测到了一个特定手势例如拖拽，就不能让child来响应了，于是就会触发这种中断把事件直接交给自己来处理，那么，作为开发者的我们，就可以好好利用这种机制。</p><h2 id="事件的屏蔽：requestDisallowTouchIntercept"><a href="#事件的屏蔽：requestDisallowTouchIntercept" class="headerlink" title="事件的屏蔽：requestDisallowTouchIntercept()"></a>事件的屏蔽：requestDisallowTouchIntercept()</h2><p>前面讲的大部分其实都是框架自己干的事情，这些都不用我们去实现，我们只需要把系统的流程搞清，顺着系统的意思重写就行，但是有时候也有可能出现parent和child都需要拦截事件的情况例如同向嵌套滚动，因此在ViewGroup提供了一个额外的标识，用来打断这个事件拦截的逻辑，对外的接口是一个又长又拗口的方法：<code>requestDisallowTouchIntercept()</code>。它是一个由父视图调用的方法，调用时只用传入一个布尔参数即可，如果传的是true，那么此时就剥夺了ViewGroup对当前手势的中断能力。</p><p>例如前面提到的嵌套滚动例子，具体需求就是：如果我们自定义的子视图出于某些原因，也需要处理一些拖拽事件时，且子视图外面包裹的是ScrollView，我们希望暂时是由子视图先处理拖拽，所以需要阻止ScrollView去处理拖拽。因此我们可以把这个标识先置为true一段时间，然后待子视图不再需要后再重置该标识。但需要注意的是，这个标识默认只对当前的手势有效，意味着每次手势开始，这个标识不会像某些全局变量一样，所以不要期待：我们对它说”不要屏蔽我的事件”，之后它就会永远帮我们屏蔽一样。</p><h2 id="事件处理的重写"><a href="#事件处理的重写" class="headerlink" title="事件处理的重写"></a>事件处理的重写</h2><p>当需要重写<code>onTouchEvent()</code>方法时， 我们可能只需想处理一到两个特定的事件，也可能只是想监听触摸事件的流向，抑或是想要简单地计算一下手指移动的距离等，并不是要处理所有的事件，这样的话最好是调用一下<code>super</code>的<code>onTouchEvent()</code>，而不是把所有事件都交给自己。因为View在<code>onTouchEvent()</code>方法中做了很多事情来维护自身的状态， 例如有不可按下的标识、不可更改可绘制对象等，如果我们不调用super的方法就失去了这些特性，有时候产生很多相关的疑惑都与此有关。因此通常当我们处理事件时，一旦遇到不想处理的事件时， 与其明确的返回一个true或者false， 不如返回一个<code>super.onTouchEvent()</code>。</p><p>另外，对于<code>ACTION_CANCEL</code>，大多数情况下是跟弹起是放在一起处理的。</p><h2 id="事件的一些检测常量：ViewConfiguration"><a href="#事件的一些检测常量：ViewConfiguration" class="headerlink" title="事件的一些检测常量：ViewConfiguration"></a>事件的一些检测常量：ViewConfiguration</h2><p>ViewConfiguration类包含许多常量，在自定义手势处理时非常有用，其中大多数常量是跟触摸事件有关的（但也不全是，有些也会跟画图或其他方面相关），这些常量单位都是dp，与分辨率无关，所以我们就无需自己去找一些随机的像素点数来充当自己的slop检查。本节讲解几个实际使用的最重要的常量。</p><h3 id="touchSlop"><a href="#touchSlop" class="headerlink" title="touchSlop"></a>touchSlop</h3><p>首先是touchSlop，通过<code>getScaledTouchSlop()</code>可以得到，它是一个决定触摸事件是否能从轻触转换为拖拽的阈值。通常，当我们的手指停留在屏幕上时，即使尽可能的让手指不乱动， 我们也会发现，不管手指有多么的静止， 还是会看到有相当多的<code>ACTION_MOVE</code>传递到View中，因为我们的手指其实是个很容易颤动的东西，在将其转换为在屏幕上表示位置的一个像素点时，即使仅仅一点点的振动，系统为了探知手指的位置，也会产生大量的<code>ACTION_MOVE</code>事件。系统很多视图例如ScrollView都使用了touchSlop来与手指移动的距离相比来决定什么时候应该开始滚动或者类似的事情。 </p><h3 id="Fling"><a href="#Fling" class="headerlink" title="Fling"></a>Fling</h3><p>系统还给我们提供了用于检查Fling的常量——最小Fling速度常量和最大Fling速度常量。Fling具体是指当手指在屏幕上飞快的一划，手指离开屏幕时，屏幕的滚动还没有停止，即一种自动化的滚动。例如我们”Fling”了一个可滚动的列表时，由于我们在手指离开屏幕之前并没有让其停下，框架就会把此手势认为是Fling，因此我们需要根据手势达到的速度来让滚动滚得自然一些。</p><h3 id="scaledPagingTouchSlop"><a href="#scaledPagingTouchSlop" class="headerlink" title="scaledPagingTouchSlop"></a>scaledPagingTouchSlop</h3><p>scaledPagingTouchSlop在ViewPager中有被用到，该常量跟前面讲到的touchSlop是有区别的，当前这个touchSlop指的是横向滑动翻页的touchSlop，而不是我们常见的用于滚动的touchSlop，但也不是所有横向的slop都用这个常量，例如横向的ScrollView用的还是第一种slop来做检查，因此此处的slop仅仅用于ViewPager之类的视图中，起初设计这两个不同的常量的主要原因是，当把ScrollView放到ViewPager中时，怎样才能使两者都工作的好， 两种不同的slop检查就很容易判断出到底哪个视图的手势需求优先。</p><h2 id="多点触摸事件"><a href="#多点触摸事件" class="headerlink" title="多点触摸事件"></a>多点触摸事件</h2><p>index跟id的不同之处在于，触摸点的id是固定的,但是其索引就不是的， 举个例子，例如当前有3个手指放在了屏幕上，那么这3个触摸点的id依次是0,1,2， 同样其index也是0,1,2， 但是一旦我们松开第二根放下的手指， 那么屏幕上剩下的触摸点的id还是0跟2， 但是其相对应的index就会变成0跟1。index更多的是在指这儿还有多少POINTER，而id就是个稳定的值，用于对按下的触摸点进行跟踪记录，具体可以参见前面一篇关于多手指处理的笔记：<a href="http://linjiang.tech/2016/09/26/%E5%A4%9A%E6%89%8B%E6%8C%87Touch%E5%8F%98%E5%8C%96%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99%E5%9F%BA%E7%A1%80/">多手指Touch变化处理原则基础</a>。</p><h2 id="事件的混合"><a href="#事件的混合" class="headerlink" title="事件的混合"></a>事件的混合</h2><p>默认情况下，当我们从View中获取并处理触摸事件时，实际上并没有监测到每一个单独的事件，当我们的手指在屏幕上划来划去时，虽然移动事件的确分发给了视图，但是这些事件是成批处理过之后的事件，并不是说这些触摸点信息就丢失了，这点在应用中体现在每次有事件到来时，在事件回调方法中得到的事件是关于事件成批处理中的最近发生的事件，当我们请求获取此次触摸事件中X,Y的位置或者其他请求时， 最终得到的结果都是从成批事件处理后的最近发生的事件。</p><p>但是如果某些时候我们需要监测系统生成的每一个事件，例如可能我们要用这些来构建一个路径或者些其他，反正就是想要得到每一个单独的事件，通过MotionEvent对象可以得到我们想要的一切， 该对象的方法除了有返回x,y、发生时间、每一个单独事件的所有元数据以外，还可以得到此次成批处理中一共有多少事件， 这样我们就可以知道所有需要的事件了。</p><h2 id="触摸代理"><a href="#触摸代理" class="headerlink" title="触摸代理"></a>触摸代理</h2><p>我们以一个例子切入：有一个ListView，由于设计需求导致其item中有一个图标太小以至于很难触摸的到，但是我们又希望用户可以点击到这个图标，在多数情况下，我们可能会规避走到这一步，比方说那把视图设置得大一点，但如果必须这样，那可以想到的解决办法就是在ListView的Item中的父视图指定一片稍大的区域当做这个图标的代理，然后把此区域中的所有触摸事件都传给那个图标。其实系统早已针对这种情况给出了解决方案，我们只需调用父视图的<code>setTouchDelegate</code>方法，传入一个用供代理事件的矩形区域和需要被代理的child来初始化的触摸代理对象就可以了。在触摸代理内部它会对每一个进入到父视图的事件进行检查， 判断此事件的位置是否落在了定义的矩形区域内， 是的话， 那就把事件的坐标稍作处理，用触摸代理传送到那个按钮中， 至于此处按钮会有怎样的反应，那就要看按钮自身的触摸事件处理过程了。</p><p>当然，除了使用<code>TouchDelegate</code>，还有另外一种解决方案，就是利用<code>event.offsetLocation</code>对事件坐标进行“偏移”，然后调用需要被触摸的视图的dispatch将事件分发给它，但是这涉及到派生View或ViewGroup。两种方案在实际开发中需要好好斟酌。</p><h2 id="事件自定义处理的重要细节"><a href="#事件自定义处理的重要细节" class="headerlink" title="事件自定义处理的重要细节"></a>事件自定义处理的重要细节</h2><p>为了方便展开，约定从<strong>最外层 <code>ViewGroup(0)</code></strong> 到<strong>最内层 <code>View(n)</code></strong> 所形成的事件传递链为：</p><blockquote><p><code>ViewGroup(0) -&gt;...-&gt; ViewGroup(n-1) -&gt; View(n)</code></p></blockquote><h3 id="事件的传递方向"><a href="#事件的传递方向" class="headerlink" title="事件的传递方向"></a>事件的传递方向</h3><blockquote><p>在不拦截的情况下，若存在传递链的某节点 t 可以消费事件，[0,  n]，而[t+1，n]范围的所有节点都不消费事件，那么手势的第一个事件<code>ACTION_DOWN</code>的传递流程为<code>0 -&gt; ... -&gt; n</code>，再<code>n -&gt; ... -&gt; t</code>；除此之外的剩余事件则只会从<code>0 -&gt; ... -&gt; t -&gt; t</code>。  </p></blockquote><p>其中<code>0 -&gt; ... -&gt; n</code>的事件出现在<code>dispatchTouchEvent</code>和<code>onInterceptTouchEvent</code>两个方法，而<code>n -&gt; ... -&gt; t</code>的事件出现在<code>onTouch/onTouchEvent</code>方法。</p><p>原因：依据ViewGroup的dispatchTouchEvent源码得到以下伪代码，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!intercepted) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            ...</span><br><span class="line">            for(children) &#123;</span><br><span class="line">                ...// 注意这一句传入的第三个参数为child，而下方同方法对应的参数为null</span><br><span class="line">                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    // addTouchTarget方法会对mFirstTouchTarget赋值</span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (mFirstTouchTarget == null) &#123;</span><br><span class="line">        // 这里传递null使得ViewGroup的流程走向super.dispatchTouchEvent</span><br><span class="line">        // 从而调用到ViewGroup的onTouch相关方法</span><br><span class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 具体流程转接下来的结论2的代码片段</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在未拦截的前提下，对于<code>ACTION_DOWN</code>事件，ViewGroup会调用<code>dispatchTransformedTouchEvent</code>先将其分发给对应的child，<code>dispatchTransformedTouchEvent</code>内部会触发child分发事件给child的child，这样依次递归直到最内层View。这样传递链的第一部分<code>0 -&gt; ... -&gt; n</code>就形成了.</p><p>由于从t+1到n的所有节点都不消费事件，所以child依次对其上层返回false，即<code>dispatchTransformedTouchEvent</code>返回false，这就导致了上述代码中的<code>addTouchTarget</code>方法无法得到调用，关键字段<code>mFirstTouchTarget</code>就始终为null，ViewGroup就没有对应的供分发手势的target-child，因此ViewGroup通过<code>dispatchTransformedTouchEvent</code>调用自己的onTouch相关方法，由于节点t可以消费事件，所以onTouch相关方法返回了true。这样传递链的第二部分<code>n -&gt; ... -&gt; t</code>也形成了。</p><p>同时，接下来的事件非intercepted也非<code>ACTION_DOWN</code>，流程直接走向<code>if (mFirstTouchTarget == null) &#123;...&#125;</code>，也即是传递链的第三部分<code>0 -&gt; ... -&gt; t -&gt; t</code>形成了。</p><h3 id="onTouch相关方法的返回值的具体意义"><a href="#onTouch相关方法的返回值的具体意义" class="headerlink" title="onTouch相关方法的返回值的具体意义"></a>onTouch相关方法的返回值的具体意义</h3><blockquote><p>在整个传递链没有节点拦截的前提下，如果某节点t，[0, n]需要消费事件，那么onTouch相关方法只需要在ACTION_DOWN事件时返回true就可以持续收到整个手势的所有剩余事件，不论当这些剩余事件到来时返回true还是false。但是当在ACTION_DOWN返回true，剩余事件返回false时，虽然节点t-1到节点0所有的节点的onTouch相关方法依然不会被回调，但是Activity中的onTouchEvent方法却是可以收到这些事件的。</p></blockquote><p><strong>原因</strong>：++从根本来讲，手势 <strong>剩余</strong> 事件在视图层级能否传递的唯一依据是当前视图是否拥有供自己分发事件的target-child++，否则便会将事件分发给自己的onTouch相关方法。注意前面的“剩余”两个字，意思就是第一个事件ACTION_DOWN不受target-child影响，并始终会从上传递至下递归到最根部的视图，然后从最根部的视图开始向上执行自己的使命：寻找从传递链尾部到首部第一个可以消费事件的节点，一旦发现（即onTouch相关方法返回true，将该节点约定为t），那么节点t-1的target-child就不为空了，并且节点t-1向t-2返回了true，这样节点t-2的target-child也不为空，以此类推，直到传递链的首部，节点0到节点t-1所有节点的target-child都指向了其下一个节点。</p><p>也就是说，target-child生成的依据是手势的第一个事件ACTION_DOWN。对于其余事件，与ACTION_DOWN的流程不一致。所以对于接下来的剩余事件传递到传递链底部并向上返回时，target-child并不受返回值的影响。</p><p>而对于Activity，其分发手势事件的方法<code>dispatchTouchEvent</code>与ViewGroup的完全不一致，其逻辑表现为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (decor.dispatchTouchEvent(ev)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">return onTouchEvent(ev);</span><br></pre></td></tr></table></figure><br>上面是一段伪代码，其中的decor指代的是整个视图层的顶层容器。所以只要事件回传到传递链的首部是false时，Activity就会调用它的<code>onTouchEvent</code>方法。也就是说，Activity的<code>onTouchEvent</code>被回调与视图层是否有事件消费没关系，而仅于视图层返回到Activity的值有关系。这也是为什么消费手势的节点返回false，Activity的<code>onTouchEvent</code>被回调的原因。</p><h3 id="从onTouch相关方法看，拦截事件的时机点的不同对流向自己的事件的影响"><a href="#从onTouch相关方法看，拦截事件的时机点的不同对流向自己的事件的影响" class="headerlink" title="从onTouch相关方法看，拦截事件的时机点的不同对流向自己的事件的影响"></a>从onTouch相关方法看，拦截事件的时机点的不同对流向自己的事件的影响</h3><blockquote><p>当传递链的某节点 t 需要拦截事件，[0, n]，  </p><ul><li>若该事件是手势的第一个事件即<code>ACTION_DOWN</code>，也就是说事件还未传递到范围在(t, n]的节点，那么这个节点 t 的onTouch相关方法收到的是这个手势的完整事件，包括这个<code>ACTION_DOWN</code>；  </li><li>若该事件不是第一个事件例如是<code>ACTION_MOVE</code>，也就是说至少事件<code>ACTION_DOWN</code>已经去过(t, n]的节点了，那么当前事件会被转化为<code>ACTION_CANCEL</code>分发child，所以节点 t 的onTouch相关方法收到的事件是除了当前这个事件，即将到来的所有剩余手势事件。</li></ul></blockquote><p><strong>原因</strong>：首先要明白<code>ACTION_CANCEL</code>生成的原因。对于一个正在接收事件的View，在正常情况下，它会持续接收下去并最终收到<code>ACTION_UP</code>事件，以此来重置自己一些与手势相关的字段或UI状态，但是一旦在此期间其上一个节点拦截的后续本应传递给自己的事件，当前节点便无法获知自己手势的结束导致状态混乱，所以系统强制那个拦截事件的节点需要告知其下一个节点它的事件被我拦截了，以让下个节点根据这个状态来重置或处理相关操作，拦截事件的节点告知其下一个节点的这个状态便是<code>ACTION_CANCEL</code>。</p><p>因此，如果第一个事件本身才刚传递到节点t，节点t决定拦截就不需要告知节点t+1，这样第一个事件就不需要转化为<code>ACTION_CANCEL</code>，也就是说节点t的onTouch相关方法收到的是这个手势的完整事件。而如果节点t决定拦截时当前事件不是第一个事件，那么它就需要告知节点t+1自己需要拦截事件了，请它做好相关善后工作，因此当前事件被转化为<code>ACTION_CANCEL</code>，节点 t 的onTouch相关方法收到的事件是除了当前这个事件，即将到来的所有剩余手势事件。</p><h3 id="从拦截方法看，拦截前后流向自己的事件的变化"><a href="#从拦截方法看，拦截前后流向自己的事件的变化" class="headerlink" title="从拦截方法看，拦截前后流向自己的事件的变化"></a>从拦截方法看，拦截前后流向自己的事件的变化</h3><blockquote><p>一旦传递链的某节点 t，[0, n]拦截了事件或者仅节点 t 可以响应事件，那么接下来的该手势的其余事件传递到节点 t 时将不会再传递给<code>onInterceptTouchEvent</code>转而直接传递给其onTouch相关方法。</p></blockquote><p><strong>原因</strong>：在ViewGroup的事件分发方法中，事件能够流向<code>onInterceptTouchEvent</code>的前提条件是满足当前事件是手势的第一个事件或者存在供ViewGroup分发手势的target-child两个条件的任中之一。而其中的target-child即源码中的字段<code>mFirstTouchTarget</code>是当ViewGroup的当前事件分发给child后、child通过返回值告知ViewGroup表示child自己或child自己的child（往下递归）可以消费事件时，ViewGroup为其赋值为这个child的。因此，</p><ul><li><p>如果第一个手势事件一开始被当前节点t拦截，当前事件根本没有机会传递下去，target-child得不到赋值机会，那么接下来的该手势的其余事件顺理成章地不会再过问节点t的<code>onInterceptTouchEvent</code>了；</p></li><li><p>如果就算第一个手势事件未被节点t拦截，只要节点t+1到节点n中的所有节点都不消费事件，那么节点t的target-child依然为null，接下来的该手势的其余事件照样不会再过问节点t的<code>onInterceptTouchEvent</code>了；</p></li><li><p>再退一步讲，在节点t决定拦截时，当前事件之前的多个事件已经传递了下去且节点t之后存在消费事件的节点，也就是说节点t的target-child不为null，但是决定了拦截的这一刻，事件分发方法<code>dispatchTouchEvent</code>源码中除了将当前这个事件转化为ACTION_CANCEL并传递给target-child外，同时还会清空节点t的节点ttarget-child。这样接下来的该手势的其余事件仍然不会再过问节点t的<code>onInterceptTouchEvent</code>了；</p></li></ul><h3 id="禁止parent拦截事件的方法的正确使用方式"><a href="#禁止parent拦截事件的方法的正确使用方式" class="headerlink" title="禁止parent拦截事件的方法的正确使用方式"></a>禁止parent拦截事件的方法的正确使用方式</h3><blockquote><p>节点t可以通过调用节点t-1的<code>requestDisallowInterceptTouchEvent(true)</code>方法来禁止t-1拦截将要传递给t的事件，但是该方案对于手势起始事件ACTION_DOWN是无效的。也就是说，如果节点t-1在ACTION_DOWN时就拦截了事件，节点t是无法通过该方案禁止的，因为根本就没机会收到事件。进而推导出，<code>requestDisallowInterceptTouchEvent(true)</code>生效的前提是节点t本身就收到过事件，只是为了确保整个手势后续的事件都能收到，节点t可以通过该方案达到目的。</p></blockquote><p><strong>原因</strong>：首先，ViewGroup的拦截事件方法<code>onInterceptTouchEvent</code>是由<code>requestDisallowInterceptTouchEvent(true)</code>对应的状态<code>FLAG_DISALLOW_INTERCEPT</code>决定的，默认条件下，这个状态是关闭的，所以ViewGroup可以对即将传递给child的所有事件进行拦截。</p><p>但是在ViewGroup的分发事件方法<code>dispatchTouchEvent</code>中，在满足分发前提下，第一步就是在手势初始事件<code>ACTION_DOWN</code>时重置所有与Touch相关的状态，其中就包含了调用<code>requestDisallowInterceptTouchEvent(true)</code>所开启的状态，这样就使得<code>ACTION_DOWN</code>包括接下来的手势事件总有机会被<code>onInterceptTouchEvent</code>拦截，即<code>requestDisallowInterceptTouchEvent(true)</code>方法在ACTION_DOWN或ACTION_DOWN之前调用是无效的。</p>]]></content>
    
    <summary type="html">
    
      文章如同标题所述主要分为两部分，前半部分主要是一个流程和Touch相关知识点的概述，期间罗列了一些常见例子帮助分析，差不多都是点到为止，后半部分则是在实际开发中，对手势处理的一些很容易被忽视的细节点，当然并不是说不了解这些细节点就无法进行自定义处理逻辑，但是掌握有助于理清处理手势的一些步骤，因此从整体而言，本篇也算是一篇不错的初学者入门篇。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="View" scheme="https://linjiang.tech/tags/View/"/>
    
      <category term="手势事件" scheme="https://linjiang.tech/tags/%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【Fragment】对Fragment、FragmentManager和BackStackRecord的字段全解析</title>
    <link href="https://linjiang.tech/2017/02/18/Fragment-Study%20and%20Analysis%20of%20Fragment%20fields/"/>
    <id>https://linjiang.tech/2017/02/18/Fragment-Study%20and%20Analysis%20of%20Fragment%20fields/</id>
    <published>2017-02-18T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>Fragment、FragmentManager以及BackStackRecord是Fragment组件包中最主要的三个类，几乎包含了Fragment体系中所有的功能和知识点。从主流使用流程出发的源码分析对解决问题快速有效，但是一段时间后其中细节点可能就会慢慢的遗忘，只剩下一个感性的认知。本篇从字段入手，对这三个类的所有字段从含义、作用、使用方式以及所涉及的额外知识点几个方面的进行了详细的分析记录，有利于对源码分析和回顾，甚至完全可以当作一本字段参考字典。</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在决定尝试对Fragment系列进行源码分析后，尽管很努力地想按功能模块将Fragment的各个特性独立成篇，但仍有很多知识点存在强烈的关联性，不得不在每篇文章中重复地提及，既然如此，干脆就将这些知识点细分并分别分析记录，于是逐渐地转变为对整个类的所有字段进行分析。</p><p>经过大半月的业余时间的学习和分析，从中发现了许多不曾了解的知识点、纠正了许多错误的想法、增强了对已有结论的认识，一段有趣又漫长的工作。</p><p>注：</p><blockquote><ul><li>本文源码基于support-fragment-25.0.0版本。</li><li>篇幅较长建议在PC端打开，点击右下角菜单按钮可展开目录，便于索引。</li><li>如有遗漏或错误，欢迎指正和建议。</li></ul></blockquote><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h3 id="mAnimatingAway-amp-amp-mStateAfterAnimating"><a href="#mAnimatingAway-amp-amp-mStateAfterAnimating" class="headerlink" title="mAnimatingAway &amp;&amp; mStateAfterAnimating"></a>mAnimatingAway &amp;&amp; mStateAfterAnimating</h3><p><code>mAnimatingAway</code>：表示当前正在执行动画的view，一般这个view持有的就是Fragment的mView。若mAnimatingAway不为null就表示当前<code>fragment&#39;s view hierarchy</code>正在执行动画中，一旦动画结束，mAnimatingAway就会被置null。</p><p><code>mStateAfterAnimating</code>：若mAnimatingAway!=null，即当前fragment’s view hierarchy正在执行动画中，那么mStateAfterAnimating就表示在动画结束后Fragment应该move to的<strong>状态state</strong>。</p><p>源码注释中没提到的是，它们都是针对退出Fragment时的动画而言，其实从命名也可以猜出一二。</p><p>首先，<code>mAnimatingAway</code>只在一处被赋值，它就是5个参数的moveToState中，调用<code>f.performDestroyView()</code>的case：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # moveToState(...)</span><br><span class="line">case Fragment.ACTIVITY_CREATED:</span><br><span class="line">    ...</span><br><span class="line">    // performDestroyView将Fragment的当前状态mState置为了 CREATED;</span><br><span class="line">    f.performDestroyView();</span><br><span class="line">    if (f.mView != null &amp;&amp; f.mContainer != null) &#123;</span><br><span class="line">        Animation anim = null;</span><br><span class="line">        if (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed) &#123;</span><br><span class="line">            // loadAnimation根据fragment.mNextAnim，transit和transitionStyle三个条件返回一个anim</span><br><span class="line">            anim = loadAnimation(f, transit, false, transitionStyle);</span><br><span class="line">        &#125;</span><br><span class="line">        if (anim != null) &#123;</span><br><span class="line">            final Fragment fragment = f;</span><br><span class="line">            // anim不为null表示指定了动画，所以mAnimatingAway被赋值为了Fragment的布局文件</span><br><span class="line">            f.mAnimatingAway = f.mView;</span><br><span class="line">            // 并将Fragment需要move to的新状态保存在mStateAfterAnimating中</span><br><span class="line">            f.mStateAfterAnimating = newState;</span><br><span class="line">            final View viewToAnimate = f.mView;</span><br><span class="line">            // 对动画设置监听</span><br><span class="line">            anim.setAnimationListener(new AnimateOnHWLayerIfNeededListener(viewToAnimate, anim) &#123;</span><br><span class="line">                @Override public void onAnimationEnd(Animation animation) &#123;</span><br><span class="line">                    super.onAnimationEnd(animation);</span><br><span class="line">                    // 当动画结束，才开始继续进行下一步的状态更新操作，并清空mAnimatingAway</span><br><span class="line">                    // 移动的新状态就是动画开始前临时保存在mStateAfterAnimating的状态</span><br><span class="line">                    if (fragment.mAnimatingAway != null) &#123;</span><br><span class="line">                        fragment.mAnimatingAway = null;</span><br><span class="line">                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 然后对整个布局文件开始动画</span><br><span class="line">            f.mView.startAnimation(anim);</span><br><span class="line">        &#125;</span><br><span class="line">        // 不论是否有动画，Fragment所属视图在performDestroyView()后就立即被移除了</span><br><span class="line">        f.mContainer.removeView(f.mView);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>Fragment的退出动画是在onDestroyView之后开始执行的，而视图是立刻被移除的。并且由于Fragment的最新状态是动画结束时才开始切换的，所以只要动画没结束，Fragment的当前状态就只能moveto到CREATED，不会切换为最新状态。<br>由于case之间没有break，为了防止动画还未结束，Fragment就执行完了onDestroy、onDettach（若需要），在调用<code>f.performDestroy()</code>的case中进行了判断：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # moveToState(...)</span><br><span class="line">case Fragment.CREATED:</span><br><span class="line">    if (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">        if (mDestroyed) &#123;</span><br><span class="line">            // 如果动画期间宿主Activity需要destroy了，那么就不应该还要等到Fragment的动画完成的才结束</span><br><span class="line">            // 而是直接cancel掉（不会回调onAnimationEnd），并清除mAnimatingAway标识以正常状态流程切换。</span><br><span class="line">            if (f.mAnimatingAway != null) &#123;</span><br><span class="line">                View v = f.mAnimatingAway;</span><br><span class="line">                f.mAnimatingAway = null;</span><br><span class="line">                v.clearAnimation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 表示正在执行退出动画，只需等待，</span><br><span class="line">        // 同时更新f.mStateAfterAnimating为最新状态以让动画结束时Fragment能同步至最新状态</span><br><span class="line">        if (f.mAnimatingAway != null) &#123;</span><br><span class="line">            f.mStateAfterAnimating = newState;</span><br><span class="line">            newState = Fragment.CREATED;</span><br><span class="line">        &#125; else &#123;// 否则根据正常流程条件依次执行destroy、dettach</span><br><span class="line">            if (!f.mRetaining) &#123;</span><br><span class="line">                f.performDestroy();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                f.mState = Fragment.INITIALIZING;</span><br><span class="line">            &#125;</span><br><span class="line">            f.performDetach();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>如果在destroyView后正在执行退出动画期间，Fragment又有了新的状态切换（“活”过来了），例如重新被attach了或者重新createView了，那么在切换为最新状态前，动画会被直接忽视掉并直接先把状态切换到动画结束时应该切换到的状态，以走完上次未走完的流程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (f.mState &lt; newState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (f.mAnimatingAway != null) &#123;</span><br><span class="line">            f.mAnimatingAway = null;</span><br><span class="line">            moveToState(f, f.mStateAfterAnimating, 0, 0, true);</span><br><span class="line">        &#125;</span><br><span class="line">        switch (f.mState) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mIndex"><a href="#mIndex" class="headerlink" title="mIndex"></a>mIndex</h3><p>mIndex是Fragment的唯一凭证，通过mIndex可以找到对应的Fragment，只要与FragmentManager存在关联便会存在；否则在Fragment执行<code>onDestroy/onDetach</code>后，FragmentManager会调用<code>makeInactive</code>方法将mIndex从Fragment释放并回收到<code>mAvailIndices</code>集合。</p><p>结合FragmentManager中的<code>mActive和mAvailIndices</code>字段一起看，值是当前Fragment在mActive数组的索引。</p><p>调用关系链：<br><code>mIndex &lt;- Fragment#setIndex &lt;- FragmentManager#makeActive &lt;- FragmentManager#addFragment / BackStackRecord#setLastIn</code></p><p>被add的Fragment在FragmentManager调用addFragment方法时，会为Fragment分配唯一索引ID，由makeActive执行具体执行过程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void makeActive(Fragment f) &#123;</span><br><span class="line">    // 重新从mActive集合中add到宿主上的Fragment或者经历状态保持与恢复机制的Fragment已经存在ID，无需再分配</span><br><span class="line">    if (f.mIndex &gt;= 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果没有空余的ID，则取mActive集合的最后元素的ID再加1，以保持ID的连续性</span><br><span class="line">    if (mAvailIndices == null || mAvailIndices.size() &lt;= 0) &#123;</span><br><span class="line">        if (mActive == null) &#123;</span><br><span class="line">            mActive = new ArrayList&lt;Fragment&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        f.setIndex(mActive.size(), mParent);</span><br><span class="line">        mActive.add(f);</span><br><span class="line">    &#125; else &#123;// 否则从可用ID集合中取出最后一个作为该Fragment的ID，并添加到mActive集合。</span><br><span class="line">        f.setIndex(mAvailIndices.remove(mAvailIndices.size()-1), mParent);</span><br><span class="line">        mActive.set(f.mIndex, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mWho"><a href="#mWho" class="headerlink" title="mWho"></a>mWho</h3><p>内部字段，可标识Fragment的唯一性；与mIndex的赋值时期相同。<br>当在Fragment中启动Activity/IntentSender/请求权限时，用于确定事件的来源Fragment，以便在宿主Activity的结果回调dispatchActivityResult时根据该字段查找相应的Fragment进行结果转发。查找规则如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Activity --&gt; mFragmentManager: for --&gt; Fragment#findFragmentByWho</span><br></pre></td></tr></table></figure><br>生成规则如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final void setIndex(int index, Fragment parent) &#123;</span><br><span class="line">    mIndex = index;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">                mWho = parent.mWho + &quot;:&quot; + mIndex;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mWho = &quot;android:fragment:&quot; + mIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其作用范围限制于FragmentManager内，即Activity不会把结果分发其它Activity内的Fragment。</p><h3 id="mArguments"><a href="#mArguments" class="headerlink" title="mArguments"></a>mArguments</h3><p>可以简单的将其作为Fragment的构造参数来理解。但是与构造参数不同的是，mArguments可以在状态保存恢复机制中得到持久化，意味着Fragment恢复时，该参数依然有效：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 在saveAllState时保存了mArguments</span><br><span class="line">public FragmentState(Fragment frag) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mArguments = frag.mArguments;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// Fragment</span><br><span class="line">public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Fragment f = (Fragment)clazz.newInstance();</span><br><span class="line">    if (args != null) &#123;</span><br><span class="line">        args.setClassLoader(f.getClass().getClassLoader());</span><br><span class="line">        // 在恢复Fragment时，构造完Fragment后第一件事就是应用mArguments</span><br><span class="line">        f.mArguments = args;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以通过<code>setArguments(Bundle)</code>为Fragment传递参数，但是有一点需要注意的是，该方法调用时必须保证当前Fragment还未Attach到Activity，也即Fragment还未关联至FragmentManager，Fragment的mIndex仍为-1。</p><h3 id="mTarget-amp-amp-mTargetIndex-amp-amp-mTargetRequestCode"><a href="#mTarget-amp-amp-mTargetIndex-amp-amp-mTargetRequestCode" class="headerlink" title="mTarget &amp;&amp; mTargetIndex &amp;&amp; mTargetRequestCode"></a>mTarget &amp;&amp; mTargetIndex &amp;&amp; mTargetRequestCode</h3><p>mTarget是一个Fragment对象，mTargetIndex是mTarget的index。</p><p>与Fragment之间的数据传递有关。如果Fragment A想启动Fragment B完成一些操作，并希望B在结束前返回一个result给A，这有点像Activity之间的forResult启动方式，那么就可以通过对B设置<code>setTargetFragment(A, requestCode)</code>来实现。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Caller extends Fragment &#123;</span><br><span class="line">    ...</span><br><span class="line">    Fragment called = Called.newInstance();</span><br><span class="line">    called.setTargetFragment(this, 99);</span><br><span class="line">    called.show(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public class Called extends DialogFragment &#123;</span><br><span class="line">    ...</span><br><span class="line">    getTargetFragment().onActivityResult(getTargetRequestCode(), RESULT_OK, intent);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然官方对于Fragment之间的communication推荐通过以宿主Activity为桥梁的方式来完成，但是mTarget更加适合与Activity无关、任务型启动等情况。</p><p>状态保存与恢复机制中，当前Fragment会持久化mTargetd的Index和RequestCode来记录自己的target。</p><h3 id="mAdded"><a href="#mAdded" class="headerlink" title="mAdded"></a>mAdded</h3><p>指示当前Fragment是否已被add至FragmentManager，即存在于FragmentManager中的mAdded数组中；</p><p>初始状态下为false，当状态恢复时也会先被置为初始状态；</p><p>当add/remove时被置为true/false，当attach/dettach时若发现未add/已被add则置为true/false，同时mAdded的变化会同步到FragmentManager中的mAdded数组上。</p><h3 id="mRemoving"><a href="#mRemoving" class="headerlink" title="mRemoving"></a>mRemoving</h3><p>指示当前Fragment正在从Activity中被removing；仅当执行remove时，该状态会被置为true，在remove完成，状态改变后，就会被重置为初始状态false。</p><h3 id="mFromLayout"><a href="#mFromLayout" class="headerlink" title="mFromLayout"></a>mFromLayout</h3><p>指示当前Fragment是通过静态加载的方式实例化的。主要用来区别静态加载和动态创建两种实例化Fragment的方式。</p><h3 id="mInLayout"><a href="#mInLayout" class="headerlink" title="mInLayout"></a>mInLayout</h3><p>拦截器作用。</p><p>当静态加载一个Fragment时，其mInLayout会被置为true。同时在状态保存恢复机制中，该字段没有被持久化，默认的false。所以如果Fragment是之前静态加载的，即mFromLayout为true，那么恢复状态后继续moveToState时（下面给出解释），该过程就会因为mInLayout为false而被阻止直到setContentView的调用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(5 params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (f.mState &lt; newState) &#123;</span><br><span class="line">    // For fragments that are created from a layout, when restoring from</span><br><span class="line">    // state we don&#x27;t want to allow them to be created until they are</span><br><span class="line">    // being reloaded from the layout.</span><br><span class="line">        if (f.mFromLayout &amp;&amp; !f.mInLayout) &#123;</span><br><span class="line">            return;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="为什么需要阻止？"><a href="#为什么需要阻止？" class="headerlink" title="为什么需要阻止？"></a>为什么需要阻止？</h4><p>首先我们需要知道的是，在Activity#onCreate方法的<code>super.onCreate</code>中与Fragment相关的操作主要有两步，分别是恢复Fragment、分发onCreate事件对Fragment进行moveState：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFragments.restoreAllState(...);</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第一步中不管是静态加载还是动态创建的Fragment都会恢复；而第二步中最后move State调用的方法<code>moveToState(5参)</code>在关于Fragment生命周期方法的<strong>回调时机</strong>方面，静态加载和动态创建两种方式表现是不同的：<br>如果是静态加载的Fragment，其<code>onCreateView、onViewCreated</code>两个方法是在<code>INITIAL move to CREATED</code>时发生的，而动态创建的Fragment相应的方法是在<code>CREATED move to other(&gt;created)</code>时发生的。</p><p>也就是说，在分发onCreatd事件进行状态转移至<code>CREATED</code>时，会导致静态加载的Fragment执行与视图加载相关的方法onCreateView、onViewCreated，而动态创建的Fragment不会。而关键是此时宿主Activity还未执行setContentView也就是视图还并不存在，如果在这时候让其子Fragment拥有了视图，并执行与视图相关的操作，导致的异常情况第一是视图可能的修改过程不可见，第二是可能出现与视图相关的Crash。所以就需要在宿主Activity加载视图前，阻止子Fragment进行自身的视图加载。同时，这样的处理也符合静态加载由宿主布局加载触发的规则。</p><h3 id="mRestored"><a href="#mRestored" class="headerlink" title="mRestored"></a>mRestored</h3><p>指示当前Fragment是从之前保存的状态中恢复过来的；在FragmentState#instantiate中被显式地置为了true；</p><p>当Fragment通过动态加载方式实例化时，在回调Fragment#onCreateView生命周期前会先查找Fragment所要依附的containerView，即onCreateView的第二个参数，此时就会根据mRestored来判断是否是全新的加载流程（即不是从保存的状态恢复过来的），来检查其是否为null并抛出异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">if (container == null &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">    ...</span><br><span class="line">    throwException(new IllegalArgumentException(&quot;No view found for id 0x&quot; ... );</span><br><span class="line">&#125;</span><br><span class="line">f.mContainer = container;</span><br><span class="line">f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="mBackStackNesting"><a href="#mBackStackNesting" class="headerlink" title="mBackStackNesting"></a>mBackStackNesting</h3><p>“回退栈”中包含有该Fragment的事务总数。也就是说，包含了对该Fragment的操作的事务如果全部未保存(<code>addToBackStack</code>)或都已被出栈，该参数就是0。</p><ul><li>可以通过此参数来判断Fragment是否被关联到了当前栈中：<code>Fragment#isInBackStack()</code>。该判定作用于remove操作：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void removeFragment(...) &#123;</span><br><span class="line">    final boolean inactive = !fragment.isInBackStack();</span><br><span class="line">    // 虽然Fragment已被dettach，但是有可能还关联在回退栈中。</span><br><span class="line">    if (!fragment.mDetached || inactive) &#123;</span><br><span class="line">        if (mAdded != null) &#123;</span><br><span class="line">            mAdded.remove(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>当某个事务被“保存”到了回退栈，那么每当该事务被执行run时，该事务中所关联的所有Fragment（包括<code>OP_REPLACE</code>中的<code>op.removed</code>）的mBackStackNesting就会被+1，同时在执行Op操作OP_REPLACE时，需要被remove的Fragment的mBackStackNesting还会被额外+1，保证了mBackStackNesting表示关联事务数含义的正确性。<br>每当该事务被出栈popFromBackStack时，相应的mBackStackNesting就会被-1。这些都是通过bumpBackStackNesting方法来操作的：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// BackStackRecord</span><br><span class="line">void bumpBackStackNesting(int amt) &#123;</span><br><span class="line">    // mAddToBackStack表示当前事务是否已被添加进了回退栈</span><br><span class="line">    if (!mAddToBackStack) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Op op = mHead;</span><br><span class="line">    // 将该事务所关联的所有Fragment的mBackStackNesting都执行了+/-</span><br><span class="line">    while (op != null) &#123;</span><br><span class="line">        if (op.fragment != null) &#123;</span><br><span class="line">            op.fragment.mBackStackNesting += amt;</span><br><span class="line">        &#125;</span><br><span class="line">        if (op.removed != null) &#123;</span><br><span class="line">            for (int i=op.removed.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                Fragment r = op.removed.get(i);</span><br><span class="line">                r.mBackStackNesting += amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>虽然该字段在状态保存与恢复期间并不会被持久化，但是由于FragmentManager保存了回退栈，所以在恢复状态时，mBackStackNesting会被重新计算恢复为状态丢失前的值。</li></ul><h3 id="mFragmentManager"><a href="#mFragmentManager" class="headerlink" title="mFragmentManager"></a>mFragmentManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// The fragment manager we are associated with.  Set as soon as the</span><br><span class="line">// fragment is used in a transaction; cleared after it has been removed</span><br><span class="line">// from all transactions.</span><br></pre></td></tr></table></figure><h3 id="mHost"><a href="#mHost" class="headerlink" title="mHost"></a>mHost</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Host this fragment is attached to.</span><br></pre></td></tr></table></figure><h3 id="mChildFragmentManager"><a href="#mChildFragmentManager" class="headerlink" title="mChildFragmentManager"></a>mChildFragmentManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Private fragment manager for child fragments inside of this one.</span><br></pre></td></tr></table></figure><h3 id="mChildNonConfig"><a href="#mChildNonConfig" class="headerlink" title="mChildNonConfig"></a>mChildNonConfig</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// For use when restoring fragment state and descendant fragments are retained.</span><br><span class="line">// This state is set by FragmentState.instantiate and cleared in onCreate.</span><br></pre></td></tr></table></figure><h3 id="mParentFragment"><a href="#mParentFragment" class="headerlink" title="mParentFragment"></a>mParentFragment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// If this Fragment is contained in another Fragment, this is that container.</span><br></pre></td></tr></table></figure><p>提供了一个和Parent通信的方式。</p><h3 id="mFragmentId"><a href="#mFragmentId" class="headerlink" title="mFragmentId"></a>mFragmentId</h3><p>一个可选的唯一性标识，静态加载时为<code>&lt;fragment&gt;</code>的id属性，可以使用<code>FragmentManager#findFragmentById</code>找到对应的Fragment实例缓存；动态加载时则和<code>container ID</code>相同，即所依附的视图容器的ID。</p><blockquote><p>注意：不要试图在动态加载的方式下对已经add到cntainerView上的Fragment使用findFragmentById方式查找，因为使用事务提交时，默认约束了Fragment的mFragmentId等于<code>container ID</code>。</p></blockquote><p>在使用事务add/replace时，会对Fragment的mFragmentId及其所依附的containerView的Id进行检查，因为默认情况下被add的Fragment的mFragmentId最后被指定为了mContainerView的Id，所以在commit时发现ragment.mFragmentId != containerViewId就会抛出异常阻止操作，防止已被add的Fragment再被add至其它containerView：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (containerViewId != 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can&#x27;t change container ID of fragment &quot; ...);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mContainerId"><a href="#mContainerId" class="headerlink" title="mContainerId"></a>mContainerId</h3><p>如果Fragment是使用动态加载的方式添加的，那么该字段标识的就是其所依附的containerView的ID，在构建事务时指定（具体是在<code>doAddOp</code>方法中）。  </p><p>如果Fragment是静态加载的，该字段就是<code>&lt;fragment/&gt;</code>标签的parent的id（若存在）；但是若<code>&lt;fragment/&gt;</code>标签没有为Fragment指定id或者tag，并且其parent也正好没有id，就会抛出异常终止静态创建。（因为在没有为Fragment指定id或者tag时，FragmentManager会尝试以parent id去查找Fragment缓存）。</p><p>该字段存在的意义是用来找到Fragment的mView的parent容器，仅对动态加载方式有效。而动态加载下找到mView的parent是为了什么，具体参见Fragment.mContainer字段。</p><h3 id="mTag"><a href="#mTag" class="headerlink" title="mTag"></a>mTag</h3><p>一个可选的标识，通常用来查找对应的Fragment缓存实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 通过FragmentManager查找：</span><br><span class="line">public Fragment findFragmentByTag(String tag) &#123;</span><br><span class="line">    if (mAdded != null &amp;&amp; tag != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (mActive != null &amp;&amp; tag != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>若一个Fragment实例被设置了mTag，那么不能再对其指定其它mTag：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在添加事务时：</span><br><span class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (tag != null) &#123;</span><br><span class="line">        if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can&#x27;t change tag of fragment &quot;</span><br><span class="line">                    + fragment + &quot;: was &quot; + fragment.mTag</span><br><span class="line">                    + &quot; now &quot; + tag);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mTag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mHidden"><a href="#mHidden" class="headerlink" title="mHidden"></a>mHidden</h3><p>Fragment的显示/隐藏状态，实则是对Fragment的mView进行VISIBLE/GONE；默认状态为false，即视图显示；与mHidden相关的方法是onHiddenChanged，只要mHidden发生改变，那么onHiddenChanged就会回调，mHidden发生改变是通过显式调用show/hide命令来完成的，除此之外，mHidden是不会变化的（除dettach后被重置外）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void showFragment(Fragment fragment, int transition, int transitionStyle) &#123;</span><br><span class="line">    if (fragment.mHidden) &#123;</span><br><span class="line">        fragment.mHidden = false;</span><br><span class="line">        if (fragment.mView != null) &#123;</span><br><span class="line">            ...</span><br><span class="line">            fragment.mView.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        fragment.onHiddenChanged(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以发现，若状态未发生变化，方法是不会发生任何变化的。</p><h3 id="mDetached"><a href="#mDetached" class="headerlink" title="mDetached"></a>mDetached</h3><p>标识Fragment是否已被Dettach，通过显式调用attach/dettach命令来改变状态。如果Fragment已被dettach，那么add/remove命令是无效的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">public void addFragment(Fragment fragment, boolean moveToStateNow) &#123;</span><br><span class="line">    ...</span><br><span class="line">    makeActive(fragment);</span><br><span class="line">    if (!fragment.mDetached) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mRetainInstance-amp-amp-mRetaining"><a href="#mRetainInstance-amp-amp-mRetaining" class="headerlink" title="mRetainInstance &amp;&amp; mRetaining"></a>mRetainInstance &amp;&amp; mRetaining</h3><ul><li><a href="http://stackoverflow.com/questions/11182180/understanding-fragments-setretaininstanceboolean">http://stackoverflow.com/questions/11182180/understanding-fragments-setretaininstanceboolean</a></li><li><a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html">http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html</a></li><li><a href="https://developer.android.com/guide/topics/resources/runtime-changes.html">https://developer.android.com/guide/topics/resources/runtime-changes.html</a></li></ul><p><strong>mRetainInstance</strong> 指示当前Fragment需要保持实例状态，即不随宿主Activity的销毁重建而销毁重建。可以在Fragment中通过<code>setRetainInstance(true)</code>来开启该特性。</p><p><strong>mRetaining</strong> 指示当前Fragment正处于宿主Activity的销毁和重建的过程中，即保持实例中ing；或者解释为标识当前Fragment是一个保持了实例未被销毁的Fragment，所以在moveToState中需要对其进行特殊对待。</p><p><strong>应用场景</strong>：有时候在设备配置发生变化时Activity需要立即销毁并重建；而有些自定义变量需要保持 或 处理过程不需要因此中断，例如线程，就可以使用该方式来维持Fragment实例以满足需求。++注意与Activity被kill的区别，不论是主动finish还是因内存不足而killed++。</p><p><strong>原理</strong>：若不需要自行处理Activity配置的变更（即在Manifest中未对Activity进行<code>android:configChanges</code>配置，所以称为<code>NonConfig</code>），Activity会销毁并重建。系统在销毁前会回调<code>Activity#onRetainNonConfigurationInstance()</code>，可以用来保留一些可以传递到新Activity的实例，在FragmentActivity中该方法被重写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FragmentActivity</span><br><span class="line">@Override</span><br><span class="line">public final Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();</span><br><span class="line">    ...</span><br><span class="line">    NonConfigurationInstances nci = new NonConfigurationInstances();</span><br><span class="line">    ...</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    ...</span><br><span class="line">    return nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>mFragments.retainNestedNonConfig()</code>最终调用了<code>FragmentManager#retainNonConfig</code>方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">FragmentManagerNonConfig retainNonConfig() &#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; fragments = null;</span><br><span class="line">    ArrayList&lt;FragmentManagerNonConfig&gt; childFragments = null;</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 重要标识：仅当Fragment调用了setRetainInstance(true)，该实例才会被缓存在fragments中</span><br><span class="line">        if (f.mRetainInstance) &#123;</span><br><span class="line">            if (fragments == null) &#123;</span><br><span class="line">                fragments = new ArrayList&lt;Fragment&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            fragments.add(f);</span><br><span class="line">            // 开启该标识，以防止在moveToState时的部分生命周期方法的调用</span><br><span class="line">            f.mRetaining = true;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 当然，其嵌套子Fragments如果也开启了mRetainInstance，也会被保存</span><br><span class="line">        if (f.mChildFragmentManager != null) &#123;</span><br><span class="line">            FragmentManagerNonConfig child = f.mChildFragmentManager.retainNonConfig();</span><br><span class="line">            ...</span><br><span class="line">            childFragments.add(child);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果该FragmentManager下没有任何Fragment需要保持实例，则返回null</span><br><span class="line">    if (fragments == null &amp;&amp; childFragments == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后，将缓存包装在FragmentManagerNonConfig对象中返回</span><br><span class="line">    return new FragmentManagerNonConfig(fragments, childFragments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>纵观整个方法的流程，其实就是将需要保持实例的Fragment及其相应的嵌套子Fragment实例都保存在了FragmentManagerNonConfig对象中并返回，FragmentActivity将得到的该对象又被包装在NonConfigurationInstances里返回给了系统；我们知道，在Activity被重新create时，Activity里首次被调用的方法是attach(…)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void attach(...NonConfigurationInstances lastNonConfigurationInstances...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过该方法系统传入了上次包装实例的缓存对象<code>lastNonConfigurationInstances</code>，然后在经历生命周期过程第一个方法onCreate时，Activity直接使用了该对象来恢复Fragments实例（针对<code>.app.Fragment</code>），在FragmentActivity中也是一样（针对<code>.app.v4.Fragment</code>）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Activity#onCreate</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">// FragmentActivity#onCreate</span><br><span class="line">...</span><br><span class="line">// getLastNonConfigurationInstance方法取就是传入Activity中的mLastNonConfigurationInstances对象</span><br><span class="line">NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, nc != null ? nc.fragments : null);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更多可以参见Fragment的状态保存与恢复机制一文。</p><h3 id="mHasMenu-amp-amp-mMenuVisible"><a href="#mHasMenu-amp-amp-mMenuVisible" class="headerlink" title="mHasMenu &amp;&amp; mMenuVisible"></a>mHasMenu &amp;&amp; mMenuVisible</h3><blockquote><p>注意：Fragment里与这两个字段相关的Menu指的都是<code>OptionsMenu</code>，注意与其它<a href="https://developer.android.google.cn/guide/topics/ui/menus.html?hl=zh-cn#options-menu">菜单类型</a>的区别。<br><code>OptionsMenu</code>指的是通过物理menu按钮点击显示的菜单或者是ActionBar/ToolBar上显示的actions。</p></blockquote><ul><li><code>mHasMenu</code>表示当前Fragment有可被展示的OptionsMenu。默认为FALSE，可以通过Fragment的<code>setHasOptionsMenu(true)</code>方法开启（具体开启方法见 <code>附：OptionMenu的使用方法</code>，下同），将当前Activity下的Menu切换为Fragment的Menu。</li><li><code>mMenuVisible</code>表示在当前Fragment存在OptionsMenu的前提下（即建立在mHasMenu的基础之上），该Menu是否可见，默认为TRUE，可以通过<code>setMenuVisibility(boolean)</code>关闭。例如我们add了一个Fragment，但是该Fragment目前被同容器下的另一个Fragment遮挡而看不见，那么就可以将该字段设置为FALSE，以同步正确的状态。<blockquote><p>注意：这里的“看不见”<strong>不包括</strong>显示状态设置为不可见（即HIDDEN）。源码中与OptionsMenu相关的三个回调方法的前置条件是<code>mHidden</code>为FALSE。</p></blockquote></li></ul><p>只有当两个字段状态同时满足的前提下，OptionMenu才有效。</p><p>并且，Fragment的任何事务操作，例如 add/show/… 等都会依据这两个字段修改FragmentManager的<code>mNeedMenuInvalidate</code>属性（置为True），在所有的Fragment进行movetToState整体状态切换完成后，会依据mNeedMenuInvalidate来触发<code>invalidateOptionsMenu(Activity)</code>方法开始OptionsMenu流程，因此可以说Menu的显示/移除等都是“实时”的。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>两个字段其实最终触发的仍然是宿主Activity的<code>invalidateOptionsMenu(Activity)</code>方法，所以本质上与Activity本身的OptionsMenu使用流程相同：<br><code>invalidateOptionsMenu()</code>会导致宿主Activity重新初始化OptionsMenu流程，该流程会依次调用宿主Activity的<code>onCreateOptionsMenu(Menu)</code>、<code>onPrepareOptionsMenu(Menu)</code>。而我们开启Fragment的<code>mHasMenu</code>后，这两个方法被回调的同时，Fragment的对应的同名方法也会被回调，因此只要在Fragment的<code>onCreateOptionsMenu(Menu)</code>中setup自己的Menu就可以将OptionMenu替换为Fragment自己的Menu。<br>当然，在其它情况例如Fragment被Hide时，虽然仍旧会触发Activity的的<code>onCreateOptionsMenu(Menu)</code>、<code>onPrepareOptionsMenu(Menu)</code>，但是Fragment的对应方法不会被回调，取而代之的是回调方法<code>onDestroyOptionsMenu()</code>（在存在optionMenu的去前提下），这是因为FragmentManager在分发对应的optionMenu事件时会让Fragment检查自己的Hidden状态，如果是hide，则FragmentManager在通知完<code>onDestroyOptionsMenu()</code>后，返回给宿主是false，使得Fragment对应的方法无法回调。具体可以参见FragmentManager的<code>mCreatedMenus</code>字段详解。</p><p>++另外，源码中mHasMenu与mMenuVisible总是成对被调用，因此这两个字段的根本意义是相同的，不同的字段名是为了更直观地区分控制 “拥有” / “显示” 两个状态。++</p><h4 id="附：OptionMenu的使用方法"><a href="#附：OptionMenu的使用方法" class="headerlink" title="附：OptionMenu的使用方法"></a>附：OptionMenu的使用方法</h4><p>使用OptionMenu一共需要重写4个方法，除了<code>onOptionsMenuClosed</code>方法未找到任何方式触发回调、不需要再关心外，剩余的3个方法分别是 <code>onCreateOptionsMenu、onPrepareOptionsMenu、onOptionsItemSelected</code> 。而Menu可以通过xml配置或者动态构建。</p><ol><li>onCreateOptionsMenu</li></ol><p>OptionsMenu初始化流程的第一步，默认在Activity启动时会触发该流程，在第一步中该流程会依次回调Activity和Fragment的对应方法，当然，Fragment被回调的前提是Fragment开启了mHasMenu和mMenuVisible。回调Fragment的顺序是按照Fragment被添加的顺序来的，下同，不再重复分析。<br>另外，Activity中的该方法需要返回一个boolean变量，若返回false不会进行到下一步的onPrepareOptionsMenu流程。</p><ol><li>onPrepareOptionsMenu</li></ol><p>OptionsMenu初始化流程的第二步，除此之外，每次点击<strong>菜单按钮</strong>也会触发该步骤的回调。该步骤照例会同onCreateOptionsMenu一样依次回调Activity和Fragment对应的方法。<br>并且Activity中的该方法也需要返回一个boolean值，如果返回false，这些actions就不会出现。</p><ul><li>onOptionsItemSelected</li></ul><p>这是actions的事件回调方法。所有的actions事件 不管系统是否处理，最后都会来到该方法。如果 Activity 包含有Fragment，则系统将依次为 Activity 和每个Fragment（按照每个Fragment的添加顺序）调用 onOptionsItemSelected()，直到有一个返回结果为 true 或所有Fragment均调用完毕为止。</p><p>另外，actions并非就完全指OptionsMenu的item，还包括ActionBar/ToolBar上面的其它系统提供的可选按钮，例如”Up Button” 按钮，一个左上角的返回按钮：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1. &quot;Up Button&quot; 表示可以回到所指定的Activity，取代默认的回到栈中上一个页面的逻辑，这个Activity称作parent；&lt;br/&gt;</span><br><span class="line"> * 2. parent需要在Manifest中为当前Activity通过android:parentActivityName指定；&lt;br/&gt;</span><br><span class="line"> * 3. 原理：其实就是Activity的“出栈”，通过该按钮可以直接destroy掉栈中parent与当前Activity之间的元素，并显示parent；&lt;br/&gt;</span><br><span class="line"> * 4. 若指定的parent并不存在于Activity栈中或者存在但已经destroy了，则按钮的事件和普通的finish无异；&lt;br/&gt;</span><br><span class="line"> * 5. 若并没有指定parent，那么按钮除了照例回调onOptionsItemSelected外，没有任何事件响应；&lt;br/&gt;</span><br><span class="line"> * 6. 默认launchMode下，parent若还“alive”，会先被destroy再create（注意：与状态保存恢复机制的重建不同）；&lt;br/&gt;</span><br><span class="line"> * 7. 若不需要parent先被destroy，可以将launchMode指定为singleTop；&lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">getSupportActionBar().setDisplayHomeAsUpEnabled(true);</span><br></pre></td></tr></table></figure></p><h3 id="mNextAnim"><a href="#mNextAnim" class="headerlink" title="mNextAnim"></a>mNextAnim</h3><p>表示与Fragment关联的接下来会使用的anim动画，注意与构建事务时指定的动画的联系与区别。</p><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>mNextAnim的取值全部来自构建事务时指定的动画（若未重写<code>fragment.onCreateAnimation</code>），具体可以参见BackStackRecord的Op字段详解或BackStackRecord分析一文。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>区别在于，构建事务时指定的动画是包含Fragment在几种时机所需执行的动画的集合，例如Fragment被add/show/hide/detach等；而mNextAnim就是在前面所说的特定时机到来时被赋值为指定的动画集合中与该时机所关联的某一个动画，所以称为接下来会使用的anim动画。</p><h3 id="mContainer"><a href="#mContainer" class="headerlink" title="mContainer"></a>mContainer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// The parent container of the fragment after dynamically added to UI.</span><br></pre></td></tr></table></figure><p>也就是说，<strong>对于静态加载的Fragment，该字段为null，以下分析不适用于该方式</strong>；</p><p>对于动态加载的Fragment，mContainer在FragmentManager触发执行onCreateView之前通过containerId得到，containerId的具体细节参见对应的字段详解。</p><p>在构建事务时如果指定了containerId（传入0表示不指定），但该ID不属于当前宿主视图中的任何一个，在这一步创建mContainer时便会抛出异常终止。</p><p>当mContainer创建完成后（不管是否为null）便会开始回调onCreateView方法得到Fragment的视图mView（在moveToState方法升序的CREATED分支下），在mContainer不为null的前提下，mView被addView到了mContainer：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f.mContainer = container;</span><br><span class="line">f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">if (f.mView != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (container != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        container.addView(f.mView);</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">    f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上述片段中同时还可以知道：在动态方式下如果未对Fragment指定container，即mContainer为null，表示该Fragment是一个无视图的对象，因此不管该Fragment的onCreateView是否返回一个具体的mView，都已不重要。</p><p>最后在moveToState方法降序的ACTIVITY_CREATED分支下，也就是回调onDestroyView后onDestroy前，该字段将Fragment的视图remove了并把自己置为了null：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f.performDestroyView();</span><br><span class="line">if (f.mView != null &amp;&amp; f.mContainer != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f.mContainer.removeView(f.mView);</span><br><span class="line">&#125;</span><br><span class="line">f.mContainer = null;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>所以最后的结论是：该字段用作容纳动态创建的Fragment的mView，在回调onCreateView方法前被创建，在回调onCreateView方法后立即将mView添加进来，在onDestroyView后立即将mView移除。</p><h3 id="mView"><a href="#mView" class="headerlink" title="mView"></a>mView</h3><p>表示Fragment的视图（若存在），在moveToState中由FragmentManager的performCreateView触发调用Fragment的onCreateView返回，在ondestroyView后被置null，在Fragment对象中的任何地方可以通过getView()快速取得。<br>我们调用最多的操作之一<code>show/hide</code> Fragment实际调用的就是对字段的<code>setVisibility</code>方法。</p><h3 id="mInnerView"><a href="#mInnerView" class="headerlink" title="mInnerView"></a>mInnerView</h3><p>该字段等同于mView，仅用作Fragment视图的状态保存与恢复枢纽。</p><blockquote><p>既然mInnerView与mView相同，为什么不直接使用mView反而额外提供一个mInnerView？  </p></blockquote><p>先给出原因：为了分离宿主Activity和Fragment的在视图层面上的状态保存恢复。 </p><p>我们知道，在宿主Activity触发状态保存时，会对对应的视图层级内的所有View进行状态保存，其中就包括add到宿主的Fragment的mView，但是对于Fragment，其mView仅是属于自身状态的一部分，Fragment自身整体状态才属于宿主Activity状态的一部分，因此如果让Fragment的mView随宿主一起进行状态保存，那么当宿主率先恢复状态时，由于Fragment的mView的创建是要滞后于宿主的，恢复的Fragment的mView还未创建，那么属于Fragment的mView的状态就无法得到恢复而造成状态丢失。因此mInnerView的存在就是为了将宿主Activity与Fragment的状态保存分离，进行分别保存。</p><p>分离的第一步就是在Fragment创建视图时：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f.mView = f.performCreateView(f.getLayoutInflater(...);</span><br><span class="line">if (f.mView != null) &#123;</span><br><span class="line">    f.mInnerView = f.mView;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 11) &#123;</span><br><span class="line">        ViewCompat.setSaveFromParentEnabled(f.mView, false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        f.mView = NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">    f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    f.mInnerView = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>setSaveFromParentEnabled：表示对传入的View参数，关闭其层级开始及其以下所有的子View的保存状态不再受其parent的控制；</li><li>NoSaveStateFrameLayout.wrap： 由于setSaveFromParentEnabled方法是API&gt;=11开始新增的，在此之前只有layout才有该方法，所以这里的NoSaveStateFrameLayout是对mView进行一层包裹，以兼容处理。</li></ul><p>也就是说，依靠<a href="https://android.googlesource.com/platform/frameworks/support/+/5e63ab9%5E!/">ViewCompat.setSaveFromParentEnabled(f.mView, false);</a> 或 <code>NoSaveStateFrameLayout.wrap(f.mView);</code>，Fragment彻底切断了其mView与宿主Activity之间状态保存的层级调用关系。</p><p>接着由于Fragment的mView层级下的状态保存调用关系链已被切断，因此在切断之前提供了mInnerView来备份mView。当Fragment的状态保存与恢复机制被触发时，mView层级下的所有View的状态保存便是由mInnerView来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 调用链：saveAllState -&gt; saveFragmentBasicState -&gt; saveFragmentViewState</span><br><span class="line">void saveFragmentViewState(Fragment f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f.mInnerView.saveHierarchyState(mStateArray);</span><br><span class="line">    if (mStateArray.size() &gt; 0) &#123;</span><br><span class="line">        f.mSavedViewState = mStateArray;</span><br><span class="line">        mStateArray = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 视图创建后，mInnerView就代表mView</span><br><span class="line">final void restoreViewState(Bundle savedInstanceState) &#123;</span><br><span class="line">    if (mSavedViewState != null) &#123;</span><br><span class="line">        mInnerView.restoreHierarchyState(mSavedViewState);</span><br><span class="line">        mSavedViewState = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mDeferStart-amp-amp-mUserVisibleHint"><a href="#mDeferStart-amp-amp-mUserVisibleHint" class="headerlink" title="mDeferStart &amp;&amp; mUserVisibleHint"></a>mDeferStart &amp;&amp; mUserVisibleHint</h3><p>可以理解为延迟开始的标识，如果当前Fragment的状态还没有走到Fragment.STARTED，那么当mDeferStart为true时，Fragment的状态最多只能到Fragment.STOPPED，无法通过moveToState继续切换到Fragment.STARTED：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">moveToState(Fragment, int, int, int, boolean) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mDeferStart具体是由<code>setUserVisibleHint(boolean)</code>控制的，setUserVisibleHint是Fragment提供的一个 <strong>可见提示</strong> 状态<code>UserVisibleHint</code>（注意与Hidden是没有关系的，即使hidden为false，UserVisibleHint也不一定为true）的手动切换方法，默认状态是可见的，例如某些情况Fragment是SHOW状态，但是布局并未显示在屏幕当中，我们可以手动将它的<code>UserVisibleHint</code>置为false，Fragment会根据该状态对生命周期状态做出一些特定调整，这样就可以方便我们根据该特性来决定是否执行一些操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 如果UserVisibleHint状态未被改变（即默认本身就是可见，我们无需再次设置可见），则该方法不影响Fragment的生命周期状态。</span><br><span class="line">public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">    // 在Fragment被add且状态未到STARTED前的前提下，</span><br><span class="line">    // 当Fragment之前被标为不可见，现在切换为可见时，流程进入该分支，开始继续生命周期状态的切换流程。</span><br><span class="line">    if (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED</span><br><span class="line">            &amp;&amp; mFragmentManager != null &amp;&amp; isAdded()) &#123;</span><br><span class="line">        mFragmentManager.performPendingDeferredStart(this);</span><br><span class="line">    &#125;</span><br><span class="line">    mUserVisibleHint = isVisibleToUser;</span><br><span class="line">    // 也就是说，如果Fragment已经STARTED了，则该方法就不起作用了。</span><br><span class="line">    mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当开启这一特性使Fragment的生命周期状态阻塞到<code>STOPPED</code>后利用它完成自定义操作时，还需要恢复Fragment的生命周期状态到宿主Activity的当前生命周期所对对应的状态，这里一共有3种触发方式：</p><ol><li>再次手动调用setUserVisibleHint改变状态，一般是false开启，true恢复。</li><li>如果有loader运行，loader加载完成/销毁时是一个触发点。</li><li>事务执行完成时、所有事务的全部执行完成时。</li></ol><h4 id="方式1：调用setUserVisibleHint"><a href="#方式1：调用setUserVisibleHint" class="headerlink" title="方式1：调用setUserVisibleHint"></a>方式1：调用setUserVisibleHint</h4><p>当符合条件，<code>setUserVisibleHint</code>会直接关闭<code>mDeferStart</code>标识并调用<code>moveToState</code>开始切换Fragment的状态到当前Activity所对应的状态。在决定继续生命周期状态的切换之前，performPendingDeferredStart还会再检查一下事务：如果当前正在执行Fragment事务transactions，就跳过并给个状态标识mHavePendingDeferredStart，以示等待：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">public void performPendingDeferredStart(Fragment f) &#123;</span><br><span class="line">    if (f.mDeferStart) &#123;</span><br><span class="line">        if (mExecutingActions) &#123;</span><br><span class="line">            // Wait until we&#x27;re done executing our pending transactions</span><br><span class="line">            mHavePendingDeferredStart = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        f.mDeferStart = false;</span><br><span class="line">        moveToState(f, mCurState, 0, 0, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mHavePendingDeferredStart标识表示有一个DeferredStart还没执行，需要在mPendingActions事务结束后执行它。</p><p>Fragment的事务是在execPendingActions()方法（以commit方式提交）或者execSingleAction方法（以commiyNow方式提交）中执行的，在这两个方法的最后，都调用了方法doPendingDeferredStart：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">void doPendingDeferredStart() &#123;</span><br><span class="line">    if (mHavePendingDeferredStart) &#123;</span><br><span class="line">        boolean loadersRunning = false;</span><br><span class="line">        for (int i = 0; i &lt; mActive.size(); i++) &#123;</span><br><span class="line">            Fragment f = mActive.get(i);</span><br><span class="line">            if (f != null &amp;&amp; f.mLoaderManager != null) &#123;</span><br><span class="line">                loadersRunning |= f.mLoaderManager.hasRunningLoaders();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!loadersRunning) &#123;</span><br><span class="line">            mHavePendingDeferredStart = false;</span><br><span class="line">            startPendingDeferredFragments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法中根据<code>mHavePendingDeferredStart</code>标识来判断是否还有DeferredStart在等待执行，同时DeferredStart可以被执行的另一个前提是FragmentManager中任何一个Fragment当前都没有loader正在执行，若两个条件都满足了则依次通过调用方法<code>startPendingDeferredFragments()</code>和<code>performPendingDeferredStart(f)</code>对FragmentManager中的Fragment进行遍历执行，最终流程执行回了<code>performPendingDeferredStart</code>方法，开始<code>moveState</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">void startPendingDeferredFragments() &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performPendingDeferredStart(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，当手动调用setUserVisibleHint请求为Fragment恢复为最新状态时，需要保证当前的事务（若正在执行）和loader（若正在执行）都执行完毕，才会触发最终的moveState。</p><h4 id="方式2：loader未开始-或-加载完成-销毁时"><a href="#方式2：loader未开始-或-加载完成-销毁时" class="headerlink" title="方式2：loader未开始 或 加载完成/销毁时"></a>方式2：loader未开始 或 加载完成/销毁时</h4><p>当然，若当前存在正在运行的loader，不管有多少个，只要在最后一个loader执行完毕或者销毁时，也会调用performPendingDeferredStart根据deferredStart触发moveToState执行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// LoaderManager</span><br><span class="line">@Override</span><br><span class="line">public void destroyLoader(int id) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mHost != null &amp;&amp; !hasRunningLoaders()) &#123;</span><br><span class="line">        mHost.mFragmentManager.startPendingDeferredFragments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onLoadComplete(Loader&lt;Object&gt; loader, Object data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mHost != null &amp;&amp; !hasRunningLoaders()) &#123;</span><br><span class="line">        mHost.mFragmentManager.startPendingDeferredFragments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方式3：相关事务的执行完毕时"><a href="#方式3：相关事务的执行完毕时" class="headerlink" title="方式3：相关事务的执行完毕时"></a>方式3：相关事务的执行完毕时</h4><p>除了一个Looper周期内整体的mPendingActions执行完成时会根据mHavePendingDeferredStart标识来触发moveState外，单个事务执行完成时也会触发：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// BackStackRecord</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mManager.moveToState(mManager.mCurState, transition, transitionStyle, true);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// FragmentManager</span><br><span class="line">void moveToState(int newState, int transit, int transitStyle, boolean always) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!loadersRunning) &#123;</span><br><span class="line">        startPendingDeferredFragments();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方式4：Fragment-pop返回栈时"><a href="#方式4：Fragment-pop返回栈时" class="headerlink" title="方式4：Fragment pop返回栈时"></a>方式4：Fragment pop返回栈时</h4><p>Fragment出栈调用的是<code>FragmentManager#popBackStack()</code>或其重载方法，它们内部经过一系列调用链后最终执行到了d单个事务的具体出栈操作<code>BackStackRecord#popFromBackStack(...)</code>方法，当此次出栈的所有事务都完成出栈后，也调用了4个参数的moveToState方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// BackStackRecord</span><br><span class="line">public TransitionState popFromBackStack(boolean doStateMove, TransitionState state,</span><br><span class="line">            SparseArray&lt;Fragment&gt; firstOutFragments, SparseArray&lt;Fragment&gt; lastInFragments) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (doStateMove) &#123;</span><br><span class="line">        mManager.moveToState(mManager.mCurState,</span><br><span class="line">                FragmentManagerImpl.reverseTransit(transition), transitionStyle, true);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结论：不管时哪一种方式，哪一个时机，只要存在mDeferStart标识，最后就会触发5个参数的moveState方法，将Fragment的生命周期状态<code>f.mState</code>恢复到与宿主Actitity最新状态对应的状态<code>mCurState</code>。</p><h3 id="xxTransitionxx"><a href="#xxTransitionxx" class="headerlink" title="xxTransitionxx"></a>xxTransitionxx</h3><ul><li>mEnterTransition</li><li>mReturnTransition</li><li>mExitTransition</li><li>mReenterTransition</li><li>mSharedElementEnterTransition</li><li>mSharedElementReturnTransition</li><li>mAllowReturnTransitionOverlap</li><li>mAllowEnterTransitionOverlap<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4></li><li><a href="http://icedcap.github.io/2016/06/26/%E5%AE%89%E5%8D%93Transition%E6%A1%86%E6%9E%B6/">http://icedcap.github.io/2016/06/26/%E5%AE%89%E5%8D%93Transition%E6%A1%86%E6%9E%B6/</a></li><li><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-2/readme.md">https://github.com/hehonghui/android-tech-frontier/blob/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-2/readme.md</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0201/2394.html">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0201/2394.html</a></li><li><a href="http://stackoverflow.com/questions/28975840/feature-activity-transitions-vs-feature-content-transitions">http://stackoverflow.com/questions/28975840/feature-activity-transitions-vs-feature-content-transitions</a></li></ul><h2 id="FragmentManager"><a href="#FragmentManager" class="headerlink" title="FragmentManager"></a>FragmentManager</h2><h3 id="mPendingActions"><a href="#mPendingActions" class="headerlink" title="mPendingActions"></a>mPendingActions</h3><blockquote><p>本字段可以结合BackStackRecord一文来分析。</p></blockquote><p>pending有“等待、挂起”的意思，mPendingActions表示等待即将执行的动作的集合。这些动作包括提交给FragmentManager的事务以及FragmentManager执行出栈的操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 提交事务</span><br><span class="line">int commitInternal(boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mManager.enqueueAction(this, allowStateLoss);</span><br><span class="line">    return mIndex;</span><br><span class="line">&#125;</span><br><span class="line">// 事务出栈</span><br><span class="line">public void popBackStackXXX() &#123;</span><br><span class="line">    enqueueAction(new Runnable() &#123;</span><br><span class="line">        @Override public void run() &#123;popBackStackState(...);&#125;</span><br><span class="line">    &#125;, boolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有只要是不需要立即执行的 事务 / 出栈，都会先通过方法<code>enqueueAction(Runnable, allowStateLoss)</code>被加入到该集合中，并等待主线程Handler的回调执行。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol><li><p>向mPendingActions集合添加动作时，一旦集合中有了数据，就会向主线程的Handler post一个mExecCommit的Runnable，该动作会在Handler下个回调周期执行mPendingActions里面的 <code>等待动作</code>：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mPendingActions == null) &#123;</span><br><span class="line">        mPendingActions = new ArrayList&lt;Runnable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingActions.add(action);</span><br><span class="line">    if (mPendingActions.size() == 1) &#123;</span><br><span class="line">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        mHost.getHandler().post(mExecCommit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mExecCommit = new Runnable() &#123;</span><br><span class="line">    @Override public void run() &#123;execPendingActions();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注：在Handler下个回调周期前，enqueueAction方法可能被调用多次，这样mPendingActions就存在多个 <code>等待动作</code> 的可能性。</p></blockquote></li><li><p>一旦Handler开始回调，<code>execPendingActions()</code>方法就开始执行，该方法在满足前提的条件下，会将mPendingActions集合中的 <code>等待动作</code> 依次取出来遍历执行：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean execPendingActions() &#123;</span><br><span class="line">    ...</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (mPendingActions == null || mPendingActions.size() == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 取出放入mTmpActions数组</span><br><span class="line">        mPendingActions.toArray(mTmpActions);</span><br><span class="line">        ...</span><br><span class="line">        // 遍历numActions执行Runnable</span><br><span class="line">        for (int i=0; i&lt;numActions; i++) &#123;</span><br><span class="line">            mTmpActions[i].run();</span><br><span class="line">            mTmpActions[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h4><p>这其实是为了效率。我们不可避免的会在同一时间提交多个事务，而事务的执行有相当部分是存在重复性的操作的，如果立即执行，对资源的消耗是可观的，为了避免这种情况，FragmentManager提供了mPendingActions字段来结合Handler实现该方案。<br>而对于出栈操作，执行的正是事务的“反操作”，因此也可以理解为一种事务。</p></li></ol><h3 id="mTmpActions"><a href="#mTmpActions" class="headerlink" title="mTmpActions"></a>mTmpActions</h3><p>一个临时的动作数组集合，在mPendingActions的执行时机到来时（即execPendingActions方法执行时），为了++避免在执行mPendingActions里面的 <code>等待动作</code> 期间又需要 提交事务/出栈 而需要加锁引起的同步低效率++，这里引出mTmpActions数组来专门盛放从mPendingActions取出的动作以供执行，降低了对mPendingActions的占用。</p><p>具体可以参见<code>mPendingActions</code>的字段详解。</p><h3 id="mExecutingActions"><a href="#mExecutingActions" class="headerlink" title="mExecutingActions"></a>mExecutingActions</h3><p>“正在执行动作” 的标识。具体讲就是只要有 事务/出栈 开始执行，该变量就会被置为TRUE，一旦完成就会被置为FALSE。在方法execPendingActions和execSingleAction被改变。</p><p>该字段被用来在 事务/出栈 被执行期间，防止用户手动commitNow。否则抛出异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new IllegalStateException(&quot;FragmentManager is already executing transactions&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="mActive"><a href="#mActive" class="headerlink" title="mActive"></a>mActive</h3><p>从资源使用的效率方面考虑，FragmentManager维护了一个Fragment集合mActive，该集合中的所有Fragment都存在被FragmentManager使用的可能性，来执行add/show/remove/…等所有操作。<br>对于已经Add到view-container中的Fragment这个可能性是100%的，因为Fragment状态的切换都需要FragmentManager来管理，因此被add的Fragment必然存在于mActive的集合中；<br>而对于那些已经从view-container中移除的Fragment，取决于它们是否有再次被使用的可能性，例如退栈操作恢复上个事务状态时（<code>backStackRecord.popFromBackStack()</code>），可能有之前已经被移除的Fragment需要被重新添加到view-container，即表示这个Fragment就有被再次使用的可能性，所以对于回退栈中的所有事务中包含的Fragment，需要保留在mActive集合中。而退栈操作所抛弃的当前事务状态是无法回来的，可能有当前需要从view-container移除的Fragment，那么这些Fragment也就没有被再次使用的可能性，也就不需要再保留到mActive中。</p><p>存在于mActive集合中的Fragment会被 ++“标记”++ 为<code>active</code>状态，反之为<code>inActive</code>状态。<br>根据上面的分析，对于已经Add到视图容器的Fragment或者该Fragment被回退栈 “++持有++”，那么这个Fragment一定是<code>active</code>状态，因此方法<code>isAdd()</code>和<code>isInBackStack()</code>可以用来判断一个Fragment是否处于<code>active</code>状态，除此之外，对于通过调用<code>setRetainInstance(true)</code>开启了设备配置改变时保留实例的特性的Fragment，在设备配置改变期间也不会被移除mActive集合。</p><blockquote><p>注意  </p><pre><code>- `setRetainInstance(true)`特性对于那些在发生设备配置改变时之前已经被正常destroy的Fragment是无效的，即使是该Fragment开启了该特性。具体可参见[Fragment状态保存与恢复](http://whataa.github.io/2017/01/04/Fragment-Save%20and%20Restroe%20State/)一文。  - `isInBackStack()`方法内部依据的是`mBackStackNesting`字段，具体可以参见`mBackStackNesting`的字段详解。</code></pre></blockquote><ul><li><p>“持有” </p><p>  表示已经加入到回退栈的事务中包含有对该Fragment的操作，不论这个事务是否位于栈顶，例如：</p><blockquote><p>事务A是将Fragment1 <strong>add</strong> 到view-container，并且该事务调用了<code>addToBackStack(String)</code>加入回退栈，然后事务B是将Fragment2 <strong>replace</strong> 到view-container，并且该事务也加入了回退栈。  </p></blockquote><p>  此时由于当前回退栈中存在事务A，且事务A中拥有对Fragment1的操作，那么就表示回退栈就 <strong>持有</strong> 了Fragment1。</p><p>  按照正常流程，提交事务B后Fragment1会依次被destroyView、destroy、detach，默认情况下detach后Fragment会被标记为“inActive”，但是由于Fragment1被回退栈持有，这样Fragment只会被destroyView而无法继续后面的流程。也就是说：被关联的Fragment被执行remove时不会被标记为“inActive”状态。</p></li></ul><ul><li><p>“标记”</p><p>  标记的具体操作是将Fragment的<code>mIndex</code>字段赋值并将Fragment加入或移除<code>mActive</code>集合。<br>  如果是标记为active状态，那么mIndex &gt; -1，且Fragment会被放入到了mActive集合中以mIndex为索引的对应位置；<br>  反之，mIndex被置为-1，并将mActive集合中对应处置为了null。</p></li></ul><p>另外还可以参考以下文档：</p><ul><li><a href="http://stackoverflow.com/questions/25695960/difference-between-madded-mactive-in-source-code-of-support-fragmentmanager">【stackoverflow】difference between madded mactive</a>.</li></ul><h3 id="mAdded-1"><a href="#mAdded-1" class="headerlink" title="mAdded"></a>mAdded</h3><p>mAdded是mActive集合的一个子集，包含的仅是当前已经被添加到view-container中的Fragment。如果一个Fragment从view-container被移除，那么不管该Fragment是否会从mActive中被移除，都会从mAdded集合中移除。  </p><p>我们可以通过Fragment的<code>isAdded()</code>方法来了解Fragment是否已经被Add，通常对区别mActive和mAdded集合很有效，可以参见Fragment的mAdded字段详解。</p><p>与mActive不同的是，位于mAdded集合中的Fragment由于当前正关联在Activity之上，所以可以接收一些由Activity分发/传递过来的事件，例如<code>performLowMemory、performConfigurationChanged</code>以及与<code>Menu（ContextMenu、OptionsMenu等）</code>相关的事件。</p><h3 id="mAvailIndices"><a href="#mAvailIndices" class="headerlink" title="mAvailIndices"></a>mAvailIndices</h3><p>作用类似于<code>mAvailBackStackIndices</code>字段。为Fragment分配唯一索引ID。</p><h3 id="mBackStack"><a href="#mBackStack" class="headerlink" title="mBackStack"></a>mBackStack</h3><p>表示FragmentManager所维护的回退栈。可以通过方法 <code>getBackStackEntryAt(index) 和 getBackStackEntryCount()</code> 来分别获取回退栈中指定index处的事务和回退栈的大小。  </p><p>当提交的事务被执行（<code>run()</code>）完成时，如果该事务开启了添加到回退栈的特性，FragmentManager会调用<code>addBackStackState(BackStackRecord)</code>方法将事务添加到<code>mBackStack</code>集合中并回调回退栈变化的监听（<code>OnBackStackChangedListener</code>）。    </p><blockquote><p>注意：回退栈的添加顺序与事务的执行顺序保持一致，因此FragmentManager限定了需要立即执行的事务无法添加到回退栈。</p></blockquote><p>当触发出栈操作时，方法<code>popBackStackState</code>将栈中对应位置以上的事务全部执行了remove，具体参见<a href="http://whataa.github.io/2017/01/21/Fragment-BackStackRecord/">BackStackRecord详解</a>一文。</p><h3 id="mCreatedMenus"><a href="#mCreatedMenus" class="headerlink" title="mCreatedMenus"></a>mCreatedMenus</h3><blockquote><p>首先需要查看Fragment的<code>mHasMenu &amp;&amp; mMenuVisible</code>字段详解。</p></blockquote><p>也是一个容纳Fragment的链表。该集合被FragmentManager用来记录开启了<code>optionMenu</code>的Fragment，以供稍后Fragment被hide/detach时用以回调<code>onDestroyOptionsMenu()</code>方法通知Fragment。</p><p>通过源码可知，optionMenu  Fragment的流程分发最后是由FragmentManager的<code>dispatchCreateOptionsMenu</code>方法具体执行的，该方法先后依据以下三个条件来决定是否调用一个Fragment的<code>onCreateOptionsMenu(...)</code>方法，分别是：</p><ol><li>是否存在于<code>mAdded</code>集合；</li><li>是否是SHOW状态（<code>!hidden</code>）；</li><li>是否满足<code>mHasMenu &amp;&amp; mMenuVisible</code>。</li></ol><p>如果三个条件都满足，Fragment的<code>onCreateOptionsMenu(...)</code>方法就会被回调然后通过<code>Fragment#performCreateOptionsMenu(...)</code>向FragmentManager返回true，最后FragmentManager会根据该返回状态将回调成功的Fragment添加到<code>mCreatedMenus</code>容器并向宿主Activity返回相同的状态。 </p><p>但是若只要是任中一个条件不满足，Fragment的<code>onCreateOptionsMenu(...)</code>便不会被执行，并且此时还会对之前添加到<code>mCreatedMenus</code>容器的Fragment依次回调其<code>onDestroyOptionsMenu()</code>方法，最后FragmentManager的<code>dispatchCreateOptionsMenu</code>向宿主Activity返回False状态，宿主在收到该状态后便不会将稍后的<code>onPrepareOptionsMenu(menu)</code>流程分发给这个Fragment。</p><h3 id="mBackStackIndices"><a href="#mBackStackIndices" class="headerlink" title="mBackStackIndices"></a>mBackStackIndices</h3><p>一个ArrayList<BackStackRecord>链表。索引处和索引处对应的值分别表示当前已被使用的事务ID和ID对应的事务。配合mAvailBackStackIndices链表一起为加入到回退栈的事务分配ID/回收ID。</p><p>这里的ID即Index，在回退栈中是唯一的，下同。为什么需要ID(Index)，可以参见BackStackRecord的mIndex字段详解。</p><p>需要被添加到回退栈的事务被commit时，FragmentManager会调用方法<code>allocBackStackIndex(BackStackRecord)</code>为其分配ID，同时将生成的ID和事务本身添加到了<code>mBackStackIndices</code>集合中。<br>当回退栈中的事务被出栈执行时，集合<code>mBackStackIndices</code>对应ID处的事务就会被置为null。<br>另外，虽然在状态保存期间，该集合会丢失，但是在状态恢复期间恢复的回退栈时，会根据回退栈中事务的mIndex将该集合也一并恢复。</p><h3 id="mAvailBackStackIndices"><a href="#mAvailBackStackIndices" class="headerlink" title="mAvailBackStackIndices"></a>mAvailBackStackIndices</h3><p>一个ArrayList<Integer>链表，从字段名也可以看出，该集合包含的是可再次利用的事务ID，为需要加入到回退栈的事务提供ID。</p><h4 id="集合中的ID的来源"><a href="#集合中的ID的来源" class="headerlink" title="集合中的ID的来源"></a>集合中的ID的来源</h4><p>该集合主要在出栈事务时收集被抛弃的事务的index。源码中共有两个方法向其添加元素：</p><ul><li>方法<code>setBackStackIndex(int index, BackStackRecord bse)</code>在状态恢复机制的<code>mBackStack</code>回退栈恢复期间被调用，作用是为了恢复<code>mBackStackIndices</code>和<code>mAvailBackStackIndices</code>集合。</li><li>方法<code>freeBackStackIndex</code>在回退栈中的事务被出栈执行时<code>popFromBackStack(...)</code>方法时被调用：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void freeBackStackIndex(int index) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mBackStackIndices.set(index, null);</span><br><span class="line">        if (mAvailBackStackIndices == null) &#123;</span><br><span class="line">            mAvailBackStackIndices = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mAvailBackStackIndices.add(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>方法freeBackStackIndex将回退栈中对应index处的事务置为了null，并且将该index放入了mAvailBackStackIndices集合。也就是说，mAvailBackStackIndices这里收集的都是之前已经存在了的index，否则 在<code>mBackStackIndices.set(index, null);</code>这一行 就会抛出索引越界的异常，  而这些已经存在的index或者说这些已经存在在回退栈中的事务，只有当出栈的时候才会抛弃，也就是被<code>BackStackRecord.popFromBackStack()</code>调用。</li></ul><h4 id="可用ID是如何被使用的"><a href="#可用ID是如何被使用的" class="headerlink" title="可用ID是如何被使用的"></a>可用ID是如何被使用的</h4><p>参见BackStackRecord的mIndex字段详解，我们知道在commit时，FragmentManager的allocBackStackIndex方法负责为当前事务分配ID：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int allocBackStackIndex(BackStackRecord bse) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mAvailBackStackIndices == null || mAvailBackStackIndices.size() &lt;= 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">            int index = mBackStackIndices.size();</span><br><span class="line">            mBackStackIndices.add(bse);</span><br><span class="line">            return index;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int index = mAvailBackStackIndices.remove(mAvailBackStackIndices.size()-1);</span><br><span class="line">            mBackStackIndices.set(index, bse);</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到只要mAvailBackStackIndices不空，就会优先从其中取出可用的index，否则才会取栈顶的索引作为当前事务的ID。  </p><h4 id="该链表的意义"><a href="#该链表的意义" class="headerlink" title="该链表的意义"></a>该链表的意义</h4><p>但是有一点不明白的是，结合上面的分析，其实每次从mAvailBackStackIndices取出的ID肯定就是当前回退栈的“栈顶”的索引（这里的栈顶指的是从栈的首部遍历，第一个为null的元素的索引），我们为什么不采用 <code>在抛弃事务时就将其从栈中remove掉，入栈事务时直接add</code> 这种方案呢，反而要维护一个多余的mAvailBackStackIndices集合？  </p><p>对于回退栈，入栈出栈相较是比较频繁的，因此为了效率，这里才采用<code>被抛弃的事务在回退栈中对应的位置的值只是被置为了null，而不是直接remove</code>操作，并利用基本链表freeBackStackIndex来维护可用的事务ID，这样就可以有效的避免频繁申请/回收回退栈的空间，这是一种典型的以空间换时间的模式。</p><h3 id="mBackStackChangeListeners"><a href="#mBackStackChangeListeners" class="headerlink" title="mBackStackChangeListeners"></a>mBackStackChangeListeners</h3><p>记录注册到FragmentManager的<code>OnBackStackChangedListener</code>的集合。OnBackStackChangedListener是监听FragmentManager维护的回退栈的变化的类，当回退栈添加事务或执行出栈操作，OnBackStackChangedListener类的<code>onBackStackChanged()</code>方法在这些操作执行完成后会被回调。</p><h3 id="mCurState"><a href="#mCurState" class="headerlink" title="mCurState"></a>mCurState</h3><p>FragmentManager维护下的Fragments的当前整体状态。由<code>FragmentManager#moveToState(int, boolean)</code>方法间接赋值改变：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(int newState, boolean always) &#123;</span><br><span class="line">    moveToState(newState, 0, 0, always);</span><br><span class="line">&#125;</span><br><span class="line">void moveToState(int newState, int transit, int transitStyle, boolean always) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mCurState = newState;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>宿主Activity生命周期发生变化时通过 dispatchXXX 方法调用了<code>moveToState(int, boolean)</code>，赋予当前Fragment与Activity生命周期对应的状态：<br>method | f.mState | newState | status<br>—|—|—|—<br>dispatchCreate() | <code>Fragment.INITIALIZING</code> | <code>Fragment.CREATED</code>                  | f.mState &lt; newState<br>dispatchActivityCreated() | <code>Fragment.CREATED</code> | <code>Fragment.ACTIVITY_CREATED</code>     | &lt;<br>dispatchStart() | <code>Fragment.ACTIVITY_CREATED</code> | <code>Fragment.STARTED</code>               | &lt;<br>dispatchResume() | <code>Fragment.STARTED</code> | <code>Fragment.RESUMED</code>                       | &lt;<br>dispatchPause() | <code>Fragment.RESUMED</code> | <code>Fragment.STARTED</code>                        | f.mState &gt; newState<br>dispatchStop() | <code>Fragment.STARTED</code> | <code>Fragment.STOPPED</code>                         | &gt;<br>dispatchReallyStop() | <code>Fragment.STOPPED</code> | <code>Fragment.ACTIVITY_CREATED</code>          | &gt;<br><del>dispatchDestroyView</del>() | <code>Fragment.ACTIVITY_CREATED</code> | <code>Fragment.CREATED</code>         | &gt;<br>dispatchDestroy() | <code>Fragment.CREATED</code> | <code>Fragment.INITIALIZING</code>                 | &gt;</p><p><code>moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive)</code>会根据所操作的Fragment的状态<code>f.mState</code>和当前需要变化到的状态<code>newState</code>来进行状态转化：</p><blockquote><p>注意：case之间并没有break，意味着每次moveToState时都是从Fragment的当前状态mState入口开始一直向下走直到最新的状态newState的所对应的case，期间会依次经历中间的状态；且case中执行相关操作（如<code>performXXX</code>）后都将<code>f.mState</code>更新为了当前case所对应的状态。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">moveToState(Fragment, int, int, int, boolean) &#123;</span><br><span class="line">    if (f.mState &lt; newState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (f.mState) &#123;</span><br><span class="line">            case Fragment.INITIALIZING:</span><br><span class="line">            ...</span><br><span class="line">            case Fragment.CREATED:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; elser if (f.mState &gt; newState) &#123;</span><br><span class="line">        switch (f.mState) &#123;</span><br><span class="line">            case Fragment.RESUMED:</span><br><span class="line">            ...</span><br><span class="line">            case Fragment.STARTED:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 各个版本不太一致，但是最后都是更新了Fragment的当前状态为最新（不一定，newState可能会在此之前被指定为特定状态）。</span><br><span class="line">    f.mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>具体调用流程和状态切换参见稍后的Fragment生命周期状态一文。</p><h3 id="mHost-1"><a href="#mHost-1" class="headerlink" title="mHost"></a>mHost</h3><p>FragmentManager持有的宿主的引用，在宿主Activity的onCreate中将其传递给了FragmentManager。FragmentManager所有需要回调给宿主的操作/通知，都会通过它来传递。</p><h3 id="mController"><a href="#mController" class="headerlink" title="mController"></a>mController</h3><pre><code>no desc</code></pre><h3 id="mContainer-1"><a href="#mContainer-1" class="headerlink" title="mContainer"></a>mContainer</h3><p>表示FragmentManager所依附的容器，实则依旧是持有的宿主的引用，赋值方式与mHost一致。</p><p>当Fragment是以动态加载的方式关联到宿主时，在FragmentManager的<code>moveTostate(5参)</code>方法的升序<code>Fragment.CREATED</code>分支中，执行Fragment的<code>onCreateView</code>前会先根据Fragment的<code>mContainerId</code>为该Fragment查找其在宿主所依附的视图容器<code>f.mContainer</code>，查找的方式便是通过FragmentManager的<code>mContainer</code>来实现的：<br><code>mContainer</code>调用的<code>onFindViewById(@IdRes)</code>方法内部实则是调用的宿主Activity的对应方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public View onFindViewById(int id) &#123;</span><br><span class="line">    return FragmentActivity.this.findViewById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面涉及到的<code>mContainerId</code>、<code>f.mContainer</code>字段请参见对应的字段详解。</p><h3 id="mParent"><a href="#mParent" class="headerlink" title="mParent"></a>mParent</h3><p>如果Fragment嵌套Fragment的情况，这个<code>mParent</code>指代的就是“父”Fragment。</p><h3 id="sAnimationListenerField"><a href="#sAnimationListenerField" class="headerlink" title="sAnimationListenerField"></a>sAnimationListenerField</h3><p>该字段的引入实是为了修复<code>setHWLayerAnimListenerIfAlpha(...)</code>方法的一个动画监听器方面的BUG。</p><p>Fragment在执行相关动画时，会尝试开启硬件加速特性。当符合硬件加速条件，具体的流程是FragmentManager通过对anim设置动画监听，在动画开始前启用硬件加速并在动画结束时关闭硬件加速。<br>但是这里就存在一个BUG，因为Animation只能设置一个listener，那么在之前的v4版本中由于为开启硬件加速导致anim被重新设置了新的listener，若之前我们手动设置了listener，该listener就会被覆盖而失效。<br>因此<code>sAnimationListenerField</code>是用来反射<code>Animation.class</code>的<code>mListener</code>字段得到我们手动设置的listener，最后在硬件加速重新设置listener时将之前的listener进行了包裹，使其可以正常回调：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void setHWLayerAnimListenerIfAlpha(final View v, Animation anim) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (shouldRunOnHWLayer(v, anim)) &#123;</span><br><span class="line">        AnimationListener originalListener = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sAnimationListenerField == null) &#123;</span><br><span class="line">                sAnimationListenerField = Animation.class.getDeclaredField(&quot;mListener&quot;);</span><br><span class="line">                sAnimationListenerField.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            // 拿到已经存在的listener</span><br><span class="line">            originalListener = (AnimationListener) sAnimationListenerField.get(anim);</span><br><span class="line">        &#125; catch (...) &#123;...&#125; </span><br><span class="line">        ViewCompat.setLayerType(v, ViewCompat.LAYER_TYPE_HARDWARE, null);</span><br><span class="line">        anim.setAnimationListener(new AnimateOnHWLayerIfNeededListener(v, anim, originalListener));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mNeedMenuInvalidate"><a href="#mNeedMenuInvalidate" class="headerlink" title="mNeedMenuInvalidate"></a>mNeedMenuInvalidate</h3><blockquote><p>首先需要查看Fragment的<code>mHasMenu &amp;&amp; mMenuVisible</code>字段详解。</p></blockquote><p>一个是否需要刷新optionsMenu或者说触发optionsMenu流程的标识。  </p><p>每当事务被执行时，即FragmentManager执行add/show/…等操作时，在方法结束的最后都会根据所操作的Fragment的<code>mHasMenu &amp;&amp; mMenuVisible</code>来开启<code>mNeedMenuInvalidate</code>标识。<br>然后当完成add/show/..，对所有Fragment执行moveToState进行整体状态切换后，会根据该标识来决定触发宿主的optionsMenu流程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(4参) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">        Fragment f = mActive.get(i);</span><br><span class="line">        if (f != null) &#123;</span><br><span class="line">            moveToState(f, newState, transit, transitStyle, false);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (mNeedMenuInvalidate &amp;&amp; mHost != null &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class="line">        // 这里：该方法是触发流程的入口</span><br><span class="line">        mHost.onSupportInvalidateOptionsMenu();</span><br><span class="line">        mNeedMenuInvalidate = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mStateSaved"><a href="#mStateSaved" class="headerlink" title="mStateSaved"></a>mStateSaved</h3><h3 id="mDestroyed"><a href="#mDestroyed" class="headerlink" title="mDestroyed"></a>mDestroyed</h3><p>宿主是否执行destroy的标记，当宿主需要被销毁时，其中的FragmentMannager及其所有的Fragment都应该被释放掉。  </p><ul><li>此时若是提交事务便会抛出异常：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mDestroyed || mHost == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Activity has been destroyed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时若是有Fragment正在执行结束/退出动画（<code>mAnimatingAway</code>），会立即结束掉动画并执行动画后的操作，参见Fragment的<code>mAnimatingAway</code>字段详解。</li></ul><h3 id="mNoTransactionsBecause"><a href="#mNoTransactionsBecause" class="headerlink" title="mNoTransactionsBecause"></a>mNoTransactionsBecause</h3><pre><code>ignore.</code></pre><h3 id="mHavePendingDeferredStart"><a href="#mHavePendingDeferredStart" class="headerlink" title="mHavePendingDeferredStart"></a>mHavePendingDeferredStart</h3><p>具体参见Fragment的<code>mDeferStart</code>字段详解。</p><h3 id="mStateBundle"><a href="#mStateBundle" class="headerlink" title="mStateBundle"></a>mStateBundle</h3><p>一个临时Bundle容器。在状态保存机制触发回调Fragment的<code>onSaveInstanceState(Bundle)</code>时，作为该方法的参数用来临时存放Fragment用该方法保存的状态，该步骤执行完成后，该容器便转交给了FragmentManager的对应容器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager#saveAllState() --&gt; fs.mSavedFragmentState = saveFragmentBasicState(f)</span><br><span class="line">Bundle saveFragmentBasicState(Fragment f) &#123;</span><br><span class="line">    Bundle result = null;</span><br><span class="line">    if (mStateBundle == null) &#123;</span><br><span class="line">        mStateBundle = new Bundle();</span><br><span class="line">    &#125;</span><br><span class="line">    // 该方法内部调用`onSaveInstanceState(Bundle)`方法</span><br><span class="line">    f.performSaveInstanceState(mStateBundle);</span><br><span class="line">    if (!mStateBundle.isEmpty()) &#123;</span><br><span class="line">        result = mStateBundle;</span><br><span class="line">        mStateBundle = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mStateArray"><a href="#mStateArray" class="headerlink" title="mStateArray"></a>mStateArray</h3><p>作用类似于上面的<code>mStateBundle</code>字段。同样是在状态保存机制触发，对Fragment的View层级状态进行保存时作为临时容器，然后将得到的状态交给了<code>f.mSavedViewState</code>，最后存放在存放Fragment状态所保存的容器中以<code>FragmentManagerImpl.VIEW_STATE_TAG</code>为key的位置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void saveFragmentViewState(Fragment f) &#123;</span><br><span class="line">    if (f.mInnerView == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mStateArray == null) &#123;</span><br><span class="line">        mStateArray = new SparseArray&lt;Parcelable&gt;();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mStateArray.clear();</span><br><span class="line">    &#125;// 关键代码</span><br><span class="line">    f.mInnerView.saveHierarchyState(mStateArray);</span><br><span class="line">    if (mStateArray.size() &gt; 0) &#123;</span><br><span class="line">        f.mSavedViewState = mStateArray;</span><br><span class="line">        mStateArray = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bundle saveFragmentBasicState(Fragment f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f.performSaveInstanceState(mStateBundle);</span><br><span class="line">    ...</span><br><span class="line">    if (f.mView != null) &#123;// 关键代码</span><br><span class="line">        saveFragmentViewState(f);</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mSavedViewState != null) &#123;</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            result = new Bundle();</span><br><span class="line">        &#125;// 关键代码</span><br><span class="line">        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="mExecCommit"><a href="#mExecCommit" class="headerlink" title="mExecCommit"></a>mExecCommit</h3><p>具体参见mPendingActions字段详解。</p><h2 id="BackStackRecord"><a href="#BackStackRecord" class="headerlink" title="BackStackRecord"></a>BackStackRecord</h2><h3 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h3><p>表示一个对Fragment的操作，BackStackRecord是一个事务，构成事务的便是这1到多个的操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class Op &#123;</span><br><span class="line">    Op next;</span><br><span class="line">    Op prev;</span><br><span class="line">    int cmd;</span><br><span class="line">    Fragment fragment;</span><br><span class="line">    int enterAnim;</span><br><span class="line">    int exitAnim;</span><br><span class="line">    int popEnterAnim;</span><br><span class="line">    int popExitAnim;</span><br><span class="line">    ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从其数据结构来看，一个操作由8部分组成，其中最核心的就是操作的指令<code>cmd</code>以及该操作所要作用的对象<code>Fragment</code>。实际指令共有7种，分别是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final int OP_NULL = 0;// 无效指令</span><br><span class="line">static final int OP_ADD = 1;    // 对应BackStackRecord.add(...)</span><br><span class="line">static final int OP_REPLACE = 2;// 对应BackStackRecord.repalce(...)</span><br><span class="line">static final int OP_REMOVE = 3; // 对应BackStackRecord.remove(...)</span><br><span class="line">static final int OP_HIDE = 4;   // 对应BackStackRecord.hide(...)</span><br><span class="line">static final int OP_SHOW = 5;   // 对应BackStackRecord.show(...)</span><br><span class="line">static final int OP_DETACH = 6; // 对应BackStackRecord.detach(...)</span><br><span class="line">static final int OP_ATTACH = 7; // 对应BackStackRecord.attach(...)</span><br></pre></td></tr></table></figure></p><blockquote><p>其中需要说明的是<code>OP_REPLACE</code>指令，其原理是将已经add到指定<code>container</code>的所有Fragment先执行<code>OP_REMOVE</code>指令，最后再执行OP_ADD将指定的Fragment对象add到该<code>container</code>，因此Op对象的<code>removed</code>集合便是用来记录第一步中被remove的Fragment，该字段在其余cmd中无效。</p></blockquote><p>每种指令对应的入口方法如上所示，它们内部调用的都是 <code>adOp(Op)</code> 方法来将每种操作封装成Op对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void addOp(Op op) &#123;</span><br><span class="line">    if (mHead == null) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    op.enterAnim = mEnterAnim;</span><br><span class="line">    op.exitAnim = mExitAnim;</span><br><span class="line">    op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">    op.popExitAnim = mPopExitAnim;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每个Op对象通过<code>prev</code>和<code>next</code>来记录其上一个和下一个操作分别是什么，由此多个操作便组成了一条双链表。另外，4个形如xxxAnim的字段表示的是该操作关联的动画，它们最终都是被事务对象的相应字段赋值，也就是说，一个事务下的每个操作不能单独指定动画，<strong>动画的最小粒度针对的是单个事务</strong>。动画可以在构建事务时通过方法<code>setCustomAnimations(...)</code>来指定，具体可以参见<code>mEnterAnim</code>等字段的详解。</p><h3 id="mHead-amp-amp-mTail-amp-amp-mNumOp"><a href="#mHead-amp-amp-mTail-amp-amp-mNumOp" class="headerlink" title="mHead &amp;&amp; mTail &amp;&amp; mNumOp"></a>mHead &amp;&amp; mTail &amp;&amp; mNumOp</h3><p>分别表示事务的操作双链表的首部引用、尾部引用以及整个链表的长度，即该事务包含的指令数。</p><h3 id="xxxAnim"><a href="#xxxAnim" class="headerlink" title="xxxAnim"></a>xxxAnim</h3><p>mEnterAnim &amp;&amp; mExitAnim &amp;&amp; mPopEnterAnim mPopExitAnim</p><blockquote><p>v4里使用的是Animation，app里使用的是Animator。</p></blockquote><p>4种动画都是在构造事务时，调用<code>setCustomAnimations(...)</code>来指定的。在构造事务期间，方法<code>addOp(Op)</code>将其赋予到了每个指令Op对应的属性，而设置的动画最终在执行Op指令前（BackStackRecord的run方法或者popFromBackStack方法）都会赋值给<code>fragment.mNextAnim</code>，该属性由FragmentManager的loadAnimation方法调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// transit和transitionStyle是在构造事务时指定的，可以参见其字段详解</span><br><span class="line">Animation loadAnimation(Fragment fragment, int transit, boolean enter, int transitionStyle) &#123;</span><br><span class="line">    // onCreateAnimation可以实现返回自定义动画，算是一个系统提供的HOOK方法</span><br><span class="line">    Animation animObj = fragment.onCreateAnimation(transit, enter, fragment.mNextAnim);</span><br><span class="line">    if (animObj != null) &#123;</span><br><span class="line">        return animObj;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当然如果我们未实现上述方法，默认还会尝试读取指定的资源动画文件</span><br><span class="line">    if (fragment.mNextAnim != 0) &#123;</span><br><span class="line">        Animation anim = AnimationUtils.loadAnimation(mHost.getContext(), fragment.mNextAnim);</span><br><span class="line">        if (anim != null) &#123;</span><br><span class="line">            return anim;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 其它：由transit指定的几个特定动画</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>onCreateAnimation很重要，可以自定义一个Animation对象返回。</li><li>loadAnimation优先使用fragment.mNextAnim指定的动画。</li></ol></blockquote><p>而loadAnimation被调用的时机共有2种：show/hideFragment、创建/销毁视图。<br>当执行<code>showFragment</code>或者在生命周期<code>onCreateView与onViewCreated之间</code>（仅限<strong>动态方式</strong> 创建的Fragment），enterAnim/popEnetrAnim会执行；当执行<code>hideFragment</code>或者在生命周期<code>onDestroyView与onDestroy之间</code>，exitAnim/popExitAnim会执行。<br>具体是执行mEnterAnim还是mPopEnterAnim或者mExitAnim还是mPopExitAnim，这与操作是否由出栈触发有关。  如果是执行事务时（<code>run()</code>），在上述的时机中，执行的是mEnterAnim和mExitAnim；而当出栈时（<code>popFromBackStack(···)</code>），上述时机执行的动画则变成了mPopEnterAnim和mPopExitAnim，并且两种情况都会覆盖为最新动画，因此在正常生命周期走到销毁或重建时，所触发的动画为最近一次改变的动画。</p><p>最后，在每次执行动画时，FragmentManager还是尝试对其启用 <strong>硬件加速</strong> 特性，具体可以参见FragmentManager的<code>sAnimationListenerField</code>字段详解。</p><h3 id="mTransition-amp-amp-mTransitionStyle"><a href="#mTransition-amp-amp-mTransitionStyle" class="headerlink" title="mTransition &amp;&amp; mTransitionStyle"></a>mTransition &amp;&amp; mTransitionStyle</h3><blockquote><p>mTransitionStyle仅在app.Fragment下有效，此处不分析。</p></blockquote><p>在Fragment动画层面，mTransition 作为上面<code>mEnterAnim</code>等动画外的可选的补充，用以指定系统实现的3种类型共计6种实现的动画，可以在构造事务期间通过<code>setTransition(int)</code>来指定。</p><p>3种动画的取值分别是：<br><code>FragmentTransaction.TRANSIT_FRAGMENT_OPEN</code>、<br><code>FragmentTransaction.TRANSIT_FRAGMENT_CLOSE</code>、<br><code>FragmentTransaction.TRANSIT_FRAGMENT_FADE</code> ，<br>前两种都是一个由ScaleAnimation和AlphaAnimation组合成的AnimationSet动画，最后一种是一个单独的AlphaAnimation动画。</p><p>作为补充动画，mTransition传递流程、触发时机与<code>mEnterAnim</code>等动画一模一样，而具体是选择<code>mEnterAnim</code>等动画还是mTransition，最终是由FragmentManager的loadAnimation方法来决定的，在<code>mEnterAnim</code>等动画字段的分析中，我们得出的结论是：首选由<code>mEnterAnim</code>等指定的动画，仅当它们没有指定，才会从transit中查找：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Animation loadAnimation(Fragment fragment, int transit, boolean enter, int transitionStyle) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (transit == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据enter取值，将3种类型具体分为了6种动画，选取其中一种返回</span><br><span class="line">    int styleIndex = transitToStyleIndex(transit, enter);</span><br><span class="line">    if (styleIndex &lt; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据动画索引生成具体的animation对象</span><br><span class="line">    switch (styleIndex) &#123;</span><br><span class="line">        case ANIM_STYLE_OPEN_ENTER:</span><br><span class="line">            return makeOpenCloseAnimation(mHost.getContext(), 1.125f, 1.0f, 0, 1);</span><br><span class="line">        case ANIM_STYLE_OPEN_EXIT:</span><br><span class="line">            return makeOpenCloseAnimation(mHost.getContext(), 1.0f, .975f, 1, 0);</span><br><span class="line">        case ANIM_STYLE_CLOSE_ENTER:</span><br><span class="line">            return makeOpenCloseAnimation(mHost.getContext(), .975f, 1.0f, 0, 1);</span><br><span class="line">        case ANIM_STYLE_CLOSE_EXIT:</span><br><span class="line">            return makeOpenCloseAnimation(mHost.getContext(), 1.0f, 1.075f, 1, 0);</span><br><span class="line">        case ANIM_STYLE_FADE_ENTER:</span><br><span class="line">            return makeFadeAnimation(mHost.getContext(), 0, 1);</span><br><span class="line">        case ANIM_STYLE_FADE_EXIT:</span><br><span class="line">            return makeFadeAnimation(mHost.getContext(), 1, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>另外，再次强调一遍：所有动画仅针对以动态方式创建的Fragment。</p></blockquote><h3 id="mAddToBackStack"><a href="#mAddToBackStack" class="headerlink" title="mAddToBackStack"></a>mAddToBackStack</h3><p>在mAllowAddToBackStack为TRUE的前提下（默认就是TRUE），当我们在构建事务时调用了<code>addToBackStack(String)</code>方法，那么mAddToBackStack就会被置为TRUE。</p><p>当在后续的提交/执行事务时，会根据该字段来决定是否为事务分配<code>mIndex</code>、是否需要加入回退栈、是否需要刷新<code>mBackStackNesting</code>（参见Fragment的mBackStackNesting字段详解）</p><h3 id="mAllowAddToBackStack"><a href="#mAllowAddToBackStack" class="headerlink" title="mAllowAddToBackStack"></a>mAllowAddToBackStack</h3><p>表示当前事务是否被允许“保存”到回退栈，默认为TRUE即允许提交事务前调用BackStackRecord的<code>addToBackStack(String)</code>方法，如果调用了该方法，最后在执行完该事务时(<code>run()</code>)，<code>mManager.addBackStackState(this)</code>会将其添加到回退栈集合。<br>如果我们提交事务采用的是<code>commitNowXXX</code>方法，即允许提交的事务立即执行，那么该事务就不被允许添加到回退栈中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void commitNowXXX() &#123;</span><br><span class="line">        disallowAddToBackStack();</span><br><span class="line">        mManager.execSingleAction(this, boolean);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><code>disallowAddToBackStack()</code>将<code>mAllowAddToBackStack</code>字段置为了FALSE，该方法与<code>addToBackStack(String)</code>互斥，禁止同时调用否则将抛出异常。</p><h3 id="mName"><a href="#mName" class="headerlink" title="mName"></a>mName</h3><p>一个可选字段，用以标识一个事务，不同的事务可以有相同的name，不会状态丢失。它是在构造事务期间调用<code>addToBackStack(String name)</code>入栈时传入的。</p><p>如果name存在，那么在稍后需要出栈时，可以根据该字段指定出栈的最终位置（参见BackStackRecord的出栈入栈分析一文）。</p><h3 id="mCommitted"><a href="#mCommitted" class="headerlink" title="mCommitted"></a>mCommitted</h3><p>一个防止同一事务被多次提交的变量。</p><h3 id="mIndex-1"><a href="#mIndex-1" class="headerlink" title="mIndex"></a>mIndex</h3><p>仅对加入了回退栈的事务有效，用以标识该事务的唯一性，也可称ID，否则-1。</p><p>该字段的主要作用是为了出栈。具体体现为：由于回退栈中每个事务都有自己的唯一ID，因此在需要出栈时，可以根据该字段来指定出栈的终点（参见BackStackRecord的出栈入栈分析一文）。</p><p>对于一个要加入回退栈的事务，在commit时该事务会被分配一个唯一标识的ID：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int commitInternal(boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mIndex = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(this, allowStateLoss);</span><br><span class="line">    return mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>allocBackStackIndex在将事务加入回退栈的同时会返回事务对应的ID，这个ID是由当前回退栈存在的事务元素个数决定的（非null），具体可以参见FragmentManager的mAvailBackStackIndices字段详解。</p><h3 id="xxxBreadCrumbxxx"><a href="#xxxBreadCrumbxxx" class="headerlink" title="xxxBreadCrumbxxx"></a>xxxBreadCrumbxxx</h3><p>mBreadCrumbTitleRes &amp;&amp; mBreadCrumbTitleText &amp;&amp; mBreadCrumbShortTitleRes &amp;&amp; mBreadCrumbShortTitleText</p><p>形如文件管理器里面的路径排列的层级样式我们称作“Bread Crumb”。<br>例如：<code>··· &gt; aaa &gt; bbbb &gt; ccc &gt; ···</code>，点击aaa等按钮可以显示对应目录下的视图。</p><p>Android提供了一个叫做FragmentBreadCrumbs的类，该类是一个自定义ViewGroup，基本原理是利用Fragment的栈来实现上面的“Bread Crumb”，BreadCrumb的点击事件触发入/出栈、栈的更新事件又触发BreadCrumbs的更新。因此<code>BreadCrumbTitle</code>、<code>BreadCrumbShortTitle</code>可以理解为存在于回退栈中的事务对应的title/subtitle，例如这里可以表示目录名。</p><p>但是从API21开始，可能是不符合MD设计模式的原因，该类被<code>@Deprecated</code>了。因此，这里的mBreadCrumbTitleRes等字段就基本没有存在的意义了。</p>]]></content>
    
    <summary type="html">
    
      Fragment、FragmentManager以及BackStackRecord是Fragment组件包中最主要的三个类，几乎包含了Fragment体系中所有的功能和知识点。从主流使用流程出发的源码分析对解决问题快速有效，但是一段时间后其中细节点可能就会慢慢的遗忘，只剩下一个感性的认知。本篇从字段入手，对这三个类的所有字段从含义、作用、使用方式以及所涉及的额外知识点几个方面的进行了详细的分析记录，有利于对源码分析和回顾，甚至完全可以当作一本字段参考字典。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://linjiang.tech/tags/Fragment/"/>
    
      <category term="字段解析" scheme="https://linjiang.tech/tags/%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Fragment】对Fragment的BackStackRecord事务的分析</title>
    <link href="https://linjiang.tech/2017/01/21/Fragment-BackStackRecord/"/>
    <id>https://linjiang.tech/2017/01/21/Fragment-BackStackRecord/</id>
    <published>2017-01-21T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>继承于FragmentTransaction类的BackStackRecord是一系列对Fragment进行<code>attach、add、replace、show、hide、remove、detach、anims</code>操作的集合，我们称之为事务。事务减少了对Fragment的代码操作量，并且当事务被执行时，“批处理”极大地提升了处理效率。<br>事务同时提供了一个“保存”(<code>addToBackStack(String)</code>)的概念，如果将提交的事务“保存”，那么“保存”的事务构成的集合就称为“回退栈(<code>BackStack</code>)”，“保存”也可以称为“入栈”。<br>回退栈的引出，使得Fragment拥有了类似于Activity栈的概念，意味着FragmentManager可以将呈现状态回到之前的某一个事务执行的结果，我们将这种特性称为“出栈”。</p><h2 id="构建事务"><a href="#构建事务" class="headerlink" title="构建事务"></a>构建事务</h2><p>BackStackRecord内部拥有一个静态类Op，代表着对一个操作的封装：包括了操作的指令cmd、操作的对象Fragment以及多个Op之间的先后顺序关系（next、prev）等。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以参见Op的字段详解</span><br><span class="line">static final class Op &#123;</span><br><span class="line">    Op next;</span><br><span class="line">    Op prev;</span><br><span class="line">    int cmd;</span><br><span class="line">    Fragment fragment;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>next、prev</code>的存在将事务包含的操作集合定义为了一种双链表的结构，这种结构是有必要的，它既能保证事务提交后操作执行的严格的先后顺序，还可以非常方便的进行“反向”读取或操作，也就是我们所说的“出栈”。</p><p>对Fragment的操作一共有7种，分别是<code>attach、add、replace、show、hide、remove、detach</code>，BackStackRecord提供了相应的Op封装方法和指令来对应，例如add操作对应的三个重载方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FragmentTransaction add(Fragment fragment, String tag);</span><br><span class="line">public FragmentTransaction add(int containerViewId, Fragment fragment);</span><br><span class="line">public FragmentTransaction add(int containerViewId, Fragment fragment, String tag);</span><br></pre></td></tr></table></figure><br>从参数来看，Fragment不一定需要依附到宿主的视图容器，并且我们还可以为add的Fragment指定一个tag来标识，可见这些方法不仅仅只是用来封装对应的操作，还展示了操作的使用规则。<br>三个方法的内部都调用了<code>doAddOp</code>方法并传入了<code>OP_ADD</code>指令，在<code>doAddOp</code>方法中，除了对参数的预检外，例如检查Fragment是否是一个静态的公共类、是否已经被add过等，最主要的操作便是构造Op对象来封装操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Op op = new Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Op的构建就是简单的初始化一个Op对象，并关联对应的操作指令及操作对象Fragment。其实对于其余的操作，也都是利用的这样的构建方式来生成自己的Op对象，这也体现出事务是用来封装操作的集合而不是用来执行操作这样的特性。</p><p>得到每种操作对应的Op对象后，最后一步便是将这些Op“串”起来，所有操作的入口方法流程最终都会来到addOp(Op)方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void addOp(Op op) &#123;</span><br><span class="line">    if (mHead == null) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    op.enterAnim = mEnterAnim;</span><br><span class="line">    op.exitAnim = mExitAnim;</span><br><span class="line">    op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">    op.popExitAnim = mPopExitAnim;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法将每个封装好的Op对象添加到了链表的尾部，并且将每个Op对象的前后引用都指向了它的上一个和下一个操作构成了前面提到的双链表。<br>另外，事务提供了一个链表头mHead和链表尾mTail，这样当每次需要使用这些操作时，只要拿到双链表的表头或表尾就可以遍历到任何操作。<br>除了封装操作外，事务还提供了一些额外的功能例如：为当前事务指定进入/出栈等动画、为事务添加共享元素、将事务指定为加入回退栈等，可以参见对应的字段详解。</p><p>了解了事务提供了哪些功能以及这些功能内部是如何封装为Op对象后，要构造一个事务就很容易了。由此我们可以得出一个事务构造的大致模板：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Activity.this.getSupportFragmentManager().beginTransaction()</span><br><span class="line">            .attach(fragment)</span><br><span class="line">            .add(fragment, containerId, tag)</span><br><span class="line">            .show(fragment)</span><br><span class="line">            .replace(containerId, fragment, tag)</span><br><span class="line">            .hide(fragment)</span><br><span class="line">            .remove(fragment)</span><br><span class="line">            .detach(fragment)</span><br><span class="line">            .commit();</span><br></pre></td></tr></table></figure></p><h2 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h2><p>根据是否允许事务立即执行和是否允许事务忽略状态丢失的风险，提交事务分为了4种方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int commit();</span><br><span class="line">public int commitAllowingStateLoss();</span><br><span class="line">public void commitNow();</span><br><span class="line">public void commitNowAllowingStateLoss();</span><br></pre></td></tr></table></figure><br>其中方法名<code>不带now</code>的方法表示所提交的事务不需要立即执行；方法名<code>带AllowingStateLoss</code>的方法表示允许事务 <strong>提交时</strong> （对于now就是执行时）忽略状态丢失的风险。</p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>不需要立即执行的提交方法内部都调用了<code>commitInternal</code>方法，对于事务，该方法又将其交给了FragmentManager的<code>enqueueAction</code>方法处理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mPendingActions.add(action);</span><br><span class="line">        if (mPendingActions.size() == 1) &#123;</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">            mHost.getHandler().post(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>enqueueAction</code>直接将事务添加到了<code>等待集合mPendingActions</code>中，并在<code>等待集合</code>只有1个事务时向消息池post了一个回调任务（<code>mExecCommit</code>）。可以看到，这种方案的内部是采用Handler机制来实现的。  </p><p>Handler机制中存在一个消息池、一个不断循环读取分发消息池中的消息的Looper以及提交消息到消息池/处理Looper分发的消息的Handler，主线程中所有的操作都是由主线程的各个Handler提交并处理的，包括Activity生命周期的回调、View触摸事件的分发等。虽然消息池是一个队列结构且仅有一个主线程，使得每次只能处理一个消息，但是由于主线程的耗时机制，使得每个消息都必须在极短的时间内处理完成，因此我们平时所提交的消息都能“立即”执行，但其执行时机早已不是当时提交消息的那一刻了。  </p><p>既然提交的事务不能立即执行，为什么又提供了这种提交方式？  </p><p>这其实是为了效率。我们不可避免的会在同一时间提交多个事务，而事务的执行有相当部分是存在重复性的操作的，如果立即执行，对资源的消耗是可观的，为了避免这种情况，FragmentManager提供了<code>mPendingActions</code>字段来结合Handler实现该方案。<br><code>mPendingActions</code>是一个Runnable集合，我们通过该方案提交的事务都被添加到了该集合，从上面的源码中可以看到，只要这个集合中一有事务，便立即利用宿主的Handler提交了一个回调任务（<code>mExecCommit</code>）到主线程的消息池中，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable mExecCommit = new Runnable() &#123;</span><br><span class="line">    @Override public void run() &#123; execPendingActions(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>并在该操作之前调用removeCallbacks来保证回调任务mExecCommit未被处理前在消息池中的唯一性。<br>依据上面简述的Handler机制它并不会立即被处理，那么在mExecCommit还未被Looper从消息池中取出处理前，同一时间提交的多个事务就会被添加到<code>mPendingActions</code>中，之后当mExecCommit被回调，便触发<code>execPendingActions()</code>方法的执行，其内部实现是遍历<code>mPendingActions</code>，调用每个事务的run方法，这也就是所谓的触发执行事务：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean execPendingActions() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 先决条件验证：是否正在执行、是否在主线程</span><br><span class="line">    ...</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int numActions;</span><br><span class="line">        // 同步操作，防止例如其它线程提交事务与当前主线程都同时操作mPendingActions的情况</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mPendingActions == null || mPendingActions.size() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            numActions = mPendingActions.size();</span><br><span class="line">            if (mTmpActions == null || mTmpActions.length &lt; numActions) &#123;</span><br><span class="line">                mTmpActions = new Runnable[numActions];</span><br><span class="line">            &#125;</span><br><span class="line">            // 批量转交给mTmpActions，</span><br><span class="line">            // 以让mPendingActions在事务执行期间有能力继续接收可能提交的事务</span><br><span class="line">            mPendingActions.toArray(mTmpActions);</span><br><span class="line">            mPendingActions.clear();</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutingActions = true;</span><br><span class="line">        // 核心：依次调用run执行累积的事务</span><br><span class="line">        for (int i=0; i&lt;numActions; i++) &#123;</span><br><span class="line">            mTmpActions[i].run();</span><br><span class="line">            mTmpActions[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutingActions = false;</span><br><span class="line">        didSomething = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="commitNow"><a href="#commitNow" class="headerlink" title="commitNow"></a>commitNow</h3><p>立即执行的提交方案则没有commit方式的那样复杂的流程，因为是提交就立刻执行，所以不需要“等待集合”、不需要Handler，它更像一个精简版的“同步”<code>commit</code>，在提交后就立刻调用了FragmentManager的<code>execSingleAction</code>方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void execSingleAction(Runnable action, boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 重复性提交拦截、主线程验证、状态丢失检查</span><br><span class="line">    ...</span><br><span class="line">    mExecutingActions = true;</span><br><span class="line">    action.run();</span><br><span class="line">    mExecutingActions = false;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>execSingleAction</code>对于事务仅仅只是调用其run方法，由此可知，如果事务的个数、复杂度是可知可控的，相较于commit，commitNow方案是一个不错的选择。</p><p><code>commitNow</code>是support包v24新增的API，在此之前如果我们想让当前提交的事务立即得到执行，只能曲折地在调用commit后立即调用<code>executePendingTransactions</code>方法，该方法会直接执行上面的<code>execPendingActions</code>方法。但是这样也导致之前commit的但是还未执行的事务即<code>mPendingActions</code>集合中的所有事务也会被执行。在某些情况，可能这并不是我们想得到的结果。</p><h3 id="AllowingStateLoss"><a href="#AllowingStateLoss" class="headerlink" title="AllowingStateLoss"></a>AllowingStateLoss</h3><p>任何事务的执行都会引起FragmentManager内相关状态的改变，所以对每个提交的事务作状态丢失检查以确保在触发状态保存机制时能被正确地保存到状态是有必要的，除非我们认定所提交的事务引发的改变在状态保存机制被触发期间未被保存也无伤大雅。</p><p>以禁止状态丢失为例，检查状态具体来说就是在提交后准备期间的对应方法在中，调用了以下代码段来检查状态丢失：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!allowStateLoss) &#123;checkStateLoss();&#125;</span><br></pre></td></tr></table></figure><br>方法名<strong>带AllowingStateLoss</strong>的方法将<code>allowStateLoss</code>字段置为了TRUE，而<code>checkStateLoss</code>方法则根据<code>mStateSaved、mNoTransactionsBecause</code>两个字段来决定是否抛出异常来终止操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void checkStateLoss() &#123;</span><br><span class="line">    if (mStateSaved) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Can not perform this action after onSaveInstanceState&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mNoTransactionsBecause != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Can not perform this action inside of &quot; + mNoTransactionsBecause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mStateSaved"><a href="#mStateSaved" class="headerlink" title="mStateSaved"></a>mStateSaved</h4><p><code>mStateSaved</code>标识了宿主Activity下的整个Fragment体系是否已经发生了状态保存并且还未恢复，该字段在方法saveAllSate中被置为了TRUE（仅在版本大于3.0时，具体可以参见Fragment的状态保存和恢复一文），在分发其它生命周期例如create、resume等被置为FALSE（除stop外）。  </p><p>由于该字段仅作为<code>checkStateLoss()</code>方法的判断依据，所以为了保证事务提交时机的正确性（即不允许在stop及之后提交事务），在Activity分发stop生命周期的时候也将<code>mStateSaved</code>置为了TRUE，而不管状态保存方法是否已被触发过了。</p><h4 id="mNoTransactionsBecause"><a href="#mNoTransactionsBecause" class="headerlink" title="mNoTransactionsBecause"></a>mNoTransactionsBecause</h4><p><code>mNoTransactionsBecause</code>是一个String字段，在LoaderManager回调<code>onLoadFinished()</code>和<code>onLoaderReset()</code>方法时期会被赋值，由于Loader的异步机制，回调可能发生在Fragment的任何时期，包括在状态保存之后，所以这里干脆以一个显式的异常来提示我们来规避在上述两个回调中提交事务。</p><p>只要保证了提交事务时状态保存机制还未触发，那么在接下来事务是否已经执行已经不重要了，因为在触发状态保存机制导致FragmentManager的saveAllState方法执行时，会先确保还未执行的事务全部得到执行，因此在调用事务的run之前并不需要检查状态是否丢失的情况。</p><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><p>事务的另外一个很重要的特性便是“回退栈”概念。“入栈”开关是在事务构造期间调用addToBackStack方法开启的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public FragmentTransaction addToBackStack(String name) &#123;</span><br><span class="line">    if (!mAllowAddToBackStack) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;This FragmentTransaction is not allowed to be added to the back stack.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mAddToBackStack = true;</span><br><span class="line">    mName = name;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法开启了<code>mAddToBackStack</code>外，还可以为加入回退栈的当前事务指定一个name标识，方便后面出栈时指定出栈结果，两个字段具体都可以查看对应字段的详解。<br><code>mAllowAddToBackStack</code>字段表示允许事务添加到回退栈，默认情况是TRUE，该字段存在的意义主要是为<code>commitNow</code>服务的，具体可以查看该字段的详解。这里需要弄清楚的是为什么通过<code>commitNow</code>提交的事务不被允许添加到回退栈？<br>这和两种提交执行的时机有关，由于commit方式提交的事务并没有立即执行，有可能在得到执行前又有几个事务被提交到了“等待集合”中，但是不论怎么样，它们都会按照提交顺序一次得到执行；但是对于commitNow方式，如果允许该方式提交的事务添加到回退栈，由于是立即执行，那么该事务在执行完成后就立刻被添加到了回退栈，但是此时仍有可能存在以commit方式提交但还未执行的的事务，这样就打乱了提交顺序与回退栈中元素顺序的一一对应关系，回退栈中元素顺序不一，那么在出栈时就存在回不到某个事务执行结果的情况，回退栈失去了存在意义。</p><p>继续分析，开启mAddToBackStack后，事务一旦被提交（以commit方式），在内部方法<code>commitInternal</code>中，首先会为该事务分配一个index，该字段是一个唯一标识，可以根据该字段精确地定位到回退栈中某个具体的事务，当然，和name字段一样，也可以作为出栈时方便指定出栈结果，与name不同的是，index是唯一的，而name可以重复或为null：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int commitInternal(boolean allowStateLoss) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mIndex = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(this, allowStateLoss);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>分配index就是allocBackStackIndex方法来完成的，可以参见FragmentManager的mAvail<code>BackStackIndices</code>字段详解，解释了为何index便是该事务在回退栈中对应的元素位置。</p><p>接下来在事务开始执行的方法<code>run()</code>中，才是事务真正被添加到回退栈的实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>方法addBackStackState只做了两件事：将事务添加的回退栈链表中，回调回退栈变化事件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addBackStackState(BackStackRecord state) &#123;</span><br><span class="line">    if (mBackStack == null) &#123;</span><br><span class="line">        mBackStack = new ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mBackStack.add(state);</span><br><span class="line">    reportBackStackChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到处，事务才算真正地入栈了，也就意味着FragmentManager可以将呈现状态回到之前的某一个事务执行的结果，具体在稍后的出栈章节中具体分析。</p><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>出栈一共有3种方式，分别是pop当前栈回到上一个事务的<code>popBackStack()</code>、pop到指定ID的对应事务为止的<code>popBackStack(id, flags)</code>以及pop到指定name的对应事务为止的<code>popBackStack(name, flags)</code>，注意，这里的<code>pop到指定name/id的对应事务为止</code>表示回到该事务执行的对应结果，将栈中该事务以上的事务全部出栈（默认条件下，未开启Flag）；</p><p>并且根据提交的及时性，FragmentManager一共提供了6个入口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">popBackStack()</span><br><span class="line">popBackStackImmediate()</span><br><span class="line">popBackStack(final String name, final int flags)</span><br><span class="line">popBackStackImmediate(String name, int flags)</span><br><span class="line">popBackStack(final int id, final int flags)</span><br><span class="line">popBackStackImmediate(int id, int flags)</span><br></pre></td></tr></table></figure><br>形如<code>xxxImmediate(xxx)</code>的方式表示会立即执行出栈操作，反之其余的是将整个操作提交给了Handler，在下一次事件轮询中才会被执行，与提交事务的几种方式类似。而所有方法内部的核心实现，都是转发给了FragmentManager的<code>popBackStackState(handler, name, id, flags)</code>方法。</p><h3 id="FragmentManager-popBackStackState"><a href="#FragmentManager-popBackStackState" class="headerlink" title="FragmentManager#popBackStackState"></a>FragmentManager#popBackStackState</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">boolean popBackStackState(Handler handler, String name, int id, int flags) &#123;</span><br><span class="line">    if (mBackStack == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 该分支表示第一种出栈方式：pop最上层栈，没有指定任何有效参数</span><br><span class="line">    if (name == null &amp;&amp; id &lt; 0 &amp;&amp; (flags&amp;POP_BACK_STACK_INCLUSIVE) == 0) &#123;</span><br><span class="line">        int last = mBackStack.size()-1;</span><br><span class="line">        if (last &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        final BackStackRecord bss = mBackStack.remove(last);</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line">        if (mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">            // 根据Op双链表从尾至头开始为firstOutFragments和lastInFragments填充数据</span><br><span class="line">            // 原则：如果是add/relpace/show，则添加至firstOut；反正lastIn</span><br><span class="line">            // firstOutFragments和lastInFragments主要是为了执行API21以上的过渡动画和共享元素</span><br><span class="line">            bss.calculateBackFragments(firstOutFragments, lastInFragments);</span><br><span class="line">        &#125;</span><br><span class="line">        // 开始真正的pop栈</span><br><span class="line">        // 由于只pop了一个元素，所以第一个参数为true，表示pop后就可以开始move-state</span><br><span class="line">        bss.popFromBackStack(true, null, firstOutFragments, lastInFragments);</span><br><span class="line">        // 最后，如果addOnBackStackChangedListener，这里会进行回调。</span><br><span class="line">        reportBackStackChanged();</span><br><span class="line">    &#125; else &#123;// else分支表示调用的方法是除了第一种外</span><br><span class="line">        int index = -1;</span><br><span class="line">        // 表示出栈方法指定了name或id任中一个</span><br><span class="line">        if (name != null || id &gt;= 0) &#123;</span><br><span class="line">            index = mBackStack.size()-1;</span><br><span class="line">            // 开始从栈顶向栈底遍历当前所有的栈，找出符合条件的栈，只要匹配一个就停止</span><br><span class="line">            while (index &gt;= 0) &#123;</span><br><span class="line">                BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">                if (name != null &amp;&amp; name.equals(bss.getName())) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (id &gt;= 0 &amp;&amp; id == bss.mIndex) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前集合中为空或没有指定条件的事务，直接返回</span><br><span class="line">            if (index &lt; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指定了POP_BACK_STACK_INCLUSIVE这个FLAG，则继续遍历</span><br><span class="line">            // 如果在当前栈下还有N个连续的具有相同name或ID的事务，则记下最后一个匹配的事务</span><br><span class="line">            if ((flags&amp;POP_BACK_STACK_INCLUSIVE) != 0) &#123;</span><br><span class="line">                // 注意这里首先进行了减1操作，意味着即使下面的while没有找到直接break了，</span><br><span class="line">                // 也会将当前匹配的事务进行pop</span><br><span class="line">                index--;</span><br><span class="line">                // Consume all following entries that match.</span><br><span class="line">                while (index &gt;= 0) &#123;</span><br><span class="line">                    BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">                    if ((name != null &amp;&amp; name.equals(bss.getName()))</span><br><span class="line">                            || (id &gt;= 0 &amp;&amp; id == bss.mIndex)) &#123;</span><br><span class="line">                        index--;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 表示指定name/id的事务正好是当前所处的栈即最上层，并且没有指定FLAG，那么不需要执行任何操作</span><br><span class="line">        if (index == mBackStack.size()-1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        final ArrayList&lt;BackStackRecord&gt; states = new ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">        // 从栈顶向下开始收集集合中位于匹配的栈之上的所有事务，供下面出栈操作使用</span><br><span class="line">        for (int i=mBackStack.size()-1; i&gt;index; i--) &#123;</span><br><span class="line">            states.add(mBackStack.remove(i));</span><br><span class="line">        &#125;</span><br><span class="line">        final int LAST = states.size()-1;</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line">        if (mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">            for (int i = 0; i &lt;= LAST; i++) &#123;</span><br><span class="line">                // 同if分支，遍历填充与过渡动画和共享元素相关的firstOutFragments、lastInFragments集合</span><br><span class="line">                states.get(i).calculateBackFragments(firstOutFragments, lastInFragments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BackStackRecord.TransitionState state = null;</span><br><span class="line">        for (int i=0; i&lt;=LAST; i++) &#123;</span><br><span class="line">            // 遍历前面收集的需要pop的事务集合states，执行真正的pop</span><br><span class="line">            // i == LAST表示执行完所有事务的pop后，再通知FragmentManager进行统一的状态切换move-state</span><br><span class="line">            state = states.get(i).popFromBackStack(i == LAST, state,</span><br><span class="line">                    firstOutFragments, lastInFragments);</span><br><span class="line">        &#125;</span><br><span class="line">        // 同if分支，通知Listener</span><br><span class="line">        reportBackStackChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依上流程，在返回栈中有元素的前提下，该方法一共包含了4个步骤，依次是：(1)找出此次出栈所要呈现的执行结果对应的终点事务；(2)在终点事务之前的事务集合中根据每个事务的Op链表从尾至头开始为firstOutFragments和lastInFragments填充数据以供API21后的设备执行过渡动画和共享元素操作；(3)执行popFromBackStack操作：执行动画并将终点事务之前的事务集合从栈顶向下依次真正出栈；(4)最后回调通知回退栈的改变事件。我们将一一进行分析。在分析第一个步骤前，我们先解释下<code>POP_BACK_STACK_INCLUSIVE</code>的含义。</p><h3 id="POP-BACK-STACK-INCLUSIVE"><a href="#POP-BACK-STACK-INCLUSIVE" class="headerlink" title="POP_BACK_STACK_INCLUSIVE"></a>POP_BACK_STACK_INCLUSIVE</h3><p>在使用<code>popBackStack(id, flags)</code>、<code>popBackStack(name, flags)</code>时，从源码中第一个while语句可以看出，该flag仅针对我们指定了name/id参数，且回退栈中存在指定name/id对应的事务的情况。</p><p>该Flag开启后，两个方法在 回退栈中存在<strong>name续相同</strong>的事务 的情况时（因为ID是唯一的），执行的结果是将栈内匹配到的最靠近栈底的事务及其之上的所有事务全部出栈，也就是说最后呈现的是靠近栈底的事务的下面一个事务执行的对应结果；<br>即使回退栈中不存在name连续相同（注意，这并不代表不存在name/id对应的事务）的事务的情况，<code>popBackStack(id, flags)</code>、<code>popBackStack(name, flags)</code>最后呈现的也是指定name/id的对应事务的下面一个事务执行的对应结果。</p><h3 id="查找终点事务"><a href="#查找终点事务" class="headerlink" title="查找终点事务"></a>查找终点事务</h3><p>这个“终点”也就是我们此次出栈的目的：回到该事务对应的执行结果。终点的确定依据我们是否指定了参数name/id、参数是否存在以及是否开启了flag（指定flag为<code>POP_BACK_STACK_INCLUSIVE</code>）：</p><ul><li><p>未指定任何参数</p><p>  表示我们使用的是<code>popBackStack()</code>方法。那么终点就是栈顶的下一个事务<code>mBackStack.size()-2</code>。</p></li><li><p>指定了 <strong>“空”</strong> 的name/id</p><p>  “空”指的是我们使用的是<code>popBackStack(null, flag)</code>、<code>popBackStack(-1, flag)</code>，如果此时未开启flag，则满足以下条件：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (name == null &amp;&amp; id &lt; 0 &amp;&amp; (flags&amp;POP_BACK_STACK_INCLUSIVE) == 0)</span><br></pre></td></tr></table></figure><p>  这种情况就和上面“未指定任何参数”的情况是一样的；但如果我们开启了flag，那么终点就是-1，意味着整个回退栈的事务都将被出栈，失去执行效果。</p></li><li><p>指定了<strong>存在</strong>的name/id</p><p>  “存在”的意思就是回退栈中存在name/id对应的事务（1个或多个，id无多个）。在未开启flag的情况下，终点就是栈中从顶向下匹配到的第一个事务；一旦开启了flag，终点就会有另外两种可能：如果回退栈中存在<strong>name连续相同</strong>的事务，终点就是第一串连续相同name事务集中从顶向下匹配到的最后一个事务index的下一个事务，也就是index-1；如果不存在连续相同的，那么终点就是匹配到的第一个事务index的下一个事务——index-1。</p><p>  最后，如果index-1等于-1，那么情况就和上面“指定了空的name/id”一样。</p></li><li><p>指定了<strong>不存在</strong>的name/id</p><p>  “不存在”的意思就是：我们指定了name/id，但是回退栈中并没有与之匹配的事务，注意与“空”的区别。这种情况下，在查找完成后由于未找到，源码中就直接return了，意味着方法执行不会改变任何结果。</p></li></ul><h3 id="填充firstOutFragments和lastInFragments"><a href="#填充firstOutFragments和lastInFragments" class="headerlink" title="填充firstOutFragments和lastInFragments"></a>填充firstOutFragments和lastInFragments</h3><blockquote><p>这一节与Transition动画相关，不影响整体的出栈流程，可以跳过。</p></blockquote><p>查找到终点事务后，就需要将终点之前的事务全部执行除栈操作。但是由于API21开始引入了Transition的概念，所以对于Fragment，在出栈前还需要执行Transition动画。这一步就是为场景过渡（共享元素）动画作准备。</p><p>所谓的准备就是找出所有需要出栈的这些事务在即将出栈时总体上在每一个与Fragment相关的视图容器(conatainer)中，第一个被remove和最后被added的Fragment分别是哪个。<code>BackStackRecord#calculateBackFragments</code>会从每个事务的链表尾部开始遍历，根据以下原则来填充firstOutFragments和lastInFragments：</p><table><thead><tr><th>op.cmd</th><th>调用方法</th></tr></thead><tbody><tr><td>OP_ADD</td><td>setFirstOut</td></tr><tr><td>OP_REPLACE</td><td>setFirstOut</td></tr><tr><td>OP_REMOVE</td><td>setLastIn</td></tr><tr><td>OP_HIDE</td><td>setLastIn</td></tr><tr><td>OP_SHOW</td><td>setFirstOut</td></tr><tr><td>OP_DETACH</td><td>setLastIn</td></tr><tr><td>OP_ATTACH</td><td>setFirstOut</td></tr></tbody></table><blockquote><p>其中，<code>OP_REPLACE</code>操作下的<code>op.removed</code>触发执行的是setLastIn。<br><code>setFirstOut</code>方法用于填充firstOutFragments，<code>setLastIn</code>方法用于填充lastInFragments。</p></blockquote><p>我们将这种原则约定为“反转”机制。即之前该事务被commit到回退栈时执行的add/replace/show/attach操作，在即将出栈时，原先的操作都会转化为与之相对的操作。</p><p>这样对于每一个事务：之前最后add到Activity的Fragment现在就会最先被remove出去，所以调用setFirstOut来记录；最先remove出去的Fragment现在就会被最后重新add到Activity，所以调用setLastIn来记录。同时依据先前每个事务执行的先后顺序，越靠后执行的事务，现在应该越先被“反转”，所以在calculateBackFragments遍历时采取的顺序是从栈顶向栈底。</p><p>明白了setFirstOut和setLastIn被调用的依据原则，接下来我们来分析它们具体的填充规则。</p><h4 id="setFirstOut"><a href="#setFirstOut" class="headerlink" title="setFirstOut"></a>setFirstOut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void setFirstOut(...) &#123;</span><br><span class="line">    if (fragment != null) &#123;</span><br><span class="line">        int containerId = fragment.mContainerId;</span><br><span class="line">        if (containerId != 0 &amp;&amp; !fragment.isHidden()) &#123;    </span><br><span class="line">            if (fragment.isAdded() &amp;&amp; fragment.getView() != null</span><br><span class="line">                        &amp;&amp; firstOutFragments.get(containerId) == null) &#123;</span><br><span class="line">                firstOutFragments.put(containerId, fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            // 容错处理，防止多个事务对同一个Fragment进行了不同操作</span><br><span class="line">            if (lastInFragments.get(containerId) == fragment) &#123;</span><br><span class="line">                lastInFragments.remove(containerId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的containerId保证了每个容器的firstOut的唯一性。Fragment能被作为firstOut的前提是：1.处于显示状态（<code>!isHidden()</code>）；2.已经被add（<code>isAdded()</code>）；3.mView不为空（<code>getView() != null</code>）。这几个条件很好理解，”First Out”的Fragment是需要执行“从有到无”的动画，如果Fragment并没有在当前页面或没有视图，动画也就失去了意义。</p><p>作为填充规则最后一环，<code>firstOutFragments.get(containerId) == null</code>用以筛选满足前置条件的所有Fragments，并将第一个put到了对应的容器，保证了“last in”的Fragment作为“first out”。</p><h4 id="setLastIn"><a href="#setLastIn" class="headerlink" title="setLastIn"></a>setLastIn</h4><p>“last in”的Fragment是最终呈现到页面的Fragment的，因此它需要执行“从无到有”的动画。所以只要是没有被add的Fragment，会依次被put到lastInFragments以更新对应容器下记录的Fragment，那么最后一个被put的就表示“last in”：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void setLastIn(...) &#123;</span><br><span class="line">    if (fragment != null) &#123;</span><br><span class="line">        int containerId = fragment.mContainerId;</span><br><span class="line">        if (containerId != 0) &#123;</span><br><span class="line">            if (!fragment.isAdded()) &#123;</span><br><span class="line">                lastInFragments.put(containerId, fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            // 同setFirstOut一样，容错处理</span><br><span class="line">            if (firstOutFragments.get(containerId) == fragment) &#123;</span><br><span class="line">                firstOutFragments.remove(containerId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fragment.mState &lt; Fragment.CREATED &amp;&amp; mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">            mManager.makeActive(fragment);</span><br><span class="line">            mManager.moveToState(fragment, Fragment.CREATED, 0, 0, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们还可以发现，如果一个Fragment还处于初始状态<code>INITIALIZING</code>（其中一种情况就是该Fragment已经被dettach了），此时就会重新激活它<code>makeActive</code>并将其状态转到<code>CREATED</code>。</p><h3 id="popFromBackStack"><a href="#popFromBackStack" class="headerlink" title="popFromBackStack"></a>popFromBackStack</h3><h4 id="执行过渡动画和共享元素"><a href="#执行过渡动画和共享元素" class="headerlink" title="执行过渡动画和共享元素"></a>执行过渡动画和共享元素</h4><p>略。</p><h4 id="真正的出栈"><a href="#真正的出栈" class="headerlink" title="真正的出栈"></a>真正的出栈</h4><p>真正执行出栈操作的原理其实与上面“填充firstOut/lastIn”步骤的机制是一样的，就是执行事务的“反转操作”：从链表的尾部开始向前遍历，将每一个Op“原子”操作进行“反转”后再执行，规则如下：</p><table><thead><tr><th>op.cmd</th><th>调用方法</th><th>关联动画</th></tr></thead><tbody><tr><td>OP_ADD</td><td>mManager.removeFragment</td><td>popExitAnim</td></tr><tr><td>*OP_REPLACE</td><td>mManager.removeFragment</td><td>popExitAnim</td></tr><tr><td>OP_REMOVE</td><td>mManager.addFragment</td><td>popEnterAnim</td></tr><tr><td>OP_HIDE</td><td>mManager.showFragment</td><td>popEnterAnim</td></tr><tr><td>OP_SHOW</td><td>mManager.hideFragment</td><td>popExitAnim</td></tr><tr><td>OP_DETACH</td><td>mManager.attachFragment</td><td>popEnterAnim</td></tr><tr><td>OP_ATTACH</td><td>mManager.detachFragment</td><td><strong>popEnterAnim</strong></td></tr></tbody></table><blockquote><p>其中<code>OP_REPLACE</code>操作的op.removed集合执行的是addFragment；另外<code>OP_ATTACH</code>操作的关联动画取的是popEnterAnim。</p></blockquote><p>removeFragment等操作的具体流程可以参考Fragment生命周期状态分析，这里需要说明的是这些操作并不全都会对Fragment执行moveState，因此当此次出栈的所有事务已全部反转完成后（未完成的话FragmentManager会继续调用对应事务的<code>popFromBackStack</code>方法），还会通知FragmentManager开始执行一次整体的状态切换moveToState：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public TransitionState popFromBackStack(boolean doStateMove, TransitionState state,</span><br><span class="line">            SparseArray&lt;Fragment&gt; firstOutFragments, SparseArray&lt;Fragment&gt; lastInFragments) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // API&gt;=21时，运行Transition</span><br><span class="line">    ...</span><br><span class="line">    Op op = mTail;</span><br><span class="line">    while (op != null) &#123;</span><br><span class="line">        // 反转操作：add--&gt;remove、show--&gt;hide ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一个事务反转完成，doStateMove被标记为TRUE</span><br><span class="line">    if (doStateMove) &#123;</span><br><span class="line">        // 开始整体的状态切换</span><br><span class="line">        mManager.moveToState(mManager.mCurState,</span><br><span class="line">                FragmentManagerImpl.reverseTransit(transition), transitionStyle, true);</span><br><span class="line">        state = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>moveToState</code>方法的详细流程可以参考Fragment生命周期状态分析一文，此处不再累述。</p><h3 id="回调通知回退栈的改变事件"><a href="#回调通知回退栈的改变事件" class="headerlink" title="回调通知回退栈的改变事件"></a>回调通知回退栈的改变事件</h3><p>这一步就很简单了，依次执行完真正的出栈操作后，FragmentManager中的popBackStackState方法在return前调用了reportBackStackChanged方法，该方法就是依次调用注册到mBackStackChangeListeners的监听的回调方法，通知事件的改变：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void reportBackStackChanged() &#123;</span><br><span class="line">    if (mBackStackChangeListeners != null) &#123;</span><br><span class="line">        for (int i=0; i&lt;mBackStackChangeListeners.size(); i++) &#123;</span><br><span class="line">            mBackStackChangeListeners.get(i).onBackStackChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>listener则可以通过<code>getSupportFragmentManager().addOnBackStackChangedListener</code>来注册。</p><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>其实<code>BackStackRecord</code>不仅继承了FragmentTransaction，还实现了Runnable接口，这也是为什么可以被直接加入“等待集合”的原因。<br>不管是哪一种提交方式，事务的执行最终都回到了<code>BackStackRecord</code>的<code>run()</code>方法，该方法总体分为了四个部分，这与出栈的操作流程大致是相同的，分别是：（1）对API&gt;=21版本的设备计算并执行共享元素相关的过渡动画transitions；（2）遍历事务操作指令并依次委托FragmentManager执行真正的操作；（3）当所有的指令执行完成后，统一进行状态切换<code>moveToState</code>调动Fragment生命周期；（4）入栈事务并通知回退栈改变世事件。接下来，我们依次对这几部分进行分析。</p><h3 id="（1）计算并执行动画（API-gt-21）"><a href="#（1）计算并执行动画（API-gt-21）" class="headerlink" title="（1）计算并执行动画（API&gt;=21）"></a>（1）计算并执行动画（API&gt;=21）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    // 改方法主要是为Fragment计数：某个Fragment被某个事务“引用”的次数，</span><br><span class="line">    // 若为0则表示该Fragment“不在”回退栈中。</span><br><span class="line">    bumpBackStackNesting(1);</span><br><span class="line">    TransitionState state = null;</span><br><span class="line">    SparseArray&lt;Fragment&gt; firstOutFragments = null;</span><br><span class="line">    SparseArray&lt;Fragment&gt; lastInFragments = null;</span><br><span class="line">    if (SUPPORTS_TRANSITIONS &amp;&amp; mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">        firstOutFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line">        lastInFragments = new SparseArray&lt;Fragment&gt;();</span><br><span class="line"></span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line"></span><br><span class="line">        state = beginTransition(firstOutFragments, lastInFragments, false);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的核心方法就是计算并填充<code>firstOutFragments, lastInFragments</code>集合的<code>calculateFragments</code>方法，以及执行动画的<code>beginTransition</code>方法。<br>此处的流程与出栈对应的流程是一样的，唯一的区别便是出栈时是将指令进行“反转”分析，导致最先被add的需要变为最后被remove，最后被remove的需要变为最先被add，并添加到对应的链表；而这里只需按照指令的先后顺序分析即可无需“反转”，因此调用了方法<code>calculateFragments</code>而不是<code>calculateFragments</code>方法。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这里同样需要注意的是在遍历Ops查找<code>last in</code>的时候，对于第一次将被add或者先前被dettach/destory、现在重新需要add 的Fragment（即是Fragment的mState为<code>INITIALIZING</code>），这里会将其状态state <strong>提前</strong> moveto至<code>CREATED</code>，也就意味着Fragment的生命周期方法至少会提前走到<code>onCreate</code>。这与API&lt;21的版本中的Fragment的事务执行顺序显著不同。</p><p>在<code>API&lt;21</code>的版本中，在开始run事务集合时，<code>add、replace</code>操作对Fragment的生命周期状态的效果并不会立即切换，而是在整个Ops集合遍历完成时才开始，可以参见BackStackRecord的run方法；也因此如果Ops集合中有<code>hide / show</code>等操作时，即使add是先于其执行，但是<code>onHiddenChanged</code>回调仍会先于onAttach；而API&gt;=21中，<code>calculateFragments</code>方法打乱了这个顺序。</p><h3 id="（2）执行真正的指令操作"><a href="#（2）执行真正的指令操作" class="headerlink" title="（2）执行真正的指令操作"></a>（2）执行真正的指令操作</h3><p>遍历指令之前，先拿到指令备选动画transition、transitionStyle，至于为什么是备选，可以参见对应的字段详解，这些备选动画在最后一步执行状态切换moveToState时如果指令对应的anim没有指定时就会起效：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int transitionStyle = state != null ? 0 : mTransitionStyle;</span><br><span class="line">int transition = state != null ? 0 : mTransition;</span><br></pre></td></tr></table></figure></p><p>接下来拿到事务指令双链表的头部<code>mHead</code>开始遍历并执行具体操作，具体的对应原则如下表所示：</p><table><thead><tr><th>op.cmd</th><th>调用方法</th><th>f.mNextAnim</th></tr></thead><tbody><tr><td>OP_ADD</td><td>addFragment</td><td>enterAnim</td></tr><tr><td>OP_REPLACE</td><td>addFragment</td><td>enterAnim</td></tr><tr><td>OP_REMOVE</td><td>removeFragment</td><td>exitAnim</td></tr><tr><td>OP_HIDE</td><td>hideFragment</td><td>exitAnim</td></tr><tr><td>OP_SHOW</td><td>showFragment</td><td>enterAnim</td></tr><tr><td>OP_DETACH</td><td>detachFragment</td><td>exitAnim</td></tr><tr><td>OP_ATTACH</td><td>attachFragment</td><td>enterAnim</td></tr></tbody></table><blockquote><p>其中， <code>OP_REPLACE</code>指令在addFragment前会先remove掉依附的视图容器中的其它已经add的Fragment，对应的动画为exitAnim。  </p></blockquote><p><code>addFragment</code>等方法的具体执行流程可参见Fragment生命周期状态一文。<br>当所有的指令执行完成后，不管在此期间某些操作是否触发了对应Fragment的状态切换moveToState，最后mManager仍然会调用moveToState方法做一次其维护下的所有Fragments整体的状态切换，以确保所有的Fragment的生命周期保持与宿主一致。</p><h3 id="（3）moveToState状态切换"><a href="#（3）moveToState状态切换" class="headerlink" title="（3）moveToState状态切换"></a>（3）moveToState状态切换</h3><p>具体参见Fragment生命周期状态一文。</p><h3 id="（4）通知回退栈改变世事件"><a href="#（4）通知回退栈改变世事件" class="headerlink" title="（4）通知回退栈改变世事件"></a>（4）通知回退栈改变世事件</h3><p>执行完状态切换后，对于开启了<code>mAddToBackStack</code>的事务，除了将其添加到回退栈的事务，在此还需要对注册了OnBackStackChangedListener的listener回调回退栈的改变：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 流程：run()-&gt;addBackStackState(state)-&gt;reportBackStackChanged()</span><br><span class="line">void reportBackStackChanged() &#123;</span><br><span class="line">    if (mBackStackChangeListeners != null) &#123;</span><br><span class="line">        for (int i=0; i&lt;mBackStackChangeListeners.size(); i++) &#123;</span><br><span class="line">            mBackStackChangeListeners.get(i).onBackStackChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结合出栈章节的分析，不管是出栈还是入栈，事件都得到了正常回调。</p>]]></content>
    
    <summary type="html">
    
      使用Fragment最重要的技能之一就是事务。本文拟解决以下常见问题：为什么要有事务，事务包含的所有特性，事务的具体执行过程以及使用事务的注意事项等。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://linjiang.tech/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>【Fragment】对Fragment的状态保存恢复机制原理的分析</title>
    <link href="https://linjiang.tech/2017/01/04/Fragment-Save%20and%20Restroe%20State/"/>
    <id>https://linjiang.tech/2017/01/04/Fragment-Save%20and%20Restroe%20State/</id>
    <published>2017-01-04T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>如同Activity、View等，状态的保存与恢复的重要性不言而喻，对于Fragment，在哪setRetainInstance，在什么时机save/restore State我们也早已熟练于心，但是为什么要这样、或者还有没有更多的skill却是稍显不足，也许探究一下整个机制的过程说不定就会恍然大悟。</p><p>在深入流程分析之前，我们需要明白状态的保存机制发生的前提：只要Activity不是被主动finish的，状态的保存与恢复机制就会被触发，导致onSaveInstanceState和onRestoreInstanceState的回调，包括了内存不足被killed、其它命令杀死进程等场景，甚至于手机的配置改变引发的Activity重建的情况（用户没有手动处理配置改变的情况下）。</p><h2 id="saveAllState"><a href="#saveAllState" class="headerlink" title="saveAllState"></a>saveAllState</h2><p>Fragment依附于Activity，因此Fragment的状态保存与恢复机制也是由Activity的相关方法触发。Activity的方法onSaveInstanceState的参数outState是系统在状态需要保存时用来提供存放持久化状态的容器，当系统触发状态保存时，在该方法中，通过对mFragments的saveAllState方法的调用，Activity下的Fragment的所有状态便保存在了 <code>FRAGMENTS_TAG</code> 键中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是saveAllState()具体保存了Fragment的哪些状态却不从得知。我们继续分析：<br>mFragments对象对应的类FragmentController是供Host(Activity)调用的一层FragmentManager的包装，FragmentManager下维护的所有Fragment的生命周期都是Host通过FragmentController来转发回调的，因此saveAllState()事件也被分发到了FragmentManager的saveAllState()中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Parcelable saveAllState() &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerState fms = new FragmentManagerState();</span><br><span class="line">    fms.mActive = active;</span><br><span class="line">    fms.mAdded = added;</span><br><span class="line">    fms.mBackStack = backStack;</span><br><span class="line">    return fms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，该方法将所有需要保存的状态归结为3种并封装到了一个FragmentManagerState可序列化对象中，我们依次来看看这三种状态分别是什么以及其具体的保存过程。</p><h4 id="fms-mActive"><a href="#fms-mActive" class="headerlink" title="fms.mActive"></a>fms.mActive</h4><p>mActive是一个FragmentState[]数组对象，而FragmentState类则是一个实现了Parcelable接口的实体，它负责对Fragment的基本变量进行序列化，包括了arguments、tag等信息，具体保存了哪些状态如下所示（字段代表的意义可以参考Fragment的字段详解）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public FragmentState(Fragment frag) &#123;</span><br><span class="line">    mClassName = frag.getClass().getName();</span><br><span class="line">    mIndex = frag.mIndex;</span><br><span class="line">    mFromLayout = frag.mFromLayout;</span><br><span class="line">    mFragmentId = frag.mFragmentId;</span><br><span class="line">    mContainerId = frag.mContainerId;</span><br><span class="line">    mTag = frag.mTag;</span><br><span class="line">    mRetainInstance = frag.mRetainInstance;</span><br><span class="line">    mDetached = frag.mDetached;</span><br><span class="line">    mArguments = frag.mArguments;</span><br><span class="line">    mHidden = frag.mHidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了以上字段外，FragmentState还预留了一个<code>Bundle mSavedFragmentState</code>来存储一些额外的状态，具体保存了什么接下来再分析；可见，这些字段足以代表了Fragment的实例基本状态。</p><p>因此可以简单说FragmentState就是对Fragment的基本状态的一个封装。</p><p>在需要save state时，只需要将对应的Fragment通过FragmentState构造方法传入，该Fragment实例的基本状态也就封装好了，在FragmentManager中具体实现过程如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">Parcelable saveAllState() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 若没有Fragment，就无需保存状态</span><br><span class="line">    if (mActive == null || mActive.size() &lt;= 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int N = mActive.size();</span><br><span class="line">    FragmentState[] active = new FragmentState[N];</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">        Fragment f = mActive.get(i);</span><br><span class="line">        if (f != null) &#123;</span><br><span class="line">            if (f.mIndex &lt; 0) &#123;</span><br><span class="line">                throwException(new IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            // 重点：遍历“活着”的Fragment，依次封装状态并存入active数组中。</span><br><span class="line">            FragmentState fs = new FragmentState(f);</span><br><span class="line">            active[i] = fs;</span><br><span class="line">            // 对处于正常生命周期状态下的Fragment，</span><br><span class="line">            // 还需要确保其与用户相关操作的变量以及视图层级等状态得到保存</span><br><span class="line">            if (f.mState &gt; Fragment.INITIALIZING &amp;&amp; fs.mSavedFragmentState == null) &#123;</span><br><span class="line">                // saveFragmentBasicState具体实现了以下操作：</span><br><span class="line">                // 1. 执行了Fragment的onSaveInstanceState方法；</span><br><span class="line">                // 1.1. 同时若存在子Fragment，也对子Fragment相关状态调用saveAllState进行了保存；</span><br><span class="line">                // 2. 调用saveFragmentViewState保存了视图层级状态；</span><br><span class="line">                // 3. 保存了用户可见性状态mUserVisibleHint；</span><br><span class="line">                fs.mSavedFragmentState = saveFragmentBasicState(f);</span><br><span class="line">                if (f.mTarget != null) &#123;</span><br><span class="line">                    if (f.mTarget.mIndex &lt; 0) &#123;</span><br><span class="line">                        throwException(new IllegalStateException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fs.mSavedFragmentState == null) &#123;</span><br><span class="line">                        fs.mSavedFragmentState = new Bundle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 同时，如果Fragment有target，还需要保存target对应的索引index</span><br><span class="line">                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);</span><br><span class="line">                    // 以及target的mTargetRequestCode</span><br><span class="line">                    if (f.mTargetRequestCode != 0) &#123;</span><br><span class="line">                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 最后，将mSavedFragmentState信息保存在FragmentState的额外字段mSavedFragmentState中；（有误）</span><br><span class="line">                fs.mSavedFragmentState = f.mSavedFragmentState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，最终除了Fragment的一些基本状态得到保存外，上面提到的额外字段mSavedFragmentState还存储了以下信息：</p><table><thead><tr><th>信息(Bundle’s Key)</th><th>备注</th></tr></thead><tbody><tr><td><code>TARGET_STATE_TAG</code></td><td>target的index</td></tr><tr><td><code>TARGET_REQUEST_CODE_STATE_TAG</code></td><td>target的requestCode</td></tr><tr><td><code>VIEW_STATE_TAG</code></td><td>视图层级状态</td></tr><tr><td><code>USER_VISIBLE_HINT_TAG</code></td><td>mUserVisibleHint字段</td></tr><tr><td><code>FragmentActivity.FRAGMENTS_TAG</code></td><td>子FragmentManager下所维护的所有Fragment的状态</td></tr><tr><td>onSaveInstanceState(outState)</td><td>供用户手动保存的状态</td></tr></tbody></table><h4 id="fms-mAdded"><a href="#fms-mAdded" class="headerlink" title="fms.mAdded"></a>fms.mAdded</h4><p>mAdded是一个int[]型数组，被用来保存当前已经被added到FragmentManager下的所有fragments的index：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager#saveAllState()</span><br><span class="line">...</span><br><span class="line">if (mAdded != null) &#123;</span><br><span class="line">    N = mAdded.size();</span><br><span class="line">    if (N &gt; 0) &#123;</span><br><span class="line">        added = new int[N];</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            // 依次遍历mAdded数组，将Fragment对应的index添加至added</span><br><span class="line">            added[i] = mAdded.get(i).mIndex;</span><br><span class="line">            if (added[i] &lt; 0) &#123;</span><br><span class="line">                throwException(new IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="fms-mBackStack"><a href="#fms-mBackStack" class="headerlink" title="fms.mBackStack"></a>fms.mBackStack</h4><p>mBackStack也是一个数组，实现了Parcelable接口的BackStackState类是对FragmentManager下的回退栈<code>backStack</code>的状态的一个保存。我们可以看看它保存了哪些状态：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int[] mOps;</span><br><span class="line">final int mTransition;</span><br><span class="line">final int mTransitionStyle;</span><br><span class="line">final String mName;</span><br><span class="line">final int mIndex;</span><br><span class="line">final int mBreadCrumbTitleRes;</span><br><span class="line">final CharSequence mBreadCrumbTitleText;</span><br><span class="line">final int mBreadCrumbShortTitleRes;</span><br><span class="line">final CharSequence mBreadCrumbShortTitleText;</span><br><span class="line">final ArrayList&lt;String&gt; mSharedElementSourceNames;</span><br><span class="line">final ArrayList&lt;String&gt; mSharedElementTargetNames;</span><br></pre></td></tr></table></figure><br>每个字段所表示的意思可以参见BackStack类的字段详解。这里额外说明一下其中的<code>int[] mOps的</code>变量，它的每一小段（长度为<code>bse.mNumOp*7 + numRemoved</code>）表示的是一个回退栈中的单个事务：<img src="https://raw.githubusercontent.com/whataa/PicsRepo/master/BackStackState%20mOps.jpg" alt="image">  </p><blockquote><p>上图中index为6的元素如果为0，表示该事务不存在removed元素，所以该段长度就只有7；反之长度为7 + numRemoved。</p></blockquote><p>由于Op类并没有实现Parcelable接口，所以这里在保存Op对象时，对其进行了“扁平”转化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// BackStackState#BackStackState(BackStackRecord bse)</span><br><span class="line">...</span><br><span class="line">mOps = new int[bse.mNumOp*7 + numRemoved];</span><br><span class="line">...</span><br><span class="line">op = bse.mHead;</span><br><span class="line">int pos = 0;</span><br><span class="line">while (op != null) &#123;</span><br><span class="line">    mOps[pos++] = op.cmd;</span><br><span class="line">    mOps[pos++] = op.fragment != null ? op.fragment.mIndex : -1;</span><br><span class="line">    mOps[pos++] = op.enterAnim;</span><br><span class="line">    mOps[pos++] = op.exitAnim;</span><br><span class="line">    mOps[pos++] = op.popEnterAnim;</span><br><span class="line">    mOps[pos++] = op.popExitAnim;</span><br><span class="line">    if (op.removed != null) &#123;</span><br><span class="line">        final int N = op.removed.size();</span><br><span class="line">        mOps[pos++] = N;</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            mOps[pos++] = op.removed.get(i).mIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mOps[pos++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    op = op.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样使得mOps的每个元素都是一个基本变量，可以方便地被持久化。</p><h4 id="issue-mStateSaved"><a href="#issue-mStateSaved" class="headerlink" title="issue: mStateSaved"></a>issue: mStateSaved</h4><p>这里还有一个issue，具体可以参考Fragment字段详解中的<code>mStateSaved</code>说明。</p><p>意思是在Honeycomb(11)之前，save state是发生在onPause之前的，但是从版本11开始，save state的时机被修改为onPause之后了。因为对于Fragment，在pause后和stop前之间改变fragment的mstate是被允许的，因此对于老设备，为了使其和现在的逻辑保存一致（v4的兼容性），就没有在此处将mStateSaved置为true以防止在执行事务时检测到保存状态时机已经发生过了而抛出异常；</p><blockquote><p>这也就意味着，在版本11之前，在pause后stop之前执行Fragment事务，虽然不发生异常但存在状态丢失的风险。</p></blockquote><h3 id="NoConfig下的状态保存"><a href="#NoConfig下的状态保存" class="headerlink" title="NoConfig下的状态保存"></a>NoConfig下的状态保存</h3><p>除了前面提到的一些“正常的”条件下被killed的情况下的状态保存调用之外，还有一种情况就是：</p><blockquote><p>设备的配置改变引发Activity被re-created，即Activity立马被杀死并重新创建。</p></blockquote><p>我们知道，若不需要自行处理Activity在配置的变更下的变更（即在Manifest中未对Activity进行<code>android:configChanges</code>配置，所以称为<strong>NonConfig</strong>），Activity会被销毁并重建。在这种情况下，按正常流程处理，依附于Activity的Fragment也是会按照前面的保存状态流程被销毁然后恢复的。但是对于Fragment，我们可能会经常遇到这样的情况：其中存在某些处理过程不需要因此中断，例如线程，因此Fragment提供了一个叫做<code>setRetainInstance(true)</code>的方法来告知系统：在宿主Activity被销毁重建的过程中，该Fragment不需要随之也销毁重建，即需要保持实例。</p><p>上述特性可以在Fragment的onCreate中开启。一旦开启，在设备配置改变时，系统在销毁Activity前会回调<code>Activity#onRetainNonConfigurationInstance()</code>，用来保留一些可以传递到新Activity的实例，在FragmentActivity中该方法被重写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FragmentActivity</span><br><span class="line">@Override</span><br><span class="line">public final Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();</span><br><span class="line">    ...</span><br><span class="line">    NonConfigurationInstances nci = new NonConfigurationInstances();</span><br><span class="line">    ...</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    ...</span><br><span class="line">    return nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>mFragments.retainNestedNonConfig()</code>最终将事件分发到了<code>FragmentManager#retainNonConfig</code>方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">FragmentManagerNonConfig retainNonConfig() &#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; fragments = null;</span><br><span class="line">    ArrayList&lt;FragmentManagerNonConfig&gt; childFragments = null;</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 重要标识：仅当Fragment调用了setRetainInstance(true)，该实例才会被缓存在fragments中</span><br><span class="line">        if (f.mRetainInstance) &#123;</span><br><span class="line">            if (fragments == null) &#123;</span><br><span class="line">                fragments = new ArrayList&lt;Fragment&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            fragments.add(f);</span><br><span class="line">            // 开启该标识，以防止在moveToState时的部分生命周期方法的调用</span><br><span class="line">            f.mRetaining = true;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 当然，其嵌套子Fragments如果也开启了mRetainInstance，也会被保存</span><br><span class="line">        if (f.mChildFragmentManager != null) &#123;</span><br><span class="line">            FragmentManagerNonConfig child = f.mChildFragmentManager.retainNonConfig();</span><br><span class="line">            ...</span><br><span class="line">            childFragments.add(child);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果该FragmentManager下没有任何Fragment需要保持实例，则返回null</span><br><span class="line">    if (fragments == null &amp;&amp; childFragments == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后，将缓存包装在FragmentManagerNonConfig对象中返回</span><br><span class="line">    return new FragmentManagerNonConfig(fragments, childFragments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码中的注释已经很详细了，纵观整个方法的流程，其实就是将需要 保持实例的Fragment集合 及 其相应的嵌套子Fragment实例集合 都保存在了FragmentManagerNonConfig对象中并返回，FragmentActivity将得到的该对象又被包装在NonConfigurationInstances里返回给了系统。<br>这样，在设备配置改变时，通过setRetainInstance来告知需要保持实例的Fragment对象就在Activity的被销毁过程中被保存了下来。<br><img src="https://raw.githubusercontent.com/whataa/PicsRepo/master/FragmentManagerState.png" alt="image"></p><p>当然，如果我们在mainfest中配置了Activity的<code>android:configChanges</code>属性，即我们需要手动处理设备配置改变下的变化，那么也就意味着Activity不需要默认地被销毁重建，这样也就不存在Fragment保持实例这一说法了。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面分析了触发状态的保存机制的两种大的情况：分别是普通情况下例如内存不足、被其它软件杀死等，以及特殊情况——设备的配置改变。不论是哪一种情况，都会触发onSaveInstance方法的回调，即使是当设备配置改变时已经通过setRetainInstance告知了保留实例，这里需要特别注意。</p><p>并且，两种情况保存状态/实例的时机和位置是独立，也就是说onSaveInstance并不会因为setRetainInstance发生改变、或者retainNonConfig不会干扰setRetainInstance的执行和结果。</p><p>同时另一个需要注意的点就是：<strong>setRetainInstance起效的前提是设备的配置改变</strong> 这一情况，如果只是普通情况Activity被killed，Fragment依然会被销毁和稍后的恢复，即无法保持实例的，这时候只能通过onSaveInstance来保留一些状态。</p><h2 id="restoreAllState"><a href="#restoreAllState" class="headerlink" title="restoreAllState"></a>restoreAllState</h2><p>当Activity <code>re-created</code>时（包括了稍后用户手动从历史栈中回来或者配置改变引发的重建的情况），当前状态就应该恢复到上次被销毁时保存的状态。</p><p>我们知道，在Activity被create时，Activity里首次被调用的方法是attach(…)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void attach(...NonConfigurationInstances lastNonConfigurationInstances...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该方法中系统传入了上次包装实例的缓存对象<code>lastNonConfigurationInstances</code> （若存在，我们这里针对的就是存在的情况），然后在经历生命周期过程第一个方法onCreate时，Activity直接使用了该对象来恢复Fragments实例（针对<code>.app.Fragment</code>），在FragmentActivity中也是一样（针对<code>.app.v4.Fragment</code>）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Activity#onCreate</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">// FragmentActivity#onCreate</span><br><span class="line">...</span><br><span class="line">// getLastNonConfigurationInstance方法取就是传入Activity中的mLastNonConfigurationInstances对象</span><br><span class="line">NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, nc != null ? nc.fragments : null);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在存在savedInstanceState的前提下，在onCreate时直接依据<code>FRAGMENTS_TAG</code>键得到与Fragment相关的状态（若存在），然后调用了<code>mFragments.restoreAllState</code>方法，我们可以看到，传入的参数除了Fragment的状态之外，还包括了<code>NonConfigurationInstances.fragments</code>对象，该对象正是前面设备配置改变时，系统在销毁Activity前回调的<code>Activity#onRetainNonConfigurationInstance()</code>方法中保留下来的Fragment实例集合。也就是说，不论是那种触发状态保存机制的情况下保留的状态，最终在Activity re-created时，都会通过mFragments.restoreAllState入口将状态恢复。mFragments.restoreAllState最终将事件分发给了FragmentManager#restoreAllState方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">void restoreAllState(Parcelable state, FragmentManagerNonConfig nonConfig) &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerState fms = (FragmentManagerState)state;</span><br><span class="line">    ...</span><br><span class="line">    // step1</span><br><span class="line">    if (nonConfig != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step2</span><br><span class="line">    for (int i=0; i&lt;fms.mActive.length; i++) &#123;</span><br><span class="line">        FragmentState fs = fms.mActive[i];</span><br><span class="line">        if (fs != null) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // step3</span><br><span class="line">    if (nonConfig != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step4</span><br><span class="line">    if (fms.mAdded != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step5</span><br><span class="line">    if (fms.mBackStack != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的流程可以大致分为5个步骤，FragmentManager通过这几个步骤恢复了自身的一些状态，也就恢复了所辖的所有Fragment。</p><h3 id="Step-1：将保持的Fragment实例关联至FragmentState"><a href="#Step-1：将保持的Fragment实例关联至FragmentState" class="headerlink" title="Step 1：将保持的Fragment实例关联至FragmentState"></a>Step 1：将保持的Fragment实例关联至FragmentState</h3><p>由于可能存在保持了实例的Fragment，所以在该步骤中，需要将这些实例关联到上次保存的Fragment状态对象FragmentState中，这样在接下来的步骤中就不需要实例化对应的Fragment对象了（因为下面的步骤会依据保存的状态来实例化新的Fragment对象）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # restoreAllState()</span><br><span class="line">if (nonConfig != null) &#123;</span><br><span class="line">    List&lt;Fragment&gt; nonConfigFragments = nonConfig.getFragments();</span><br><span class="line">    childNonConfigs = nonConfig.getChildNonConfigs();</span><br><span class="line">    final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 得到保持的实例对象</span><br><span class="line">        Fragment f = nonConfigFragments.get(i);</span><br><span class="line">        // 取出实例对象在保存了状态的数组中对应的FragmentState</span><br><span class="line">        FragmentState fs = fms.mActive[f.mIndex];</span><br><span class="line">        // 将实例关联到对应的FragmentState</span><br><span class="line">        fs.mInstance = f;</span><br><span class="line">        f.mSavedViewState = null;</span><br><span class="line">        f.mBackStackNesting = 0;</span><br><span class="line">        f.mInLayout = false;</span><br><span class="line">        f.mAdded = false;</span><br><span class="line">        f.mTarget = null;</span><br><span class="line">        if (fs.mSavedFragmentState != null) &#123;</span><br><span class="line">            fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());</span><br><span class="line">            f.mSavedViewState =FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">            f.mSavedFragmentState = fs.mSavedFragmentState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Step2：恢复FragmentManager-mActive"><a href="#Step2：恢复FragmentManager-mActive" class="headerlink" title="Step2：恢复FragmentManager#mActive"></a>Step2：恢复FragmentManager#mActive</h3><p>在将保存的状态和保持的实例合并后，接下来就需要开始遍历fms.mActive，将保存的Fragment状态依次恢复：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # restoreAllState()</span><br><span class="line">for (int i=0; i&lt;fms.mActive.length; i++) &#123;</span><br><span class="line">    FragmentState fs = fms.mActive[i];</span><br><span class="line">    if (fs != null) &#123;</span><br><span class="line">        FragmentManagerNonConfig childNonConfig = null;</span><br><span class="line">        if (childNonConfigs != null &amp;&amp; i &lt; childNonConfigs.size()) &#123;</span><br><span class="line">            // 拿到Fragment的子Fragment的实例</span><br><span class="line">            childNonConfig = childNonConfigs.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 该方法通过FragmentState保存的状态返回一个Fragment实例</span><br><span class="line">        Fragment f = fs.instantiate(mHost, mParent, childNonConfig);</span><br><span class="line">        // 将（重新实例化）的Fragment对象关联到mActive数组中</span><br><span class="line">        mActive.add(f);</span><br><span class="line">        // 清空mInstance字段，以防最后再次从中恢复</span><br><span class="line">        fs.mInstance = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mActive.add(null);</span><br><span class="line">        if (mAvailIndices == null) &#123;</span><br><span class="line">            mAvailIndices = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;restoreAllState: avail #&quot; + i);</span><br><span class="line">        mAvailIndices.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中的<code>fs.instantiate(mHost, mParent, childNonConfig)</code>方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// FragmentState</span><br><span class="line">public Fragment instantiate(FragmentHostCallback host, Fragment parent, FragmentManagerNonConfig childNonConfig) &#123;</span><br><span class="line">    // mInstance是上一步关联进来的保持了实例的Fragment对象</span><br><span class="line">    if (mInstance == null) &#123;</span><br><span class="line">        final Context context = host.getContext();</span><br><span class="line">        if (mArguments != null) &#123;</span><br><span class="line">            mArguments.setClassLoader(context.getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        // 最终通过Fragment的instantiate方法得到了一个全新的Fragment对象</span><br><span class="line">        mInstance = Fragment.instantiate(context, mClassName, mArguments);</span><br><span class="line">        if (mSavedFragmentState != null) &#123;</span><br><span class="line">            mSavedFragmentState.setClassLoader(context.getClassLoader());</span><br><span class="line">            mInstance.mSavedFragmentState = mSavedFragmentState;</span><br><span class="line">        &#125;</span><br><span class="line">        mInstance.setIndex(mIndex, parent);</span><br><span class="line">        mInstance.mFromLayout = mFromLayout;</span><br><span class="line">        mInstance.mRestored = true;</span><br><span class="line">        mInstance.mFragmentId = mFragmentId;</span><br><span class="line">        mInstance.mContainerId = mContainerId;</span><br><span class="line">        mInstance.mTag = mTag;</span><br><span class="line">        mInstance.mRetainInstance = mRetainInstance;</span><br><span class="line">        mInstance.mDetached = mDetached;</span><br><span class="line">        mInstance.mHidden = mHidden;</span><br><span class="line">        mInstance.mFragmentManager = host.mFragmentManager;</span><br><span class="line">    &#125;</span><br><span class="line">    mInstance.mChildNonConfig = childNonConfig;</span><br><span class="line">    return mInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Fragment.instantiate(…)方法会根据所给的class name加载对应的Class类，调用<code>clazz.newInstance()</code>新建一个全新的Fragment对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Fragment f = (Fragment)clazz.newInstance();</span><br><span class="line">    if (args != null) &#123;</span><br><span class="line">        args.setClassLoader(f.getClass().getClassLoader());</span><br><span class="line">        f.mArguments = args;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到Fragment对象后，我们还发现紧接下来第一件事就是为之绑定mArguments（若存在），所以如果需要传递一些简单的或者受限于生命周期的可持久化的参数，推荐使用<code>setArguments(Bundle)</code>方式。</p><p>另外，这里需要显式地强调一点：虽然在上面的<code>FragmentState#instantiate</code>方法中，保持了实例的Fragment的mSavedFragmentState字段并没有被赋值，但是状态的恢复机制依然与正常的流程一样。因为保持了实例就意味着该实例下的状态也会被保持。</p><h3 id="Step3：关联恢复的Fragment的target"><a href="#Step3：关联恢复的Fragment的target" class="headerlink" title="Step3：关联恢复的Fragment的target"></a>Step3：关联恢复的Fragment的target</h3><p>关于Target字段是什么可以参考Fragment的字段详解。</p><p>保存了的状态对应的Fragment实例恢复后，这一步就主要根据Fragment对应的target索引，来讲索引替换为对应的Fragment实例，当然，target索引对应的实例存在的前提是该target之前使用了<code>Fragment#setRetainInstance</code>机制来保持实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (nonConfig != null) &#123;</span><br><span class="line">    List&lt;Fragment&gt; nonConfigFragments = nonConfig.getFragments();</span><br><span class="line">    final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Fragment f = nonConfigFragments.get(i);</span><br><span class="line">        if (f.mTargetIndex &gt;= 0) &#123;</span><br><span class="line">            if (f.mTargetIndex &lt; mActive.size()) &#123;</span><br><span class="line">                f.mTarget = mActive.get(f.mTargetIndex);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                f.mTarget = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这一步我们也可以知道，Fragment对应的Target在状态的保存与恢复机制下，默认只会保留target的索引index，如果target正好启用了setRetainInstance特性，那么target就会被关联至相应的Fragment。</p><h3 id="Step4：恢复FragmentManager-mAdded"><a href="#Step4：恢复FragmentManager-mAdded" class="headerlink" title="Step4：恢复FragmentManager#mAdded"></a>Step4：恢复FragmentManager#mAdded</h3><p>接下来，开始恢复mAdded，FragmentManager#mAdded字段主要作用就是记录已经add到Activity上的Fragment：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (fms.mAdded != null) &#123;</span><br><span class="line">    // 依据的就是在saveAllState时保存的fms.mAdded数组</span><br><span class="line">    // 该数组保存的是已经Add的Fragment在mActive对应是索引</span><br><span class="line">    mAdded = new ArrayList&lt;Fragment&gt;(fms.mAdded.length);</span><br><span class="line">    for (int i=0; i&lt;fms.mAdded.length; i++) &#123;</span><br><span class="line">        Fragment f = mActive.get(fms.mAdded[i]);</span><br><span class="line">        if (f == null) &#123;</span><br><span class="line">            throwException(new IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        f.mAdded = true;</span><br><span class="line">        if (mAdded.contains(f)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Already added!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mAdded.add(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mAdded = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Step5：恢复FragmentManager-mBackStack"><a href="#Step5：恢复FragmentManager-mBackStack" class="headerlink" title="Step5：恢复FragmentManager#mBackStack"></a>Step5：恢复FragmentManager#mBackStack</h3><p>与第4步一样，这里通过在saveAllState时保存的fms.mBackStack数组依次恢复FragmentManager的回退栈中的BackStackRecord信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (fms.mBackStack != null) &#123;</span><br><span class="line">    mBackStack = new ArrayList&lt;BackStackRecord&gt;(fms.mBackStack.length);</span><br><span class="line">    for (int i=0; i&lt;fms.mBackStack.length; i++) &#123;</span><br><span class="line">        BackStackRecord bse = fms.mBackStack[i].instantiate(this);</span><br><span class="line">        mBackStack.add(bse);</span><br><span class="line">        if (bse.mIndex &gt;= 0) &#123;</span><br><span class="line">            setBackStackIndex(bse.mIndex, bse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mBackStack = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>BackStackState#instantiate方法中，依据了在saveAllState时，构造BackStackState的规则来完整地恢复BackStackRecord的各个字段，包括<code>mOps</code>，具体可以参见BackStackState类。</p><p>至此，该方法的流程就走完了，期间Fragment除了实例化并恢复了基本状态，却并没有发生状态转移(<code>moveToState</code>)，Fragment的<code>mState</code>字段依然是<code>INITIALIZING</code>状态，也就是说，对于整个大流程而言，还差一步状态的转移，Fragment的整体状态就可以恢复为应用上次离开(killed)时的样子了。而这一步就发生在Activity的onCreate方法里mFragments.restoreAllState的后面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Activity | FragmentActivity</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFragments.restoreAllState(...);</span><br><span class="line">    ...// here</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mFragments.dispatchCreate()方法就很熟悉了，具体可以参见Fragment的生命周期状态分析一文。这里仅列出在saveAllState时保存在各个Key下的状态通过dispatchCreate的触发，最终是在什么地方被恢复的，dispatchCreate()最终来到了moveState的5个参数的方法中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager#moveState</span><br><span class="line">...</span><br><span class="line">if (f.mState &lt; newState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch (f.mState) &#123;</span><br><span class="line">        case Fragment.INITIALIZING:</span><br><span class="line">            ...</span><br><span class="line">            if (f.mSavedFragmentState != null) &#123;</span><br><span class="line">                f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());</span><br><span class="line">                f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">                f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);</span><br><span class="line">                if (f.mTarget != null) &#123;</span><br><span class="line">                    f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            if (!f.mRetaining) &#123;</span><br><span class="line">                f.performCreate(f.mSavedFragmentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                f.restoreChildFragmentState(f.mSavedFragmentState);</span><br><span class="line">                f.mState = Fragment.CREATED;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>上面同时恢复的字段包括了<code>mSavedViewState 、mTarget 、mTargetRequestCode 、mUserVisibleHint</code>等，对于<code>mSavedFragmentState</code>，Fragment的生命周期方法中的这些方法也会用到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">if (f.mView != null) &#123;</span><br><span class="line">    f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，我们可以选择在以上生命周期任何一个方法中来恢复我们先前保存的状态，并且这些状态都是同一个对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析Fragment的状态保存与恢复实则是分析FragmentManager的状态保存与恢复，对于Fragment的管理类，除了Fragment个体的状态保存恢复，Fragment之间在FragmentManager下的相互关系、结构栈等也需要维持，因此整个过程以FragmentManagerState为核心，经历了FragmentManagerState的“构造、持久化、还原”三大步骤，逐步完成了FragmentManager的状态保存与恢复。具体来说，就是在destroy前保存相关字段状态，交由系统管理，然后在re-created Activity时，先后创建全新FragmentManager及相关Fragment对象来关联上次保存的状态字段，实现状态的恢复。</p><p>本篇属于个人计划的分析Fragment系列。关于Fragment的字段详解、静态/动态加载流程、生命周期和状态的切换以及常见异常解决方案等的分析会陆续完成，欢迎关注。</p>]]></content>
    
    <summary type="html">
    
      如同Activity、View等，状态的保存与恢复的重要性不言而喻，对于Fragment，在哪setRetainInstance，在什么时机save/restore State我们也早已熟练于心，但是为什么要这样、或者还有没有更多的skill却是稍显不足，也许探究一下整个机制的过程说不定就会恍然大悟。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://linjiang.tech/tags/Fragment/"/>
    
      <category term="状态保存" scheme="https://linjiang.tech/tags/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>以Patch的形式更新Android Studio</title>
    <link href="https://linjiang.tech/2016/12/30/Android%20Studio%20Patches%20Update/"/>
    <id>https://linjiang.tech/2016/12/30/Android%20Studio%20Patches%20Update/</id>
    <published>2016-12-30T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>2019/09/19 更新：兼容最新的方式，添加Mac平台相关描述</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><ol><li><p>通过如下方式得到最新渠道(<code>Canary, Dev, Beta, Stable</code>)版本号；</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. https://dl.google.com/android/studio/patches/updates.xml</span><br><span class="line">or</span><br><span class="line">2. http://tools.android.com/download/studio</span><br></pre></td></tr></table></figure></li><li><p>查看本地Studio的版本号，</p><p> 例如：Build #AI-191.8026.42.35.5791312, built on August 9, 2019</p></li><li><p>拼接Studio Patch的地址并下载</p><ul><li><code>$&#123;platform&#125;</code> ：windows平台为win，Mac平台为mac</li><li><code>$&#123;from-version&#125;</code>：当前版本</li><li><p><code>$&#123;to-version&#125;</code> ：最新版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 无需代理</span><br><span class="line">https://dl.google.com/android/studio/patches/AI-$&#123;from-version&#125;-$&#123;to-version&#125;-patch-$&#123;platform&#125;.jar</span><br></pre></td></tr></table></figure></li></ul></li><li><p>得到Patch文件后，粘贴至Android Studio根目录下的上层文件夹（建议）。</p><blockquote><p>Windows：若直接存放在根目录下，执行命令时会出现冲突。<br>Mac：粘贴至 /Applications/Android\ Studio.app/ ，即于Contents目录同级。</p></blockquote></li><li><p>打开终端cd到上述对应路径，执行如下命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. 注意如果目录是在系统盘(C:)，一定要使用带 管理员权限 的命令提示符；</span><br><span class="line">1. 注意$&#123;PATCH-PATH&#125;为可执行的Patch的路径及文件全名（可使用相对路径）；</span><br><span class="line">2. 注意命令最后有一个“.”</span><br><span class="line">Java -classpath $&#123;PATCH-PATH&#125; com.intellij.updater.Runner install .</span><br></pre></td></tr></table></figure><blockquote><p>最新方式中将最后的 <code>.</code> 替换为 <code>Contents</code> </p></blockquote></li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li><p>本地version为：<code>145.3360264</code><br>最新version为：<code>145.3537739</code></p></li><li><p>下载<code>https://dl.google.com/android/studio/patches/AI-145.3360264-145.3537739-patch-win.jar</code></p></li><li><p>粘贴至<code>E:\Android Studio Wrapper\AI-145.3360264-145.3537739-patch-win.jar</code></p></li><li><p>终端 cd 至 <code>E:\Android Studio Wrapper\Android Studio&gt;:</code>   </p></li><li><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window</span><br><span class="line">Java -classpath ..\AI-145.3360264-145.3537739-patch-win.jar com.intellij.updater.Runner install .</span><br><span class="line">// mac</span><br><span class="line">java -classpath ./AI-145.3360264-145.3537739-patch--mac.jar com.intellij.updater.Runner install Contents</span><br></pre></td></tr></table></figure></li></ol><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li><p>该方法仅适用于版本跨度小的升级，早期的版本或者大版本更新有可能并没有放出patch文件，一切以下载链接是否可用为准。</p></li><li><p>建议在关闭Android Studio的前提下运行上面的步骤。</p></li><li><p>执行第5步后，有可能出现提示大意指：<code>不能删除文件xxx，无法应用patch</code> 等信息，请直接忽略掉（点击cancel），正常情况下后续会依次经历back up、apply patch；也有可能在back up后出现failed patch，请确保权限正确。</p></li></ul>]]></content>
    
    <summary type="html">
    
      本文是一篇纯技巧型的文章，非常方便没有VPN / 公司采用沙盒机制无法连接网络等场景下的使用。Patch的方式使得我们不用面对在每次IDE更新后就重新下载动辄上G的全量安装文件、或者由于配置的麻烦不想去更新而无法体验到最新的特性这些问题。
    
    </summary>
    
    
      <category term="工具插件" scheme="https://linjiang.tech/categories/%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="Android-Studio" scheme="https://linjiang.tech/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>App&#39;s ClassLoader的来源</title>
    <link href="https://linjiang.tech/2016/10/31/App&#39;s%20ClassLoader%E7%9A%84%E6%9D%A5%E6%BA%90/"/>
    <id>https://linjiang.tech/2016/10/31/App&#39;s%20ClassLoader%E7%9A%84%E6%9D%A5%E6%BA%90/</id>
    <published>2016-10-31T10:00:00.000Z</published>
    <updated>2023-01-13T08:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>Java中每一个类都是通过ClassLoader来加载的。对于基于Java的Android应用，这些ClassLoader是从哪来的呢。研究过Android插件化机制的都知道Android中有<code>PathClassLoader</code>和<code>DexClassLoader</code>这两个类，它们的概念和区别也许我们已经很熟悉了，但是对为什么应用的类加载器是PathClassLoader，它是如何产生的这些问题却是不甚了解。本文就从应用的启动流程出发，来揭开ClassLoader的秘密。</p><p>如果抛开底层原理不看，我们可以感知到的App启动的第一步大概就是<code>Application的onCreate</code>方法，因此我们先来看看Application类是如何加载进来的。</p><h3 id="加载Application"><a href="#加载Application" class="headerlink" title="加载Application"></a>加载Application</h3><p>在该方法中加入下面这行代码来查看一下当前堆栈：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Throwable().printStackTrace();</span><br></pre></td></tr></table></figure><br>启动应用后，可以在logCat中看到如下信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">W/System.err: java.lang.Throwable</span><br><span class="line">             at com.demo.MyApplication.onCreate(MyApplication.java:12)</span><br><span class="line">             at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1013)</span><br><span class="line">             at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4707)</span><br><span class="line">             at android.app.ActivityThread.-wrap1(ActivityThread.java)</span><br><span class="line">             at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)</span><br><span class="line">             at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">             at android.os.Looper.loop(Looper.java:148)</span><br><span class="line">             at android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">             at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">             at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">             at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br></pre></td></tr></table></figure><br>方法间的调用链很清晰，在onCreate之前，从名字来看与<code>Application</code>类相关的调用最早是出现在<code>ActivityThread.handleBindApplication</code>这一行，那么我们就到ActivityThread的源码中去一探究竟。</p><p>在ActivityThread类中大约4680行处，第一次发现了Application的身影，结合代码中的上下文，我们可以确信这就是我们日常开发中所熟悉的Application对象。可以看到，它是通过调用data.info的makeApplication方法来生成的，而这个 <code>data.info</code><br>是一个LoadedApk对象，LoadedApk表示，一个包对应一个LoadedApk对象（具体的可以自行深入了解）。先来看看这个data.info是什么时候生成的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br></pre></td></tr></table></figure></p><h4 id="data-info"><a href="#data-info" class="headerlink" title="data . info"></a>data . info</h4><p>往回查找，在大约4493行发现它被首次赋值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br></pre></td></tr></table></figure><br>从getPackageInfoNoCheck方法名就可以看出，它获取的应该是一个全新未缓存的LoadedApk对象，继续查看代码，其内部其实只是调用了getPackageInfo方法。</p><p>果不其然，在该方法会首先去查找缓存，由于是第一次调用，所以未命中缓存，直接通过LoadedApk构造方法new了一个LoadedApk对象，并缓存至<code>mPackages</code>中。</p><blockquote><p>注意由于上面getPackageInfoNoCheck传入的ClassLoader为null，所以导致构造LoadedApk时传入的baseLoader也为null。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;();</span><br><span class="line"></span><br><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,</span><br><span class="line">        boolean registerPackage) &#123;</span><br><span class="line">        //...</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        //...</span><br><span class="line">        ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        //...</span><br><span class="line">        LoadedApk packageInfo = ref != null ? ref.get() : null;</span><br><span class="line">        if (packageInfo == null || (packageInfo.mResources != null</span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            //...</span><br><span class="line">            packageInfo = new LoadedApk(this, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);</span><br><span class="line">                        </span><br><span class="line">            //...由于前面getPackageInfoNoCheck传给getPackageInfo的includeCode参数为true，所以放入缓存</span><br><span class="line">            else if (includeCode) &#123;</span><br><span class="line">                mPackages.put(aInfo.packageName, new WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过getPackageInfoNoCheck拿到返回LoadedApk对象后，我们再回到最初的位置，来看看<code>LoadedApk#makeApplication</code>方法。</p><h4 id="makeApplication"><a href="#makeApplication" class="headerlink" title="makeApplication"></a>makeApplication</h4><p>在LoadApk#makeApplication中，首先构造了Application的全包名字符串，并调用了方法getClassLoader得到ClassLoader的实例，然后调用了<code>mActivityThread.mInstrumentation.newApplication</code>方法传入classLoader参数，newApplication方法中通过cl.loadClass(className).newInstance()最终返回了Application实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LoadedApk</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123;</span><br><span class="line">    //...</span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    //...</span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">// Instrumentation</span><br><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重点来了，上面说到最终加载并构造Application对象的这个ClassLoader是通过<code>LoadedApk#getClassLoader</code>得到的，我们看看它的源码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mClassLoader != null) &#123;</span><br><span class="line">            return mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mIncludeCode &amp;&amp; !mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            //...</span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);</span><br><span class="line">            //...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mBaseClassLoader == null) &#123;</span><br><span class="line">                mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mClassLoader = mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很明显在第一次调用的时候缓存mClassLoader为null，同时<code>mIncludeCode</code>为true，并且我们的包名肯定也不是系统的包名，所以接下来直接调用的是<code>ApplicationLoaders.getDefault().getClassLoader</code>方法，该方法的流程为：当参数<code>parent==null || parent == baseParent</code>， 且<code>缓存无效</code>时，就会构建一个以BootClassLoader为parent，指向apk的PathClassLoader对象，在前面的分析中可知，构建LoadedApk对象时传入的baseLoader为null，所以LoadedApk的变量mBaseClassLoader也为null，最终导致ApplicationLoaders.getDefault().getClassLoader返回了一个全新的PathClassLoader对象。<code>ClassLoader.getSystemClassLoader()</code>的源码很简单，就是一个懒加载的单例，其parent为BootClassLoader，在此就不贴代码了。</p><p>其实对于ApplicationLoaders，这也是唯一被调用的时机（即通过LodedApk#getClassLoader），每个App进程都有唯一的ApplicationLoaders实例，一个LoadedApk的ClassLoader一但创建，便会保存在ApplicationLoaders的mLoaders实例中，后续则通过apk路径查询返回。同时还可以得出一个结论，一个进程可以对应多个apk。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ApplicationLoaders</span><br><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent) &#123;</span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">    synchronized (mLoaders) &#123;</span><br><span class="line">        if (parent == null) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            if (loader != null) &#123;</span><br><span class="line">                return loader;</span><br><span class="line">            &#125;</span><br><span class="line">            PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent);</span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            return pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line">        PathClassLoader pathClassloader = new PathClassLoader(zip, parent);</span><br><span class="line">        return pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到这里，Application的ClassLoader的来源我们也就清楚了，也解决了文中开头提到的为什么是PathClassLoader的问题。但是诸如Activity、Service等组件又是通过哪个ClassLoader加载进来的呢。</p><h3 id="加载四大组件"><a href="#加载四大组件" class="headerlink" title="加载四大组件"></a>加载四大组件</h3><p>其实前面的分析流程来对Android四大组件的启动流程分析同样适用，最终都会走到在ActivityThread，分别通过<code>performLaunchActivity、handleCreateService、handleReceiver、installProvider</code>几个方法来启动的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        //...</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">            //...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">        //...</span><br><span class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        Service service = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">            service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleReceiver(ReceiverData data) &#123;</span><br><span class="line">        //...</span><br><span class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        //...</span><br><span class="line">        BroadcastReceiver receiver;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">            //...</span><br><span class="line">            receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private IActivityManager.ContentProviderHolder installProvider(Context context,</span><br><span class="line">            IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">            boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">    ContentProvider localProvider = null;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    if (holder == null || holder.provider == null) &#123;</span><br><span class="line">        //...</span><br><span class="line">        Context c = null;</span><br><span class="line">        //...</span><br><span class="line">        c = mInitialApplication;</span><br><span class="line">        //...</span><br><span class="line">        try &#123;</span><br><span class="line">            final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            localProvider = (ContentProvider)cl.loadClass(info.name).newInstance();</span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            //...</span><br><span class="line">        &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以得到，这些方法中，最终都会直接/间接通过<code>LoadedApk#getClassLoader</code>来加载相应的类，这里的LoadedApk对象则是handleBindApplication流程期间生成并保存到ActivityThread的mPackages中的缓存，而每个App在启动时都会经历handleBindApplication流程，所以最终可以得出的结论就是加载四大组件的ClassLoader与Application的ClassLoader是同一个类加载器并且它是PathClassLoader对象。</p><h3 id="加载普通类"><a href="#加载普通类" class="headerlink" title="加载普通类"></a>加载普通类</h3><p>加载Application和四大组件的ClassLoader我们已经知道了，那么应用中自行编写的其它普通类又是通过哪个ClassLoader加载进来的呢？其实这个问题属于Java类加载机制的一部分。在一个类A中如果使用到了类B，都会直接或间接的通过new关键字或者Class.forName.newInstance显式地获得B的对象，在B类未加载的前提下，两种方式都会触发加载B类。如果我们深究其原理和区别，可以再写一篇文章了，这里直接抛出简要说明，我们可以把new关键字当做forName和newInstance两个步骤的集合，在调用Class.forName时，默认调用了以下方法作为将要加载的类的类加载器:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Returns the defining class loader of the caller&#x27;s caller.</span><br><span class="line">VMStack.getCallingClassLoader()</span><br></pre></td></tr></table></figure><br>由注释可知，该方法获取的是当前栈caller’s caller的类加载器，对于上面的AB例子，那么返回的就是加载A的类加载器。也就是说，普通类的加载是通过调用该类的caller类的类加载器来完成的。由于整个应用默认的初始类加载器是PathClassLoader，那么通过Application和四大组件引用到的其它普通类的类加载器也都是PathClassLoader。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本文结合Application和四大组件以及普通类是如何加载的问题来分析了Android应用的类加载器的来源。了解Android中的类加载器的来源可以让我们更清楚Android应用的所有类的是如何加载进来的；在对自定义类加载器中，对如何修改加载流程来达到应用的热更新和插件化目的的也有明显的帮助。</p>]]></content>
    
    <summary type="html">
    
      Java中每一个类都是通过ClassLoader来加载的。对于基于Java的Android应用，这些ClassLoader是从哪来的呢。研究过Android插件化机制的都知道Android中有PathClassLoader和DexClassLoader这两个类，它们的概念和区别也许我们已经很熟悉了，但是对为什么应用的类加载器是PathClassLoader，它是如何产生的这些问题却是不甚了解。本文就从应用的启动流程出发，来揭开ClassLoader的秘密。
    
    </summary>
    
    
      <category term="Android" scheme="https://linjiang.tech/categories/Android/"/>
    
    
      <category term="ClassLoader" scheme="https://linjiang.tech/tags/ClassLoader/"/>
    
      <category term="Hotfix&amp;Plugin" scheme="https://linjiang.tech/tags/Hotfix-Plugin/"/>
    
  </entry>
  
</feed>
