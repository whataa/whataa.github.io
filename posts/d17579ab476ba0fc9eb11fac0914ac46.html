<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用InheritedWidget被忽略的要点 - linjiang</title><meta name=description content=linjiang&#39;blog><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,700" type=text/css><link rel=stylesheet href=/style.css></head><body><header><h1><a href=/ >linjiang</a></h1><ul class=list-inline><li><a href=/ ><span>Home</span></a></li><li><a href=/about.html><span>About</span></a></li><li><a href=https://github.com/whataa target=_blank><span>GitHub</span></a></li></ul></header><div class=content><article class="blog-post post"><h2>使用InheritedWidget被忽略的要点</h2><p class=date>2019-02-25</p><div class=post-content><p>我们知道，flutter提供了一套功能粒度划分非常细的基本组件，并推荐利用组合的方式来构建布局，这确实很便捷、高效，但是也导致了Widget层次结构嵌套非常深，即使是一个很简单的页面。而不论什么页面，控件之间往往存在某些状态依赖关系，假使让一个结构形如“A-&gt;B-&gt;C-&gt;...-&gt;Z”中的A传递数据给Z，如果利用构造函数来一层层传递，效率可想而知。好在官方提供了 <code>InheritedWidget</code> 。</p><p>InheritedWidget的好处不言而喻，从起官方文档的定义即可知：</p><blockquote><p>Base class for widgets that efficiently propagate information down the tree.</p><p>To obtain <strong>the nearest</strong> instance of a particular type of inherited widget from a build context, use BuildContext.inheritFromWidgetOfExactType.</p><p>Inherited widgets, when referenced <strong>in this way</strong>, will cause the consumer to rebuild when the inherited widget itself changes state.</p></blockquote><p>通过直译（加揣度），大意就是包含以下两个特性：</p><ol><li>InheritedWidget是一个可以在树中高效地向下传递数据的组件：我们可以在以 <code>InheritedWidget</code> 为节点的树下任一Widget中调用 <code>BuildContext.inheritFromWidgetOfExactType</code> 来获取离其最近的 <code>InheritedWidget</code> 实例。</li><li>当以上面这种方式（调用<code>inheritFromWidgetOfExactType</code>方法时）被引用后，每当InheritedWidget自身的状态改变时，会导致 &quot;consumer&quot;（调用<code>inheritFromWidgetOfExactType</code>方法的这个Child） 重新 <code>build</code> 。</li></ol><p>SDK提供的Theme就是基于该特性，实现了配置的传递和配置的动态改变。</p><h3 id=案例>案例</h3><p>目前网上也有很多使用教程，核心大致实现<a href=https://gist.github.com/whataa/f197d3136ac800ccbb254fa4974a732a>inherited_widget_test.dart</a>，其结构图如下所示：</p><html><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0c9cefa2cc7a5b1908c47cab494588a5?method=download&shareKey=3d07341e3daa253f8569b7fafd833f3e" width=40%></p></html><p>我们先简单描述下代码逻辑：</p><ul><li><code>WidgetA</code> 调用了<code>inheritFromWidgetOfExactType</code>方法，获得了存放在 <code>MyInherited</code> 对象里的 <code>data</code> 数据并显示在 <code>WidgetA</code> 内容上，同时使得 <code>WidgetA</code> 和 <code>MyInherited</code> 产生关联；</li><li>当点击 <code>FlatButton</code> 触发 <code>MyWidget</code> 状态更新时， <code>MyState</code> 的 <code>build</code> 方法回调，重新构建 <code>MyInherited</code> 对象传入新值，由于<code>data</code>发生变化， <code>MyInherited</code> 的方法 <code>updateShouldNotify</code> 中返回了true，最终使得与<code>MyInherited</code> 关联的 <code>WidgetA</code> 触发reBuild。</li></ul><p>当我们运行并点击<code>FlatButton</code>后，页面表现得确实如上述所示，<code>WidgetA</code>的内容由 <code>WidgetA data = 0</code> 变为了 <code>WidgetA data = 1</code>，似乎 <code>InheritedWidget</code> 正确的使用方式正是如此，但是log里输出的却是如下：</p><pre><code>I/flutter: onPressed
I/flutter: MyWidget build
I/flutter: MyInherited construct
I/flutter: MyInherited updateShouldNotify result = true
I/flutter: WidgetA build
I/flutter: WidgetB build
</code></pre><p>可以看到，结合前面的代码逻辑分析，理论上只有 <code>WidgetA</code> 才会reBuild，而现在却产生了 <code>I/flutter: WidgetB build</code> 这条记录。这是为什么呢？</p><h3 id=原因分析>原因分析</h3><p>其实可以从前面提到的特性2找到答案。其中说到：<em><strong>InheriteWidget 状态发生变化时会rebuild相关的child。</strong></em> 我们知道，flutter中Widget被标识为了<code>@immutable</code>，即是不可变的，那么所谓的状态发生变化就意味着InheriteWidget重新构建，由于前面代码中在InheriteWidget构造时同时也构造的其child对象，因此当InheriteWidget重新构建时也会导致child跟着重新构建，这样也就失去了 “rebuild相关的child” 的意义，</p><p><em><strong>也就是说，要想特性2生效，需要保证InheriteWidget节点下的树不会被重新构建。</strong></em></p><h3 id=推荐做法>推荐做法</h3><h4 id=1-使用const-widget>1. 使用const Widget</h4><p>将<code>InheriteWidget</code> 的child转化为const，这样即使在重建 <code>InheriteWidget</code> 时，由于其child得到的是同一个对象，也就不会导致这个子树重建，选择性reBuild也就得到了保证。但是由于const特性，相关的参数也必须是常量，因此需要重写或修改的代码量相对较多，因此更推荐下面的做法。</p><h4 id=2-上移child对象到inheritewidget的parent-widget>2. 上移Child对象到InheriteWidget的Parent Widget</h4><p>我们可以参考Theme的实现方式，Theme是一个普通的Widget，其build方法如下：</p><pre><code>/// Theme.class
@override
Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: IconTheme(
        data: data.iconTheme,
        child: child,
      ),
    );
}
</code></pre><p>其中，<code>_InheritedTheme</code> 就是InheritedWidget，其child参数所指向的child对象是在Theme的构造函数中传入：</p><pre><code>const Theme({
    Key key,
    @required this.data,
    this.isMaterialAppTheme = false,
    @required this.child,
  })
</code></pre><p>这样就避免了当触发Theme的build方法进而导致<code>_InheritedTheme</code>重建时，child也被重新实例化的情况。</p><p>对于StatefulWidget来说，InheritedWidget是在State对象的build方法中实例化的，setState触发的是State的build，而StatefulWidget本身是没有重新实例化的，也就保证了child没有被重新实例化。</p><p>现在我们在保证层级结构不变的前提下，重新对上述式例进行优化，修改后的代码位于<a href=https://gist.github.com/whataa/bef37322816ba8e91b8368a1f716b3ca>inherited_widget_test_2.dart</a>，其中 <code>WidgetA和WidgetB</code> 对象已经提前于InheritedWidget在 <code>MyWidget</code> 构建期间实例化，当<code>MyWidget</code>执行 <code>build</code> 方法时触发InheritedWidget构建时再作为参数传入。这样只要 <code>MyWidget</code> 不重新构建，child也就不会构建，每次触发 <code>MyWidget</code> 的 <code>State</code> 变化时，只有InheritedWidget才会重新构建。</p><p>当我们再次点击FlatButton时，日志将如下所示：</p><pre><code>I/flutter: onPressed
I/flutter: MyWidget build
I/flutter: MyInherited construct
I/flutter: MyInherited updateShouldNotify result = true
I/flutter: WidgetA build
</code></pre><h3 id=结束>结束</h3><p>InheritedWidget 是学习flutter不得不掌握的一个特殊组件，具备向下传值和选择性reBuild子树节点的特性，许多SDK组件包括第三方库包都是基于其特性实现，本文结合官方文档发现并解决了一个使用InheritedWidget时容易被忽略的问题，并给出推荐方案。</p><p>感谢阅读。</p></div></article><script src=https://giscus.app/client.js data-repo=whataa/whataa.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk1NDY1NzI1MA==" data-category=Announcements data-category-id=DIC_kwDOA0IA4s4CtJJY data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll()</script></div></body></html>