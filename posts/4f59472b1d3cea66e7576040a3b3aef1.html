<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Kotlin：分析 ?. 的实现对空安全的保证 - linjiang</title><meta name=description content=linjiang&#39;blog><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,700" type=text/css><link rel=stylesheet href=/style.css></head><body><header><h1><a href=/ >linjiang</a></h1><ul class=list-inline><li><a href=/ ><span>Home</span></a></li><li><a href=/about.html><span>About</span></a></li><li><a href=https://github.com/whataa target=_blank><span>GitHub</span></a></li></ul></header><div class=content><article class="blog-post post"><h2>Kotlin：分析 ?. 的实现对空安全的保证</h2><p class=date>2020-04-01</p><div class=post-content><p>空安全是Kotlin特性之一，本文以一个常见的“错误”推导场景为例来分析 ?. 的实现。</p><p>使用kotlin开发时可能大家都遇到过这种情况：</p><pre><code class=language-kotlin> private var user: User? = null
 fun main() {
     if (user != null) {
         user.hello()
     }
 }
</code></pre><p>IDE 会提示 user.hello() 这一行语法错误，我们必须显式使用 <code>!!</code> 或者 <code>?.</code> 来解决，也就是说 IDE 认为 user 变量依然可能为null。“怎么可能，我明明已经在外层手动判断了 user 不为 null ”，这可能是我们首先想到的，然后开始巴拉这个「智能推导」实际是智障。</p><p>这其实并不是推导算法出现了 BUG，而是 user 确实无法被推导，原因就在于 user <strong>作为一个共享变量，任意时刻都存在被其它线程修改的可能性</strong>，也就是说即使前面进行了 null 判断，也不能保证在执行 hello 方法时的这一刻 user 一定不为 null，因此这种情况需要我们手动处理。如果我们确定 user 只会被一个线程操作，那么可以使用 <code>!!</code> 来明确告知以通过编译，否则应选择 <code>?.</code> 保证user字段的安全调用。</p><h2 id=-的实现>?. 的实现</h2><p>但是这里又会产生一个新疑问：我们知道 <code>?.</code> 其实就是针对类似 <code>if(x != null) {x.xx}</code> 这样的语法而提炼的糖，既然 user 任何时候都可能为 null，为什么语法糖 <code>?.</code> 能严格保证不会出现空指针异常？万千疑惑不如从反编译后的 Java 文件寻找答案：</p><pre><code class=language-kotlin>public final void main() {
    User var10000 = this.user;
    if (var10000 != null) {
        var10000.hello();
    }
}
</code></pre><p>以上是对 <code>user?.hello()</code> 的 de-sugar，我们可以清楚地看到其背后实际的逻辑：通过定义一个临时局部变量指向 user 变量对应的对象，然后后续的判断和执行都是调用的这个局部变量。<br>定义临时局部变量来避免一些并发问题的操作非常常见，由于局部变量只属于被定义时的线程环境所有，其它线程无法对其进行修改，<code>var10000</code> 是否为 null 只取决于定义后赋值的这一刻 user 的值，因此后续无论 user 的指向如何变化，都不会再影响变量 <code>var10000</code> 的值，只要这个局部变量不为 null，调用 hello 方法时肯定不会导致空指针异常。</p><h2 id=结尾>结尾</h2><p>到此这个由推导引出的疑问算是有了最终答案。现在我们回顾在此之前的解决方式，可以明显发现是存在潜在问题的：<strong>我们在判断 user 不为 null 之后直接使用 user!!.hello() 依然存在空指针异常的可能性</strong>。因此最后再次强调：仅当我们确认所操作的变量一定安全，否则对 <code>!!</code> 要慎重使用。<br></p></div></article><script src=https://giscus.app/client.js data-repo=whataa/whataa.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk1NDY1NzI1MA==" data-category=Announcements data-category-id=DIC_kwDOA0IA4s4CtJJY data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll()</script></div></body></html>