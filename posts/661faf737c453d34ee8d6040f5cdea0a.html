<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Kotlin：委托 和 动态代理 的奇妙组合 - linjiang</title><meta name=description content=linjiang&#39;blog><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,700" type=text/css><link rel=stylesheet href=/style.css></head><body><header><h1><a href=/ >linjiang</a></h1><ul class=list-inline><li><a href=/ ><span>Home</span></a></li><li><a href=/about.html><span>About</span></a></li><li><a href=https://github.com/whataa target=_blank><span>GitHub</span></a></li></ul></header><div class=content><article class="blog-post post"><h2>Kotlin：委托 和 动态代理 的奇妙组合</h2><p class=date>2020-04-08</p><div class=post-content><p>Callback是事件驱动的灵魂，Interface作为具体形式服务于各种场景。但是对于包含多个方法的接口，即使只会用到其中一个，也不得不容忍大量的空方法实现样板代码；当然我们可以创建一个公共的中间类预先实现需要的接口，其它地方使用时就可以直接继承该中间类并只需重写需要的方法即可，然而这样又会产生占用继承位、不同的接口需要不同的中间类等新问题，那么到了kotlin这儿又会有怎样的解决方案？<br>这里以 AnimatorListener 为例，直接展示最终的解决方案：<br></p><pre><code class=language-kotlin>inline fun &lt;reified T : Any&gt; noOpDelegate(): T {
    val javaClass = T::class.java
    return Proxy.newProxyInstance(javaClass.classLoader, arrayOf(javaClass)) {_,_,_ -&gt;
    } as T
}

animator.addListener(object : Animator.AnimatorListener by noOpDelegate() {
    // 重写关心的方法即可
})
</code></pre><br><br>意犹未尽？😝</div></article><script src=https://giscus.app/client.js data-repo=whataa/whataa.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk1NDY1NzI1MA==" data-category=Announcements data-category-id=DIC_kwDOA0IA4s4CtJJY data-mapping=title data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll()</script></div></body></html>