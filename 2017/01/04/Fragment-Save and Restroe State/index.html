<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<meta charset="utf-8" >

<title>【Fragment】对Fragment的状态保存恢复机制原理的分析</title>
<meta name="keywords" content="【Fragment】对Fragment的状态保存恢复机制原理的分析, linjiang&#39;s blog">
<meta name="description" content="如同Activity、View等，状态的保存与恢复的重要性不言而喻，对于Fragment，在哪setRetainInstance，在什么时机save/restore State我们也早已熟练于心，但是为什么要这样、或者还有没有更多的skill却是稍显不足，也许探究一下整个机制的过程说不定就会恍然大悟。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">







  <meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="linjiang's blog" type="application/atom+xml">
</head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://linjiang.tech">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://linjiang.tech">
        <h1 class="site-title">linjiang&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        HOME
      </a>
    
  
    
      <a href="/tips" class="menu purple-link">
        TIPS
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        ARCHIVES
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        ABOUT ME
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">【Fragment】对Fragment的状态保存恢复机制原理的分析</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2017-01-04</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Fragment/">
              Fragment
                
                  ，
                
              </a>
            
              <a href="/tags/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98/">
              状态保存
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>如同Activity、View等，状态的保存与恢复的重要性不言而喻，对于Fragment，在哪setRetainInstance，在什么时机save/restore State我们也早已熟练于心，但是为什么要这样、或者还有没有更多的skill却是稍显不足，也许探究一下整个机制的过程说不定就会恍然大悟。</p>
<p>在深入流程分析之前，我们需要明白状态的保存机制发生的前提：只要Activity不是被主动finish的，状态的保存与恢复机制就会被触发，导致onSaveInstanceState和onRestoreInstanceState的回调，包括了内存不足被killed、其它命令杀死进程等场景，甚至于手机的配置改变引发的Activity重建的情况（用户没有手动处理配置改变的情况下）。</p>
<h2 id="saveAllState"><a href="#saveAllState" class="headerlink" title="saveAllState"></a>saveAllState</h2><p>Fragment依附于Activity，因此Fragment的状态保存与恢复机制也是由Activity的相关方法触发。Activity的方法onSaveInstanceState的参数outState是系统在状态需要保存时用来提供存放持久化状态的容器，当系统触发状态保存时，在该方法中，通过对mFragments的saveAllState方法的调用，Activity下的Fragment的所有状态便保存在了 <code>FRAGMENTS_TAG</code> 键中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是saveAllState()具体保存了Fragment的哪些状态却不从得知。我们继续分析：<br>mFragments对象对应的类FragmentController是供Host(Activity)调用的一层FragmentManager的包装，FragmentManager下维护的所有Fragment的生命周期都是Host通过FragmentController来转发回调的，因此saveAllState()事件也被分发到了FragmentManager的saveAllState()中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Parcelable saveAllState() &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerState fms = new FragmentManagerState();</span><br><span class="line">    fms.mActive = active;</span><br><span class="line">    fms.mAdded = added;</span><br><span class="line">    fms.mBackStack = backStack;</span><br><span class="line">    return fms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，该方法将所有需要保存的状态归结为3种并封装到了一个FragmentManagerState可序列化对象中，我们依次来看看这三种状态分别是什么以及其具体的保存过程。</p>
<h4 id="fms-mActive"><a href="#fms-mActive" class="headerlink" title="fms.mActive"></a>fms.mActive</h4><p>mActive是一个FragmentState[]数组对象，而FragmentState类则是一个实现了Parcelable接口的实体，它负责对Fragment的基本变量进行序列化，包括了arguments、tag等信息，具体保存了哪些状态如下所示（字段代表的意义可以参考Fragment的字段详解）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public FragmentState(Fragment frag) &#123;</span><br><span class="line">    mClassName = frag.getClass().getName();</span><br><span class="line">    mIndex = frag.mIndex;</span><br><span class="line">    mFromLayout = frag.mFromLayout;</span><br><span class="line">    mFragmentId = frag.mFragmentId;</span><br><span class="line">    mContainerId = frag.mContainerId;</span><br><span class="line">    mTag = frag.mTag;</span><br><span class="line">    mRetainInstance = frag.mRetainInstance;</span><br><span class="line">    mDetached = frag.mDetached;</span><br><span class="line">    mArguments = frag.mArguments;</span><br><span class="line">    mHidden = frag.mHidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了以上字段外，FragmentState还预留了一个<code>Bundle mSavedFragmentState</code>来存储一些额外的状态，具体保存了什么接下来再分析；可见，这些字段足以代表了Fragment的实例基本状态。</p>
<p>因此可以简单说FragmentState就是对Fragment的基本状态的一个封装。</p>
<p>在需要save state时，只需要将对应的Fragment通过FragmentState构造方法传入，该Fragment实例的基本状态也就封装好了，在FragmentManager中具体实现过程如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">Parcelable saveAllState() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 若没有Fragment，就无需保存状态</span><br><span class="line">    if (mActive == null || mActive.size() &lt;= 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int N = mActive.size();</span><br><span class="line">    FragmentState[] active = new FragmentState[N];</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">        Fragment f = mActive.get(i);</span><br><span class="line">        if (f != null) &#123;</span><br><span class="line">            if (f.mIndex &lt; 0) &#123;</span><br><span class="line">                throwException(new IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            // 重点：遍历“活着”的Fragment，依次封装状态并存入active数组中。</span><br><span class="line">            FragmentState fs = new FragmentState(f);</span><br><span class="line">            active[i] = fs;</span><br><span class="line">            // 对处于正常生命周期状态下的Fragment，</span><br><span class="line">            // 还需要确保其与用户相关操作的变量以及视图层级等状态得到保存</span><br><span class="line">            if (f.mState &gt; Fragment.INITIALIZING &amp;&amp; fs.mSavedFragmentState == null) &#123;</span><br><span class="line">                // saveFragmentBasicState具体实现了以下操作：</span><br><span class="line">                // 1. 执行了Fragment的onSaveInstanceState方法；</span><br><span class="line">                // 1.1. 同时若存在子Fragment，也对子Fragment相关状态调用saveAllState进行了保存；</span><br><span class="line">                // 2. 调用saveFragmentViewState保存了视图层级状态；</span><br><span class="line">                // 3. 保存了用户可见性状态mUserVisibleHint；</span><br><span class="line">                fs.mSavedFragmentState = saveFragmentBasicState(f);</span><br><span class="line">                if (f.mTarget != null) &#123;</span><br><span class="line">                    if (f.mTarget.mIndex &lt; 0) &#123;</span><br><span class="line">                        throwException(new IllegalStateException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fs.mSavedFragmentState == null) &#123;</span><br><span class="line">                        fs.mSavedFragmentState = new Bundle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 同时，如果Fragment有target，还需要保存target对应的索引index</span><br><span class="line">                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);</span><br><span class="line">                    // 以及target的mTargetRequestCode</span><br><span class="line">                    if (f.mTargetRequestCode != 0) &#123;</span><br><span class="line">                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 最后，将mSavedFragmentState信息保存在FragmentState的额外字段mSavedFragmentState中；（有误）</span><br><span class="line">                fs.mSavedFragmentState = f.mSavedFragmentState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，最终除了Fragment的一些基本状态得到保存外，上面提到的额外字段mSavedFragmentState还存储了以下信息：</p>
<table>
<thead>
<tr>
<th>信息(Bundle’s Key)</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TARGET_STATE_TAG</code></td>
<td>target的index</td>
</tr>
<tr>
<td><code>TARGET_REQUEST_CODE_STATE_TAG</code></td>
<td>target的requestCode</td>
</tr>
<tr>
<td><code>VIEW_STATE_TAG</code></td>
<td>视图层级状态</td>
</tr>
<tr>
<td><code>USER_VISIBLE_HINT_TAG</code></td>
<td>mUserVisibleHint字段</td>
</tr>
<tr>
<td><code>FragmentActivity.FRAGMENTS_TAG</code></td>
<td>子FragmentManager下所维护的所有Fragment的状态</td>
</tr>
<tr>
<td>onSaveInstanceState(outState)</td>
<td>供用户手动保存的状态</td>
</tr>
</tbody>
</table>
<h4 id="fms-mAdded"><a href="#fms-mAdded" class="headerlink" title="fms.mAdded"></a>fms.mAdded</h4><p>mAdded是一个int[]型数组，被用来保存当前已经被added到FragmentManager下的所有fragments的index：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager#saveAllState()</span><br><span class="line">...</span><br><span class="line">if (mAdded != null) &#123;</span><br><span class="line">    N = mAdded.size();</span><br><span class="line">    if (N &gt; 0) &#123;</span><br><span class="line">        added = new int[N];</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            // 依次遍历mAdded数组，将Fragment对应的index添加至added</span><br><span class="line">            added[i] = mAdded.get(i).mIndex;</span><br><span class="line">            if (added[i] &lt; 0) &#123;</span><br><span class="line">                throwException(new IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="fms-mBackStack"><a href="#fms-mBackStack" class="headerlink" title="fms.mBackStack"></a>fms.mBackStack</h4><p>mBackStack也是一个数组，实现了Parcelable接口的BackStackState类是对FragmentManager下的回退栈<code>backStack</code>的状态的一个保存。我们可以看看它保存了哪些状态：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int[] mOps;</span><br><span class="line">final int mTransition;</span><br><span class="line">final int mTransitionStyle;</span><br><span class="line">final String mName;</span><br><span class="line">final int mIndex;</span><br><span class="line">final int mBreadCrumbTitleRes;</span><br><span class="line">final CharSequence mBreadCrumbTitleText;</span><br><span class="line">final int mBreadCrumbShortTitleRes;</span><br><span class="line">final CharSequence mBreadCrumbShortTitleText;</span><br><span class="line">final ArrayList&lt;String&gt; mSharedElementSourceNames;</span><br><span class="line">final ArrayList&lt;String&gt; mSharedElementTargetNames;</span><br></pre></td></tr></table></figure><br>每个字段所表示的意思可以参见BackStack类的字段详解。这里额外说明一下其中的<code>int[] mOps的</code>变量，它的每一小段（长度为<code>bse.mNumOp*7 + numRemoved</code>）表示的是一个回退栈中的单个事务：<img src="https://raw.githubusercontent.com/whataa/PicsRepo/master/BackStackState%20mOps.jpg" alt="image">  </p>
<blockquote>
<p>上图中index为6的元素如果为0，表示该事务不存在removed元素，所以该段长度就只有7；反之长度为7 + numRemoved。</p>
</blockquote>
<p>由于Op类并没有实现Parcelable接口，所以这里在保存Op对象时，对其进行了“扁平”转化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// BackStackState#BackStackState(BackStackRecord bse)</span><br><span class="line">...</span><br><span class="line">mOps = new int[bse.mNumOp*7 + numRemoved];</span><br><span class="line">...</span><br><span class="line">op = bse.mHead;</span><br><span class="line">int pos = 0;</span><br><span class="line">while (op != null) &#123;</span><br><span class="line">    mOps[pos++] = op.cmd;</span><br><span class="line">    mOps[pos++] = op.fragment != null ? op.fragment.mIndex : -1;</span><br><span class="line">    mOps[pos++] = op.enterAnim;</span><br><span class="line">    mOps[pos++] = op.exitAnim;</span><br><span class="line">    mOps[pos++] = op.popEnterAnim;</span><br><span class="line">    mOps[pos++] = op.popExitAnim;</span><br><span class="line">    if (op.removed != null) &#123;</span><br><span class="line">        final int N = op.removed.size();</span><br><span class="line">        mOps[pos++] = N;</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            mOps[pos++] = op.removed.get(i).mIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mOps[pos++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    op = op.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样使得mOps的每个元素都是一个基本变量，可以方便地被持久化。</p>
<h4 id="issue-mStateSaved"><a href="#issue-mStateSaved" class="headerlink" title="issue: mStateSaved"></a>issue: mStateSaved</h4><p>这里还有一个issue，具体可以参考Fragment字段详解中的<code>mStateSaved</code>说明。</p>
<p>意思是在Honeycomb(11)之前，save state是发生在onPause之前的，但是从版本11开始，save state的时机被修改为onPause之后了。因为对于Fragment，在pause后和stop前之间改变fragment的mstate是被允许的，因此对于老设备，为了使其和现在的逻辑保存一致（v4的兼容性），就没有在此处将mStateSaved置为true以防止在执行事务时检测到保存状态时机已经发生过了而抛出异常；</p>
<blockquote>
<p>这也就意味着，在版本11之前，在pause后stop之前执行Fragment事务，虽然不发生异常但存在状态丢失的风险。</p>
</blockquote>
<h3 id="NoConfig下的状态保存"><a href="#NoConfig下的状态保存" class="headerlink" title="NoConfig下的状态保存"></a>NoConfig下的状态保存</h3><p>除了前面提到的一些“正常的”条件下被killed的情况下的状态保存调用之外，还有一种情况就是：</p>
<blockquote>
<p>设备的配置改变引发Activity被re-created，即Activity立马被杀死并重新创建。</p>
</blockquote>
<p>我们知道，若不需要自行处理Activity在配置的变更下的变更（即在Manifest中未对Activity进行<code>android:configChanges</code>配置，所以称为<strong>NonConfig</strong>），Activity会被销毁并重建。在这种情况下，按正常流程处理，依附于Activity的Fragment也是会按照前面的保存状态流程被销毁然后恢复的。但是对于Fragment，我们可能会经常遇到这样的情况：其中存在某些处理过程不需要因此中断，例如线程，因此Fragment提供了一个叫做<code>setRetainInstance(true)</code>的方法来告知系统：在宿主Activity被销毁重建的过程中，该Fragment不需要随之也销毁重建，即需要保持实例。</p>
<p>上述特性可以在Fragment的onCreate中开启。一旦开启，在设备配置改变时，系统在销毁Activity前会回调<code>Activity#onRetainNonConfigurationInstance()</code>，用来保留一些可以传递到新Activity的实例，在FragmentActivity中该方法被重写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FragmentActivity</span><br><span class="line">@Override</span><br><span class="line">public final Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();</span><br><span class="line">    ...</span><br><span class="line">    NonConfigurationInstances nci = new NonConfigurationInstances();</span><br><span class="line">    ...</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    ...</span><br><span class="line">    return nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>mFragments.retainNestedNonConfig()</code>最终将事件分发到了<code>FragmentManager#retainNonConfig</code>方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">FragmentManagerNonConfig retainNonConfig() &#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; fragments = null;</span><br><span class="line">    ArrayList&lt;FragmentManagerNonConfig&gt; childFragments = null;</span><br><span class="line">    ...</span><br><span class="line">    for (int i=0; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 重要标识：仅当Fragment调用了setRetainInstance(true)，该实例才会被缓存在fragments中</span><br><span class="line">        if (f.mRetainInstance) &#123;</span><br><span class="line">            if (fragments == null) &#123;</span><br><span class="line">                fragments = new ArrayList&lt;Fragment&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            fragments.add(f);</span><br><span class="line">            // 开启该标识，以防止在moveToState时的部分生命周期方法的调用</span><br><span class="line">            f.mRetaining = true;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 当然，其嵌套子Fragments如果也开启了mRetainInstance，也会被保存</span><br><span class="line">        if (f.mChildFragmentManager != null) &#123;</span><br><span class="line">            FragmentManagerNonConfig child = f.mChildFragmentManager.retainNonConfig();</span><br><span class="line">            ...</span><br><span class="line">            childFragments.add(child);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果该FragmentManager下没有任何Fragment需要保持实例，则返回null</span><br><span class="line">    if (fragments == null &amp;&amp; childFragments == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后，将缓存包装在FragmentManagerNonConfig对象中返回</span><br><span class="line">    return new FragmentManagerNonConfig(fragments, childFragments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码中的注释已经很详细了，纵观整个方法的流程，其实就是将需要 保持实例的Fragment集合 及 其相应的嵌套子Fragment实例集合 都保存在了FragmentManagerNonConfig对象中并返回，FragmentActivity将得到的该对象又被包装在NonConfigurationInstances里返回给了系统。<br>这样，在设备配置改变时，通过setRetainInstance来告知需要保持实例的Fragment对象就在Activity的被销毁过程中被保存了下来。<br><img src="https://raw.githubusercontent.com/whataa/PicsRepo/master/FragmentManagerState.png" alt="image"></p>
<p>当然，如果我们在mainfest中配置了Activity的<code>android:configChanges</code>属性，即我们需要手动处理设备配置改变下的变化，那么也就意味着Activity不需要默认地被销毁重建，这样也就不存在Fragment保持实例这一说法了。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面分析了触发状态的保存机制的两种大的情况：分别是普通情况下例如内存不足、被其它软件杀死等，以及特殊情况——设备的配置改变。不论是哪一种情况，都会触发onSaveInstance方法的回调，即使是当设备配置改变时已经通过setRetainInstance告知了保留实例，这里需要特别注意。</p>
<p>并且，两种情况保存状态/实例的时机和位置是独立，也就是说onSaveInstance并不会因为setRetainInstance发生改变、或者retainNonConfig不会干扰setRetainInstance的执行和结果。</p>
<p>同时另一个需要注意的点就是：<strong>setRetainInstance起效的前提是设备的配置改变</strong> 这一情况，如果只是普通情况Activity被killed，Fragment依然会被销毁和稍后的恢复，即无法保持实例的，这时候只能通过onSaveInstance来保留一些状态。</p>
<h2 id="restoreAllState"><a href="#restoreAllState" class="headerlink" title="restoreAllState"></a>restoreAllState</h2><p>当Activity <code>re-created</code>时（包括了稍后用户手动从历史栈中回来或者配置改变引发的重建的情况），当前状态就应该恢复到上次被销毁时保存的状态。</p>
<p>我们知道，在Activity被create时，Activity里首次被调用的方法是attach(…)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void attach(...NonConfigurationInstances lastNonConfigurationInstances...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该方法中系统传入了上次包装实例的缓存对象<code>lastNonConfigurationInstances</code> （若存在，我们这里针对的就是存在的情况），然后在经历生命周期过程第一个方法onCreate时，Activity直接使用了该对象来恢复Fragments实例（针对<code>.app.Fragment</code>），在FragmentActivity中也是一样（针对<code>.app.v4.Fragment</code>）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Activity#onCreate</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">// FragmentActivity#onCreate</span><br><span class="line">...</span><br><span class="line">// getLastNonConfigurationInstance方法取就是传入Activity中的mLastNonConfigurationInstances对象</span><br><span class="line">NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">...</span><br><span class="line">if (savedInstanceState != null) &#123;</span><br><span class="line">    Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">    mFragments.restoreAllState(p, nc != null ? nc.fragments : null);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在存在savedInstanceState的前提下，在onCreate时直接依据<code>FRAGMENTS_TAG</code>键得到与Fragment相关的状态（若存在），然后调用了<code>mFragments.restoreAllState</code>方法，我们可以看到，传入的参数除了Fragment的状态之外，还包括了<code>NonConfigurationInstances.fragments</code>对象，该对象正是前面设备配置改变时，系统在销毁Activity前回调的<code>Activity#onRetainNonConfigurationInstance()</code>方法中保留下来的Fragment实例集合。也就是说，不论是那种触发状态保存机制的情况下保留的状态，最终在Activity re-created时，都会通过mFragments.restoreAllState入口将状态恢复。mFragments.restoreAllState最终将事件分发给了FragmentManager#restoreAllState方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager</span><br><span class="line">void restoreAllState(Parcelable state, FragmentManagerNonConfig nonConfig) &#123;</span><br><span class="line">    ...</span><br><span class="line">    FragmentManagerState fms = (FragmentManagerState)state;</span><br><span class="line">    ...</span><br><span class="line">    // step1</span><br><span class="line">    if (nonConfig != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step2</span><br><span class="line">    for (int i=0; i&lt;fms.mActive.length; i++) &#123;</span><br><span class="line">        FragmentState fs = fms.mActive[i];</span><br><span class="line">        if (fs != null) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // step3</span><br><span class="line">    if (nonConfig != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step4</span><br><span class="line">    if (fms.mAdded != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // step5</span><br><span class="line">    if (fms.mBackStack != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的流程可以大致分为5个步骤，FragmentManager通过这几个步骤恢复了自身的一些状态，也就恢复了所辖的所有Fragment。</p>
<h3 id="Step-1：将保持的Fragment实例关联至FragmentState"><a href="#Step-1：将保持的Fragment实例关联至FragmentState" class="headerlink" title="Step 1：将保持的Fragment实例关联至FragmentState"></a>Step 1：将保持的Fragment实例关联至FragmentState</h3><p>由于可能存在保持了实例的Fragment，所以在该步骤中，需要将这些实例关联到上次保存的Fragment状态对象FragmentState中，这样在接下来的步骤中就不需要实例化对应的Fragment对象了（因为下面的步骤会依据保存的状态来实例化新的Fragment对象）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # restoreAllState()</span><br><span class="line">if (nonConfig != null) &#123;</span><br><span class="line">    List&lt;Fragment&gt; nonConfigFragments = nonConfig.getFragments();</span><br><span class="line">    childNonConfigs = nonConfig.getChildNonConfigs();</span><br><span class="line">    final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 得到保持的实例对象</span><br><span class="line">        Fragment f = nonConfigFragments.get(i);</span><br><span class="line">        // 取出实例对象在保存了状态的数组中对应的FragmentState</span><br><span class="line">        FragmentState fs = fms.mActive[f.mIndex];</span><br><span class="line">        // 将实例关联到对应的FragmentState</span><br><span class="line">        fs.mInstance = f;</span><br><span class="line">        f.mSavedViewState = null;</span><br><span class="line">        f.mBackStackNesting = 0;</span><br><span class="line">        f.mInLayout = false;</span><br><span class="line">        f.mAdded = false;</span><br><span class="line">        f.mTarget = null;</span><br><span class="line">        if (fs.mSavedFragmentState != null) &#123;</span><br><span class="line">            fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());</span><br><span class="line">            f.mSavedViewState =FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">            f.mSavedFragmentState = fs.mSavedFragmentState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Step2：恢复FragmentManager-mActive"><a href="#Step2：恢复FragmentManager-mActive" class="headerlink" title="Step2：恢复FragmentManager#mActive"></a>Step2：恢复FragmentManager#mActive</h3><p>在将保存的状态和保持的实例合并后，接下来就需要开始遍历fms.mActive，将保存的Fragment状态依次恢复：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager # restoreAllState()</span><br><span class="line">for (int i=0; i&lt;fms.mActive.length; i++) &#123;</span><br><span class="line">    FragmentState fs = fms.mActive[i];</span><br><span class="line">    if (fs != null) &#123;</span><br><span class="line">        FragmentManagerNonConfig childNonConfig = null;</span><br><span class="line">        if (childNonConfigs != null &amp;&amp; i &lt; childNonConfigs.size()) &#123;</span><br><span class="line">            // 拿到Fragment的子Fragment的实例</span><br><span class="line">            childNonConfig = childNonConfigs.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 该方法通过FragmentState保存的状态返回一个Fragment实例</span><br><span class="line">        Fragment f = fs.instantiate(mHost, mParent, childNonConfig);</span><br><span class="line">        // 将（重新实例化）的Fragment对象关联到mActive数组中</span><br><span class="line">        mActive.add(f);</span><br><span class="line">        // 清空mInstance字段，以防最后再次从中恢复</span><br><span class="line">        fs.mInstance = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mActive.add(null);</span><br><span class="line">        if (mAvailIndices == null) &#123;</span><br><span class="line">            mAvailIndices = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;restoreAllState: avail #&quot; + i);</span><br><span class="line">        mAvailIndices.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中的<code>fs.instantiate(mHost, mParent, childNonConfig)</code>方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// FragmentState</span><br><span class="line">public Fragment instantiate(FragmentHostCallback host, Fragment parent, FragmentManagerNonConfig childNonConfig) &#123;</span><br><span class="line">    // mInstance是上一步关联进来的保持了实例的Fragment对象</span><br><span class="line">    if (mInstance == null) &#123;</span><br><span class="line">        final Context context = host.getContext();</span><br><span class="line">        if (mArguments != null) &#123;</span><br><span class="line">            mArguments.setClassLoader(context.getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        // 最终通过Fragment的instantiate方法得到了一个全新的Fragment对象</span><br><span class="line">        mInstance = Fragment.instantiate(context, mClassName, mArguments);</span><br><span class="line">        if (mSavedFragmentState != null) &#123;</span><br><span class="line">            mSavedFragmentState.setClassLoader(context.getClassLoader());</span><br><span class="line">            mInstance.mSavedFragmentState = mSavedFragmentState;</span><br><span class="line">        &#125;</span><br><span class="line">        mInstance.setIndex(mIndex, parent);</span><br><span class="line">        mInstance.mFromLayout = mFromLayout;</span><br><span class="line">        mInstance.mRestored = true;</span><br><span class="line">        mInstance.mFragmentId = mFragmentId;</span><br><span class="line">        mInstance.mContainerId = mContainerId;</span><br><span class="line">        mInstance.mTag = mTag;</span><br><span class="line">        mInstance.mRetainInstance = mRetainInstance;</span><br><span class="line">        mInstance.mDetached = mDetached;</span><br><span class="line">        mInstance.mHidden = mHidden;</span><br><span class="line">        mInstance.mFragmentManager = host.mFragmentManager;</span><br><span class="line">    &#125;</span><br><span class="line">    mInstance.mChildNonConfig = childNonConfig;</span><br><span class="line">    return mInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Fragment.instantiate(…)方法会根据所给的class name加载对应的Class类，调用<code>clazz.newInstance()</code>新建一个全新的Fragment对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Fragment f = (Fragment)clazz.newInstance();</span><br><span class="line">    if (args != null) &#123;</span><br><span class="line">        args.setClassLoader(f.getClass().getClassLoader());</span><br><span class="line">        f.mArguments = args;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到Fragment对象后，我们还发现紧接下来第一件事就是为之绑定mArguments（若存在），所以如果需要传递一些简单的或者受限于生命周期的可持久化的参数，推荐使用<code>setArguments(Bundle)</code>方式。</p>
<p>另外，这里需要显式地强调一点：虽然在上面的<code>FragmentState#instantiate</code>方法中，保持了实例的Fragment的mSavedFragmentState字段并没有被赋值，但是状态的恢复机制依然与正常的流程一样。因为保持了实例就意味着该实例下的状态也会被保持。</p>
<h3 id="Step3：关联恢复的Fragment的target"><a href="#Step3：关联恢复的Fragment的target" class="headerlink" title="Step3：关联恢复的Fragment的target"></a>Step3：关联恢复的Fragment的target</h3><p>关于Target字段是什么可以参考Fragment的字段详解。</p>
<p>保存了的状态对应的Fragment实例恢复后，这一步就主要根据Fragment对应的target索引，来讲索引替换为对应的Fragment实例，当然，target索引对应的实例存在的前提是该target之前使用了<code>Fragment#setRetainInstance</code>机制来保持实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (nonConfig != null) &#123;</span><br><span class="line">    List&lt;Fragment&gt; nonConfigFragments = nonConfig.getFragments();</span><br><span class="line">    final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Fragment f = nonConfigFragments.get(i);</span><br><span class="line">        if (f.mTargetIndex &gt;= 0) &#123;</span><br><span class="line">            if (f.mTargetIndex &lt; mActive.size()) &#123;</span><br><span class="line">                f.mTarget = mActive.get(f.mTargetIndex);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                f.mTarget = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这一步我们也可以知道，Fragment对应的Target在状态的保存与恢复机制下，默认只会保留target的索引index，如果target正好启用了setRetainInstance特性，那么target就会被关联至相应的Fragment。</p>
<h3 id="Step4：恢复FragmentManager-mAdded"><a href="#Step4：恢复FragmentManager-mAdded" class="headerlink" title="Step4：恢复FragmentManager#mAdded"></a>Step4：恢复FragmentManager#mAdded</h3><p>接下来，开始恢复mAdded，FragmentManager#mAdded字段主要作用就是记录已经add到Activity上的Fragment：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (fms.mAdded != null) &#123;</span><br><span class="line">    // 依据的就是在saveAllState时保存的fms.mAdded数组</span><br><span class="line">    // 该数组保存的是已经Add的Fragment在mActive对应是索引</span><br><span class="line">    mAdded = new ArrayList&lt;Fragment&gt;(fms.mAdded.length);</span><br><span class="line">    for (int i=0; i&lt;fms.mAdded.length; i++) &#123;</span><br><span class="line">        Fragment f = mActive.get(fms.mAdded[i]);</span><br><span class="line">        if (f == null) &#123;</span><br><span class="line">            throwException(new IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        f.mAdded = true;</span><br><span class="line">        if (mAdded.contains(f)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Already added!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mAdded.add(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mAdded = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Step5：恢复FragmentManager-mBackStack"><a href="#Step5：恢复FragmentManager-mBackStack" class="headerlink" title="Step5：恢复FragmentManager#mBackStack"></a>Step5：恢复FragmentManager#mBackStack</h3><p>与第4步一样，这里通过在saveAllState时保存的fms.mBackStack数组依次恢复FragmentManager的回退栈中的BackStackRecord信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (fms.mBackStack != null) &#123;</span><br><span class="line">    mBackStack = new ArrayList&lt;BackStackRecord&gt;(fms.mBackStack.length);</span><br><span class="line">    for (int i=0; i&lt;fms.mBackStack.length; i++) &#123;</span><br><span class="line">        BackStackRecord bse = fms.mBackStack[i].instantiate(this);</span><br><span class="line">        mBackStack.add(bse);</span><br><span class="line">        if (bse.mIndex &gt;= 0) &#123;</span><br><span class="line">            setBackStackIndex(bse.mIndex, bse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mBackStack = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>BackStackState#instantiate方法中，依据了在saveAllState时，构造BackStackState的规则来完整地恢复BackStackRecord的各个字段，包括<code>mOps</code>，具体可以参见BackStackState类。</p>
<p>至此，该方法的流程就走完了，期间Fragment除了实例化并恢复了基本状态，却并没有发生状态转移(<code>moveToState</code>)，Fragment的<code>mState</code>字段依然是<code>INITIALIZING</code>状态，也就是说，对于整个大流程而言，还差一步状态的转移，Fragment的整体状态就可以恢复为应用上次离开(killed)时的样子了。而这一步就发生在Activity的onCreate方法里mFragments.restoreAllState的后面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Activity | FragmentActivity</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFragments.restoreAllState(...);</span><br><span class="line">    ...// here</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mFragments.dispatchCreate()方法就很熟悉了，具体可以参见Fragment的生命周期状态分析一文。这里仅列出在saveAllState时保存在各个Key下的状态通过dispatchCreate的触发，最终是在什么地方被恢复的，dispatchCreate()最终来到了moveState的5个参数的方法中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// FragmentManager#moveState</span><br><span class="line">...</span><br><span class="line">if (f.mState &lt; newState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch (f.mState) &#123;</span><br><span class="line">        case Fragment.INITIALIZING:</span><br><span class="line">            ...</span><br><span class="line">            if (f.mSavedFragmentState != null) &#123;</span><br><span class="line">                f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());</span><br><span class="line">                f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">                f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);</span><br><span class="line">                if (f.mTarget != null) &#123;</span><br><span class="line">                    f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            if (!f.mRetaining) &#123;</span><br><span class="line">                f.performCreate(f.mSavedFragmentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                f.restoreChildFragmentState(f.mSavedFragmentState);</span><br><span class="line">                f.mState = Fragment.CREATED;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>上面同时恢复的字段包括了<code>mSavedViewState 、mTarget 、mTargetRequestCode 、mUserVisibleHint</code>等，对于<code>mSavedFragmentState</code>，Fragment的生命周期方法中的这些方法也会用到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">if (f.mView != null) &#123;</span><br><span class="line">    f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，我们可以选择在以上生命周期任何一个方法中来恢复我们先前保存的状态，并且这些状态都是同一个对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析Fragment的状态保存与恢复实则是分析FragmentManager的状态保存与恢复，对于Fragment的管理类，除了Fragment个体的状态保存恢复，Fragment之间在FragmentManager下的相互关系、结构栈等也需要维持，因此整个过程以FragmentManagerState为核心，经历了FragmentManagerState的“构造、持久化、还原”三大步骤，逐步完成了FragmentManager的状态保存与恢复。具体来说，就是在destroy前保存相关字段状态，交由系统管理，然后在re-created Activity时，先后创建全新FragmentManager及相关Fragment对象来关联上次保存的状态字段，实现状态的恢复。</p>
<p>本篇属于个人计划的分析Fragment系列。关于Fragment的字段详解、静态/动态加载流程、生命周期和状态的切换以及常见异常解决方案等的分析会陆续完成，欢迎关注。</p>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#saveAllState"><span class="top-box-text">saveAllState</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#NoConfig%E4%B8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98"><span class="top-box-text">NoConfig下的状态保存</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%B3%A8%E6%84%8F"><span class="top-box-text">注意</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#restoreAllState"><span class="top-box-text">restoreAllState</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Step-1%EF%BC%9A%E5%B0%86%E4%BF%9D%E6%8C%81%E7%9A%84Fragment%E5%AE%9E%E4%BE%8B%E5%85%B3%E8%81%94%E8%87%B3FragmentState"><span class="top-box-text">Step 1：将保持的Fragment实例关联至FragmentState</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Step2%EF%BC%9A%E6%81%A2%E5%A4%8DFragmentManager-mActive"><span class="top-box-text">Step2：恢复FragmentManager#mActive</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Step3%EF%BC%9A%E5%85%B3%E8%81%94%E6%81%A2%E5%A4%8D%E7%9A%84Fragment%E7%9A%84target"><span class="top-box-text">Step3：关联恢复的Fragment的target</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Step4%EF%BC%9A%E6%81%A2%E5%A4%8DFragmentManager-mAdded"><span class="top-box-text">Step4：恢复FragmentManager#mAdded</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Step5%EF%BC%9A%E6%81%A2%E5%A4%8DFragmentManager-mBackStack"><span class="top-box-text">Step5：恢复FragmentManager#mBackStack</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2016/12/30/Android%20Studio%20Patches%20Update/">
          <h3 class="post-title">
            下一篇：以Patch的形式更新Android Studio
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/whataa" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

